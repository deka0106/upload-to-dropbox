{"version":3,"file":"index.js","sources":["../webpack://upload-to-dropbox/./lib/main.js","../webpack://upload-to-dropbox/./lib/upload.js","../webpack://upload-to-dropbox/./lib/utils.js","../webpack://upload-to-dropbox/./node_modules/@actions/core/lib/command.js","../webpack://upload-to-dropbox/./node_modules/@actions/core/lib/core.js","../webpack://upload-to-dropbox/./node_modules/@actions/core/lib/file-command.js","../webpack://upload-to-dropbox/./node_modules/@actions/core/lib/utils.js","../webpack://upload-to-dropbox/./node_modules/@nodelib/fs.scandir/out/adapters/fs.js","../webpack://upload-to-dropbox/./node_modules/@nodelib/fs.scandir/out/constants.js","../webpack://upload-to-dropbox/./node_modules/@nodelib/fs.scandir/out/index.js","../webpack://upload-to-dropbox/./node_modules/@nodelib/fs.scandir/out/providers/async.js","../webpack://upload-to-dropbox/./node_modules/@nodelib/fs.scandir/out/providers/sync.js","../webpack://upload-to-dropbox/./node_modules/@nodelib/fs.scandir/out/settings.js","../webpack://upload-to-dropbox/./node_modules/@nodelib/fs.scandir/out/utils/fs.js","../webpack://upload-to-dropbox/./node_modules/@nodelib/fs.scandir/out/utils/index.js","../webpack://upload-to-dropbox/./node_modules/@nodelib/fs.stat/out/adapters/fs.js","../webpack://upload-to-dropbox/./node_modules/@nodelib/fs.stat/out/index.js","../webpack://upload-to-dropbox/./node_modules/@nodelib/fs.stat/out/providers/async.js","../webpack://upload-to-dropbox/./node_modules/@nodelib/fs.stat/out/providers/sync.js","../webpack://upload-to-dropbox/./node_modules/@nodelib/fs.stat/out/settings.js","../webpack://upload-to-dropbox/./node_modules/@nodelib/fs.walk/out/index.js","../webpack://upload-to-dropbox/./node_modules/@nodelib/fs.walk/out/providers/async.js","../webpack://upload-to-dropbox/./node_modules/@nodelib/fs.walk/out/providers/stream.js","../webpack://upload-to-dropbox/./node_modules/@nodelib/fs.walk/out/providers/sync.js","../webpack://upload-to-dropbox/./node_modules/@nodelib/fs.walk/out/readers/async.js","../webpack://upload-to-dropbox/./node_modules/@nodelib/fs.walk/out/readers/common.js","../webpack://upload-to-dropbox/./node_modules/@nodelib/fs.walk/out/readers/reader.js","../webpack://upload-to-dropbox/./node_modules/@nodelib/fs.walk/out/readers/sync.js","../webpack://upload-to-dropbox/./node_modules/@nodelib/fs.walk/out/settings.js","../webpack://upload-to-dropbox/./node_modules/array-union/index.js","../webpack://upload-to-dropbox/./node_modules/braces/index.js","../webpack://upload-to-dropbox/./node_modules/braces/lib/compile.js","../webpack://upload-to-dropbox/./node_modules/braces/lib/constants.js","../webpack://upload-to-dropbox/./node_modules/braces/lib/expand.js","../webpack://upload-to-dropbox/./node_modules/braces/lib/parse.js","../webpack://upload-to-dropbox/./node_modules/braces/lib/stringify.js","../webpack://upload-to-dropbox/./node_modules/braces/lib/utils.js","../webpack://upload-to-dropbox/./node_modules/dir-glob/index.js","../webpack://upload-to-dropbox/./node_modules/dropbox/cjs/index.js","../webpack://upload-to-dropbox/./node_modules/dropbox/cjs/lib/routes.js","../webpack://upload-to-dropbox/./node_modules/dropbox/cjs/src/auth.js","../webpack://upload-to-dropbox/./node_modules/dropbox/cjs/src/constants.js","../webpack://upload-to-dropbox/./node_modules/dropbox/cjs/src/dropbox.js","../webpack://upload-to-dropbox/./node_modules/dropbox/cjs/src/error.js","../webpack://upload-to-dropbox/./node_modules/dropbox/cjs/src/response.js","../webpack://upload-to-dropbox/./node_modules/dropbox/cjs/src/utils.js","../webpack://upload-to-dropbox/./node_modules/fast-glob/out/index.js","../webpack://upload-to-dropbox/./node_modules/fast-glob/out/managers/tasks.js","../webpack://upload-to-dropbox/./node_modules/fast-glob/out/providers/async.js","../webpack://upload-to-dropbox/./node_modules/fast-glob/out/providers/filters/deep.js","../webpack://upload-to-dropbox/./node_modules/fast-glob/out/providers/filters/entry.js","../webpack://upload-to-dropbox/./node_modules/fast-glob/out/providers/filters/error.js","../webpack://upload-to-dropbox/./node_modules/fast-glob/out/providers/matchers/matcher.js","../webpack://upload-to-dropbox/./node_modules/fast-glob/out/providers/matchers/partial.js","../webpack://upload-to-dropbox/./node_modules/fast-glob/out/providers/provider.js","../webpack://upload-to-dropbox/./node_modules/fast-glob/out/providers/stream.js","../webpack://upload-to-dropbox/./node_modules/fast-glob/out/providers/sync.js","../webpack://upload-to-dropbox/./node_modules/fast-glob/out/providers/transformers/entry.js","../webpack://upload-to-dropbox/./node_modules/fast-glob/out/readers/reader.js","../webpack://upload-to-dropbox/./node_modules/fast-glob/out/readers/stream.js","../webpack://upload-to-dropbox/./node_modules/fast-glob/out/readers/sync.js","../webpack://upload-to-dropbox/./node_modules/fast-glob/out/settings.js","../webpack://upload-to-dropbox/./node_modules/fast-glob/out/utils/array.js","../webpack://upload-to-dropbox/./node_modules/fast-glob/out/utils/errno.js","../webpack://upload-to-dropbox/./node_modules/fast-glob/out/utils/fs.js","../webpack://upload-to-dropbox/./node_modules/fast-glob/out/utils/index.js","../webpack://upload-to-dropbox/./node_modules/fast-glob/out/utils/path.js","../webpack://upload-to-dropbox/./node_modules/fast-glob/out/utils/pattern.js","../webpack://upload-to-dropbox/./node_modules/fast-glob/out/utils/stream.js","../webpack://upload-to-dropbox/./node_modules/fast-glob/out/utils/string.js","../webpack://upload-to-dropbox/./node_modules/fastq/queue.js","../webpack://upload-to-dropbox/./node_modules/fill-range/index.js","../webpack://upload-to-dropbox/./node_modules/glob-parent/index.js","../webpack://upload-to-dropbox/./node_modules/globby/gitignore.js","../webpack://upload-to-dropbox/./node_modules/globby/index.js","../webpack://upload-to-dropbox/./node_modules/globby/stream-utils.js","../webpack://upload-to-dropbox/./node_modules/ignore/index.js","../webpack://upload-to-dropbox/./node_modules/is-extglob/index.js","../webpack://upload-to-dropbox/./node_modules/is-glob/index.js","../webpack://upload-to-dropbox/./node_modules/is-number/index.js","../webpack://upload-to-dropbox/./node_modules/merge2/index.js","../webpack://upload-to-dropbox/./node_modules/micromatch/index.js","../webpack://upload-to-dropbox/./node_modules/node-fetch/lib/index.js","../webpack://upload-to-dropbox/./node_modules/path-type/index.js","../webpack://upload-to-dropbox/./node_modules/picomatch/index.js","../webpack://upload-to-dropbox/./node_modules/picomatch/lib/constants.js","../webpack://upload-to-dropbox/./node_modules/picomatch/lib/parse.js","../webpack://upload-to-dropbox/./node_modules/picomatch/lib/picomatch.js","../webpack://upload-to-dropbox/./node_modules/picomatch/lib/scan.js","../webpack://upload-to-dropbox/./node_modules/picomatch/lib/utils.js","../webpack://upload-to-dropbox/./node_modules/reusify/reusify.js","../webpack://upload-to-dropbox/./node_modules/run-parallel/index.js","../webpack://upload-to-dropbox/./node_modules/slash/index.js","../webpack://upload-to-dropbox/./node_modules/to-regex-range/index.js","../webpack://upload-to-dropbox/./node_modules/@vercel/ncc/dist/ncc/@@notfound.js","../webpack://upload-to-dropbox/external \"crypto\"","../webpack://upload-to-dropbox/external \"events\"","../webpack://upload-to-dropbox/external \"fs\"","../webpack://upload-to-dropbox/external \"http\"","../webpack://upload-to-dropbox/external \"https\"","../webpack://upload-to-dropbox/external \"os\"","../webpack://upload-to-dropbox/external \"path\"","../webpack://upload-to-dropbox/external \"stream\"","../webpack://upload-to-dropbox/external \"url\"","../webpack://upload-to-dropbox/external \"util\"","../webpack://upload-to-dropbox/external \"zlib\"","../webpack://upload-to-dropbox/webpack/bootstrap","../webpack://upload-to-dropbox/webpack/runtime/compat","../webpack://upload-to-dropbox/webpack/startup"],"sourcesContent":["\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst globby_1 = __importDefault(require(\"globby\"));\nconst core = __importStar(require(\"@actions/core\"));\nconst fs = __importStar(require(\"fs\"));\nconst path_1 = require(\"path\");\nconst upload_1 = require(\"./upload\");\nconst utils_1 = require(\"./utils\");\nconst accessToken = core.getInput('dropbox_access_token');\nconst src = core.getInput('src');\nconst dest = core.getInput('dest');\nconst multiple = utils_1.asBoolean(core.getInput('multiple'));\nconst mode = core.getInput('mode');\nconst autorename = utils_1.asBoolean(core.getInput('autorename'));\nconst mute = utils_1.asBoolean(core.getInput('mute'));\nasync function run() {\n    try {\n        const { upload } = upload_1.makeUpload(accessToken);\n        if (!multiple) {\n            const contents = await fs.promises.readFile(src);\n            if (utils_1.isDirectory(dest)) {\n                const path = path_1.join(dest, path_1.basename(src));\n                await upload(path, contents, { mode, autorename, mute });\n                core.info(`Uploaded: ${src} -> ${path}`);\n            }\n            else {\n                await upload(dest, contents, { mode, autorename, mute });\n                core.info(`Uploaded: ${src} -> ${dest}`);\n            }\n        }\n        else {\n            const files = await globby_1.default(src);\n            await Promise.all(files.map(async (file) => {\n                const path = path_1.join(dest, file);\n                const contents = await fs.promises.readFile(file);\n                await upload(path, contents, { mode, autorename, mute });\n                core.info(`Uploaded: ${file} -> ${path}`);\n            }));\n        }\n    }\n    catch (error) {\n        core.setFailed(error);\n    }\n}\nvoid run();\n","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.makeUpload = void 0;\nconst dropbox_1 = require(\"dropbox\");\nconst node_fetch_1 = __importDefault(require(\"node-fetch\"));\nfunction makeUpload(accessToken) {\n    const dropbox = new dropbox_1.Dropbox({ accessToken, fetch: node_fetch_1.default });\n    return {\n        upload: async (path, contents, options) => {\n            await dropbox.filesUpload({\n                path,\n                contents,\n                mode: getMode(options.mode),\n                autorename: options.autorename,\n                mute: options.mute,\n            });\n        },\n    };\n}\nexports.makeUpload = makeUpload;\nfunction getMode(mode) {\n    switch (mode) {\n        case 'overwrite':\n            return {\n                '.tag': 'overwrite',\n            };\n        case 'add':\n        default:\n            return {\n                '.tag': 'add',\n            };\n    }\n}\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.asBoolean = exports.isDirectory = void 0;\nfunction isDirectory(path) {\n    return path.endsWith('/');\n}\nexports.isDirectory = isDirectory;\nfunction asBoolean(s) {\n    return s.toLowerCase() === 'true';\n}\nexports.asBoolean = asBoolean;\n","\"use strict\";\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\n    result[\"default\"] = mod;\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst os = __importStar(require(\"os\"));\nconst utils_1 = require(\"./utils\");\n/**\n * Commands\n *\n * Command Format:\n *   ::name key=value,key=value::message\n *\n * Examples:\n *   ::warning::This is the message\n *   ::set-env name=MY_VAR::some value\n */\nfunction issueCommand(command, properties, message) {\n    const cmd = new Command(command, properties, message);\n    process.stdout.write(cmd.toString() + os.EOL);\n}\nexports.issueCommand = issueCommand;\nfunction issue(name, message = '') {\n    issueCommand(name, {}, message);\n}\nexports.issue = issue;\nconst CMD_STRING = '::';\nclass Command {\n    constructor(command, properties, message) {\n        if (!command) {\n            command = 'missing.command';\n        }\n        this.command = command;\n        this.properties = properties;\n        this.message = message;\n    }\n    toString() {\n        let cmdStr = CMD_STRING + this.command;\n        if (this.properties && Object.keys(this.properties).length > 0) {\n            cmdStr += ' ';\n            let first = true;\n            for (const key in this.properties) {\n                if (this.properties.hasOwnProperty(key)) {\n                    const val = this.properties[key];\n                    if (val) {\n                        if (first) {\n                            first = false;\n                        }\n                        else {\n                            cmdStr += ',';\n                        }\n                        cmdStr += `${key}=${escapeProperty(val)}`;\n                    }\n                }\n            }\n        }\n        cmdStr += `${CMD_STRING}${escapeData(this.message)}`;\n        return cmdStr;\n    }\n}\nfunction escapeData(s) {\n    return utils_1.toCommandValue(s)\n        .replace(/%/g, '%25')\n        .replace(/\\r/g, '%0D')\n        .replace(/\\n/g, '%0A');\n}\nfunction escapeProperty(s) {\n    return utils_1.toCommandValue(s)\n        .replace(/%/g, '%25')\n        .replace(/\\r/g, '%0D')\n        .replace(/\\n/g, '%0A')\n        .replace(/:/g, '%3A')\n        .replace(/,/g, '%2C');\n}\n//# sourceMappingURL=command.js.map","\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\n    result[\"default\"] = mod;\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst command_1 = require(\"./command\");\nconst file_command_1 = require(\"./file-command\");\nconst utils_1 = require(\"./utils\");\nconst os = __importStar(require(\"os\"));\nconst path = __importStar(require(\"path\"));\n/**\n * The code to exit an action\n */\nvar ExitCode;\n(function (ExitCode) {\n    /**\n     * A code indicating that the action was successful\n     */\n    ExitCode[ExitCode[\"Success\"] = 0] = \"Success\";\n    /**\n     * A code indicating that the action was a failure\n     */\n    ExitCode[ExitCode[\"Failure\"] = 1] = \"Failure\";\n})(ExitCode = exports.ExitCode || (exports.ExitCode = {}));\n//-----------------------------------------------------------------------\n// Variables\n//-----------------------------------------------------------------------\n/**\n * Sets env variable for this action and future actions in the job\n * @param name the name of the variable to set\n * @param val the value of the variable. Non-string values will be converted to a string via JSON.stringify\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction exportVariable(name, val) {\n    const convertedVal = utils_1.toCommandValue(val);\n    process.env[name] = convertedVal;\n    const filePath = process.env['GITHUB_ENV'] || '';\n    if (filePath) {\n        const delimiter = '_GitHubActionsFileCommandDelimeter_';\n        const commandValue = `${name}<<${delimiter}${os.EOL}${convertedVal}${os.EOL}${delimiter}`;\n        file_command_1.issueCommand('ENV', commandValue);\n    }\n    else {\n        command_1.issueCommand('set-env', { name }, convertedVal);\n    }\n}\nexports.exportVariable = exportVariable;\n/**\n * Registers a secret which will get masked from logs\n * @param secret value of the secret\n */\nfunction setSecret(secret) {\n    command_1.issueCommand('add-mask', {}, secret);\n}\nexports.setSecret = setSecret;\n/**\n * Prepends inputPath to the PATH (for this action and future actions)\n * @param inputPath\n */\nfunction addPath(inputPath) {\n    const filePath = process.env['GITHUB_PATH'] || '';\n    if (filePath) {\n        file_command_1.issueCommand('PATH', inputPath);\n    }\n    else {\n        command_1.issueCommand('add-path', {}, inputPath);\n    }\n    process.env['PATH'] = `${inputPath}${path.delimiter}${process.env['PATH']}`;\n}\nexports.addPath = addPath;\n/**\n * Gets the value of an input.  The value is also trimmed.\n *\n * @param     name     name of the input to get\n * @param     options  optional. See InputOptions.\n * @returns   string\n */\nfunction getInput(name, options) {\n    const val = process.env[`INPUT_${name.replace(/ /g, '_').toUpperCase()}`] || '';\n    if (options && options.required && !val) {\n        throw new Error(`Input required and not supplied: ${name}`);\n    }\n    return val.trim();\n}\nexports.getInput = getInput;\n/**\n * Sets the value of an output.\n *\n * @param     name     name of the output to set\n * @param     value    value to store. Non-string values will be converted to a string via JSON.stringify\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction setOutput(name, value) {\n    command_1.issueCommand('set-output', { name }, value);\n}\nexports.setOutput = setOutput;\n/**\n * Enables or disables the echoing of commands into stdout for the rest of the step.\n * Echoing is disabled by default if ACTIONS_STEP_DEBUG is not set.\n *\n */\nfunction setCommandEcho(enabled) {\n    command_1.issue('echo', enabled ? 'on' : 'off');\n}\nexports.setCommandEcho = setCommandEcho;\n//-----------------------------------------------------------------------\n// Results\n//-----------------------------------------------------------------------\n/**\n * Sets the action status to failed.\n * When the action exits it will be with an exit code of 1\n * @param message add error issue message\n */\nfunction setFailed(message) {\n    process.exitCode = ExitCode.Failure;\n    error(message);\n}\nexports.setFailed = setFailed;\n//-----------------------------------------------------------------------\n// Logging Commands\n//-----------------------------------------------------------------------\n/**\n * Gets whether Actions Step Debug is on or not\n */\nfunction isDebug() {\n    return process.env['RUNNER_DEBUG'] === '1';\n}\nexports.isDebug = isDebug;\n/**\n * Writes debug message to user log\n * @param message debug message\n */\nfunction debug(message) {\n    command_1.issueCommand('debug', {}, message);\n}\nexports.debug = debug;\n/**\n * Adds an error issue\n * @param message error issue message. Errors will be converted to string via toString()\n */\nfunction error(message) {\n    command_1.issue('error', message instanceof Error ? message.toString() : message);\n}\nexports.error = error;\n/**\n * Adds an warning issue\n * @param message warning issue message. Errors will be converted to string via toString()\n */\nfunction warning(message) {\n    command_1.issue('warning', message instanceof Error ? message.toString() : message);\n}\nexports.warning = warning;\n/**\n * Writes info to log with console.log.\n * @param message info message\n */\nfunction info(message) {\n    process.stdout.write(message + os.EOL);\n}\nexports.info = info;\n/**\n * Begin an output group.\n *\n * Output until the next `groupEnd` will be foldable in this group\n *\n * @param name The name of the output group\n */\nfunction startGroup(name) {\n    command_1.issue('group', name);\n}\nexports.startGroup = startGroup;\n/**\n * End an output group.\n */\nfunction endGroup() {\n    command_1.issue('endgroup');\n}\nexports.endGroup = endGroup;\n/**\n * Wrap an asynchronous function call in a group.\n *\n * Returns the same type as the function itself.\n *\n * @param name The name of the group\n * @param fn The function to wrap in the group\n */\nfunction group(name, fn) {\n    return __awaiter(this, void 0, void 0, function* () {\n        startGroup(name);\n        let result;\n        try {\n            result = yield fn();\n        }\n        finally {\n            endGroup();\n        }\n        return result;\n    });\n}\nexports.group = group;\n//-----------------------------------------------------------------------\n// Wrapper action state\n//-----------------------------------------------------------------------\n/**\n * Saves state for current action, the state can only be retrieved by this action's post job execution.\n *\n * @param     name     name of the state to store\n * @param     value    value to store. Non-string values will be converted to a string via JSON.stringify\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction saveState(name, value) {\n    command_1.issueCommand('save-state', { name }, value);\n}\nexports.saveState = saveState;\n/**\n * Gets the value of an state set by this action's main execution.\n *\n * @param     name     name of the state to get\n * @returns   string\n */\nfunction getState(name) {\n    return process.env[`STATE_${name}`] || '';\n}\nexports.getState = getState;\n//# sourceMappingURL=core.js.map","\"use strict\";\n// For internal use, subject to change.\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\n    result[\"default\"] = mod;\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n// We use any as a valid input type\n/* eslint-disable @typescript-eslint/no-explicit-any */\nconst fs = __importStar(require(\"fs\"));\nconst os = __importStar(require(\"os\"));\nconst utils_1 = require(\"./utils\");\nfunction issueCommand(command, message) {\n    const filePath = process.env[`GITHUB_${command}`];\n    if (!filePath) {\n        throw new Error(`Unable to find environment variable for file command ${command}`);\n    }\n    if (!fs.existsSync(filePath)) {\n        throw new Error(`Missing file at path: ${filePath}`);\n    }\n    fs.appendFileSync(filePath, `${utils_1.toCommandValue(message)}${os.EOL}`, {\n        encoding: 'utf8'\n    });\n}\nexports.issueCommand = issueCommand;\n//# sourceMappingURL=file-command.js.map","\"use strict\";\n// We use any as a valid input type\n/* eslint-disable @typescript-eslint/no-explicit-any */\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * Sanitizes an input into a string so it can be passed into issueCommand safely\n * @param input input to sanitize into a string\n */\nfunction toCommandValue(input) {\n    if (input === null || input === undefined) {\n        return '';\n    }\n    else if (typeof input === 'string' || input instanceof String) {\n        return input;\n    }\n    return JSON.stringify(input);\n}\nexports.toCommandValue = toCommandValue;\n//# sourceMappingURL=utils.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst fs = require(\"fs\");\r\nexports.FILE_SYSTEM_ADAPTER = {\r\n    lstat: fs.lstat,\r\n    stat: fs.stat,\r\n    lstatSync: fs.lstatSync,\r\n    statSync: fs.statSync,\r\n    readdir: fs.readdir,\r\n    readdirSync: fs.readdirSync\r\n};\r\nfunction createFileSystemAdapter(fsMethods) {\r\n    if (fsMethods === undefined) {\r\n        return exports.FILE_SYSTEM_ADAPTER;\r\n    }\r\n    return Object.assign(Object.assign({}, exports.FILE_SYSTEM_ADAPTER), fsMethods);\r\n}\r\nexports.createFileSystemAdapter = createFileSystemAdapter;\r\n","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst NODE_PROCESS_VERSION_PARTS = process.versions.node.split('.');\r\nconst MAJOR_VERSION = parseInt(NODE_PROCESS_VERSION_PARTS[0], 10);\r\nconst MINOR_VERSION = parseInt(NODE_PROCESS_VERSION_PARTS[1], 10);\r\nconst SUPPORTED_MAJOR_VERSION = 10;\r\nconst SUPPORTED_MINOR_VERSION = 10;\r\nconst IS_MATCHED_BY_MAJOR = MAJOR_VERSION > SUPPORTED_MAJOR_VERSION;\r\nconst IS_MATCHED_BY_MAJOR_AND_MINOR = MAJOR_VERSION === SUPPORTED_MAJOR_VERSION && MINOR_VERSION >= SUPPORTED_MINOR_VERSION;\r\n/**\r\n * IS `true` for Node.js 10.10 and greater.\r\n */\r\nexports.IS_SUPPORT_READDIR_WITH_FILE_TYPES = IS_MATCHED_BY_MAJOR || IS_MATCHED_BY_MAJOR_AND_MINOR;\r\n","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst async = require(\"./providers/async\");\r\nconst sync = require(\"./providers/sync\");\r\nconst settings_1 = require(\"./settings\");\r\nexports.Settings = settings_1.default;\r\nfunction scandir(path, optionsOrSettingsOrCallback, callback) {\r\n    if (typeof optionsOrSettingsOrCallback === 'function') {\r\n        return async.read(path, getSettings(), optionsOrSettingsOrCallback);\r\n    }\r\n    async.read(path, getSettings(optionsOrSettingsOrCallback), callback);\r\n}\r\nexports.scandir = scandir;\r\nfunction scandirSync(path, optionsOrSettings) {\r\n    const settings = getSettings(optionsOrSettings);\r\n    return sync.read(path, settings);\r\n}\r\nexports.scandirSync = scandirSync;\r\nfunction getSettings(settingsOrOptions = {}) {\r\n    if (settingsOrOptions instanceof settings_1.default) {\r\n        return settingsOrOptions;\r\n    }\r\n    return new settings_1.default(settingsOrOptions);\r\n}\r\n","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst fsStat = require(\"@nodelib/fs.stat\");\r\nconst rpl = require(\"run-parallel\");\r\nconst constants_1 = require(\"../constants\");\r\nconst utils = require(\"../utils\");\r\nfunction read(directory, settings, callback) {\r\n    if (!settings.stats && constants_1.IS_SUPPORT_READDIR_WITH_FILE_TYPES) {\r\n        return readdirWithFileTypes(directory, settings, callback);\r\n    }\r\n    return readdir(directory, settings, callback);\r\n}\r\nexports.read = read;\r\nfunction readdirWithFileTypes(directory, settings, callback) {\r\n    settings.fs.readdir(directory, { withFileTypes: true }, (readdirError, dirents) => {\r\n        if (readdirError !== null) {\r\n            return callFailureCallback(callback, readdirError);\r\n        }\r\n        const entries = dirents.map((dirent) => ({\r\n            dirent,\r\n            name: dirent.name,\r\n            path: `${directory}${settings.pathSegmentSeparator}${dirent.name}`\r\n        }));\r\n        if (!settings.followSymbolicLinks) {\r\n            return callSuccessCallback(callback, entries);\r\n        }\r\n        const tasks = entries.map((entry) => makeRplTaskEntry(entry, settings));\r\n        rpl(tasks, (rplError, rplEntries) => {\r\n            if (rplError !== null) {\r\n                return callFailureCallback(callback, rplError);\r\n            }\r\n            callSuccessCallback(callback, rplEntries);\r\n        });\r\n    });\r\n}\r\nexports.readdirWithFileTypes = readdirWithFileTypes;\r\nfunction makeRplTaskEntry(entry, settings) {\r\n    return (done) => {\r\n        if (!entry.dirent.isSymbolicLink()) {\r\n            return done(null, entry);\r\n        }\r\n        settings.fs.stat(entry.path, (statError, stats) => {\r\n            if (statError !== null) {\r\n                if (settings.throwErrorOnBrokenSymbolicLink) {\r\n                    return done(statError);\r\n                }\r\n                return done(null, entry);\r\n            }\r\n            entry.dirent = utils.fs.createDirentFromStats(entry.name, stats);\r\n            return done(null, entry);\r\n        });\r\n    };\r\n}\r\nfunction readdir(directory, settings, callback) {\r\n    settings.fs.readdir(directory, (readdirError, names) => {\r\n        if (readdirError !== null) {\r\n            return callFailureCallback(callback, readdirError);\r\n        }\r\n        const filepaths = names.map((name) => `${directory}${settings.pathSegmentSeparator}${name}`);\r\n        const tasks = filepaths.map((filepath) => {\r\n            return (done) => fsStat.stat(filepath, settings.fsStatSettings, done);\r\n        });\r\n        rpl(tasks, (rplError, results) => {\r\n            if (rplError !== null) {\r\n                return callFailureCallback(callback, rplError);\r\n            }\r\n            const entries = [];\r\n            names.forEach((name, index) => {\r\n                const stats = results[index];\r\n                const entry = {\r\n                    name,\r\n                    path: filepaths[index],\r\n                    dirent: utils.fs.createDirentFromStats(name, stats)\r\n                };\r\n                if (settings.stats) {\r\n                    entry.stats = stats;\r\n                }\r\n                entries.push(entry);\r\n            });\r\n            callSuccessCallback(callback, entries);\r\n        });\r\n    });\r\n}\r\nexports.readdir = readdir;\r\nfunction callFailureCallback(callback, error) {\r\n    callback(error);\r\n}\r\nfunction callSuccessCallback(callback, result) {\r\n    callback(null, result);\r\n}\r\n","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst fsStat = require(\"@nodelib/fs.stat\");\r\nconst constants_1 = require(\"../constants\");\r\nconst utils = require(\"../utils\");\r\nfunction read(directory, settings) {\r\n    if (!settings.stats && constants_1.IS_SUPPORT_READDIR_WITH_FILE_TYPES) {\r\n        return readdirWithFileTypes(directory, settings);\r\n    }\r\n    return readdir(directory, settings);\r\n}\r\nexports.read = read;\r\nfunction readdirWithFileTypes(directory, settings) {\r\n    const dirents = settings.fs.readdirSync(directory, { withFileTypes: true });\r\n    return dirents.map((dirent) => {\r\n        const entry = {\r\n            dirent,\r\n            name: dirent.name,\r\n            path: `${directory}${settings.pathSegmentSeparator}${dirent.name}`\r\n        };\r\n        if (entry.dirent.isSymbolicLink() && settings.followSymbolicLinks) {\r\n            try {\r\n                const stats = settings.fs.statSync(entry.path);\r\n                entry.dirent = utils.fs.createDirentFromStats(entry.name, stats);\r\n            }\r\n            catch (error) {\r\n                if (settings.throwErrorOnBrokenSymbolicLink) {\r\n                    throw error;\r\n                }\r\n            }\r\n        }\r\n        return entry;\r\n    });\r\n}\r\nexports.readdirWithFileTypes = readdirWithFileTypes;\r\nfunction readdir(directory, settings) {\r\n    const names = settings.fs.readdirSync(directory);\r\n    return names.map((name) => {\r\n        const entryPath = `${directory}${settings.pathSegmentSeparator}${name}`;\r\n        const stats = fsStat.statSync(entryPath, settings.fsStatSettings);\r\n        const entry = {\r\n            name,\r\n            path: entryPath,\r\n            dirent: utils.fs.createDirentFromStats(name, stats)\r\n        };\r\n        if (settings.stats) {\r\n            entry.stats = stats;\r\n        }\r\n        return entry;\r\n    });\r\n}\r\nexports.readdir = readdir;\r\n","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst path = require(\"path\");\r\nconst fsStat = require(\"@nodelib/fs.stat\");\r\nconst fs = require(\"./adapters/fs\");\r\nclass Settings {\r\n    constructor(_options = {}) {\r\n        this._options = _options;\r\n        this.followSymbolicLinks = this._getValue(this._options.followSymbolicLinks, false);\r\n        this.fs = fs.createFileSystemAdapter(this._options.fs);\r\n        this.pathSegmentSeparator = this._getValue(this._options.pathSegmentSeparator, path.sep);\r\n        this.stats = this._getValue(this._options.stats, false);\r\n        this.throwErrorOnBrokenSymbolicLink = this._getValue(this._options.throwErrorOnBrokenSymbolicLink, true);\r\n        this.fsStatSettings = new fsStat.Settings({\r\n            followSymbolicLink: this.followSymbolicLinks,\r\n            fs: this.fs,\r\n            throwErrorOnBrokenSymbolicLink: this.throwErrorOnBrokenSymbolicLink\r\n        });\r\n    }\r\n    _getValue(option, value) {\r\n        return option === undefined ? value : option;\r\n    }\r\n}\r\nexports.default = Settings;\r\n","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nclass DirentFromStats {\r\n    constructor(name, stats) {\r\n        this.name = name;\r\n        this.isBlockDevice = stats.isBlockDevice.bind(stats);\r\n        this.isCharacterDevice = stats.isCharacterDevice.bind(stats);\r\n        this.isDirectory = stats.isDirectory.bind(stats);\r\n        this.isFIFO = stats.isFIFO.bind(stats);\r\n        this.isFile = stats.isFile.bind(stats);\r\n        this.isSocket = stats.isSocket.bind(stats);\r\n        this.isSymbolicLink = stats.isSymbolicLink.bind(stats);\r\n    }\r\n}\r\nfunction createDirentFromStats(name, stats) {\r\n    return new DirentFromStats(name, stats);\r\n}\r\nexports.createDirentFromStats = createDirentFromStats;\r\n","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst fs = require(\"./fs\");\r\nexports.fs = fs;\r\n","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst fs = require(\"fs\");\r\nexports.FILE_SYSTEM_ADAPTER = {\r\n    lstat: fs.lstat,\r\n    stat: fs.stat,\r\n    lstatSync: fs.lstatSync,\r\n    statSync: fs.statSync\r\n};\r\nfunction createFileSystemAdapter(fsMethods) {\r\n    if (fsMethods === undefined) {\r\n        return exports.FILE_SYSTEM_ADAPTER;\r\n    }\r\n    return Object.assign(Object.assign({}, exports.FILE_SYSTEM_ADAPTER), fsMethods);\r\n}\r\nexports.createFileSystemAdapter = createFileSystemAdapter;\r\n","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst async = require(\"./providers/async\");\r\nconst sync = require(\"./providers/sync\");\r\nconst settings_1 = require(\"./settings\");\r\nexports.Settings = settings_1.default;\r\nfunction stat(path, optionsOrSettingsOrCallback, callback) {\r\n    if (typeof optionsOrSettingsOrCallback === 'function') {\r\n        return async.read(path, getSettings(), optionsOrSettingsOrCallback);\r\n    }\r\n    async.read(path, getSettings(optionsOrSettingsOrCallback), callback);\r\n}\r\nexports.stat = stat;\r\nfunction statSync(path, optionsOrSettings) {\r\n    const settings = getSettings(optionsOrSettings);\r\n    return sync.read(path, settings);\r\n}\r\nexports.statSync = statSync;\r\nfunction getSettings(settingsOrOptions = {}) {\r\n    if (settingsOrOptions instanceof settings_1.default) {\r\n        return settingsOrOptions;\r\n    }\r\n    return new settings_1.default(settingsOrOptions);\r\n}\r\n","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nfunction read(path, settings, callback) {\r\n    settings.fs.lstat(path, (lstatError, lstat) => {\r\n        if (lstatError !== null) {\r\n            return callFailureCallback(callback, lstatError);\r\n        }\r\n        if (!lstat.isSymbolicLink() || !settings.followSymbolicLink) {\r\n            return callSuccessCallback(callback, lstat);\r\n        }\r\n        settings.fs.stat(path, (statError, stat) => {\r\n            if (statError !== null) {\r\n                if (settings.throwErrorOnBrokenSymbolicLink) {\r\n                    return callFailureCallback(callback, statError);\r\n                }\r\n                return callSuccessCallback(callback, lstat);\r\n            }\r\n            if (settings.markSymbolicLink) {\r\n                stat.isSymbolicLink = () => true;\r\n            }\r\n            callSuccessCallback(callback, stat);\r\n        });\r\n    });\r\n}\r\nexports.read = read;\r\nfunction callFailureCallback(callback, error) {\r\n    callback(error);\r\n}\r\nfunction callSuccessCallback(callback, result) {\r\n    callback(null, result);\r\n}\r\n","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nfunction read(path, settings) {\r\n    const lstat = settings.fs.lstatSync(path);\r\n    if (!lstat.isSymbolicLink() || !settings.followSymbolicLink) {\r\n        return lstat;\r\n    }\r\n    try {\r\n        const stat = settings.fs.statSync(path);\r\n        if (settings.markSymbolicLink) {\r\n            stat.isSymbolicLink = () => true;\r\n        }\r\n        return stat;\r\n    }\r\n    catch (error) {\r\n        if (!settings.throwErrorOnBrokenSymbolicLink) {\r\n            return lstat;\r\n        }\r\n        throw error;\r\n    }\r\n}\r\nexports.read = read;\r\n","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst fs = require(\"./adapters/fs\");\r\nclass Settings {\r\n    constructor(_options = {}) {\r\n        this._options = _options;\r\n        this.followSymbolicLink = this._getValue(this._options.followSymbolicLink, true);\r\n        this.fs = fs.createFileSystemAdapter(this._options.fs);\r\n        this.markSymbolicLink = this._getValue(this._options.markSymbolicLink, false);\r\n        this.throwErrorOnBrokenSymbolicLink = this._getValue(this._options.throwErrorOnBrokenSymbolicLink, true);\r\n    }\r\n    _getValue(option, value) {\r\n        return option === undefined ? value : option;\r\n    }\r\n}\r\nexports.default = Settings;\r\n","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst async_1 = require(\"./providers/async\");\r\nconst stream_1 = require(\"./providers/stream\");\r\nconst sync_1 = require(\"./providers/sync\");\r\nconst settings_1 = require(\"./settings\");\r\nexports.Settings = settings_1.default;\r\nfunction walk(directory, optionsOrSettingsOrCallback, callback) {\r\n    if (typeof optionsOrSettingsOrCallback === 'function') {\r\n        return new async_1.default(directory, getSettings()).read(optionsOrSettingsOrCallback);\r\n    }\r\n    new async_1.default(directory, getSettings(optionsOrSettingsOrCallback)).read(callback);\r\n}\r\nexports.walk = walk;\r\nfunction walkSync(directory, optionsOrSettings) {\r\n    const settings = getSettings(optionsOrSettings);\r\n    const provider = new sync_1.default(directory, settings);\r\n    return provider.read();\r\n}\r\nexports.walkSync = walkSync;\r\nfunction walkStream(directory, optionsOrSettings) {\r\n    const settings = getSettings(optionsOrSettings);\r\n    const provider = new stream_1.default(directory, settings);\r\n    return provider.read();\r\n}\r\nexports.walkStream = walkStream;\r\nfunction getSettings(settingsOrOptions = {}) {\r\n    if (settingsOrOptions instanceof settings_1.default) {\r\n        return settingsOrOptions;\r\n    }\r\n    return new settings_1.default(settingsOrOptions);\r\n}\r\n","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst async_1 = require(\"../readers/async\");\r\nclass AsyncProvider {\r\n    constructor(_root, _settings) {\r\n        this._root = _root;\r\n        this._settings = _settings;\r\n        this._reader = new async_1.default(this._root, this._settings);\r\n        this._storage = new Set();\r\n    }\r\n    read(callback) {\r\n        this._reader.onError((error) => {\r\n            callFailureCallback(callback, error);\r\n        });\r\n        this._reader.onEntry((entry) => {\r\n            this._storage.add(entry);\r\n        });\r\n        this._reader.onEnd(() => {\r\n            callSuccessCallback(callback, [...this._storage]);\r\n        });\r\n        this._reader.read();\r\n    }\r\n}\r\nexports.default = AsyncProvider;\r\nfunction callFailureCallback(callback, error) {\r\n    callback(error);\r\n}\r\nfunction callSuccessCallback(callback, entries) {\r\n    callback(null, entries);\r\n}\r\n","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst stream_1 = require(\"stream\");\r\nconst async_1 = require(\"../readers/async\");\r\nclass StreamProvider {\r\n    constructor(_root, _settings) {\r\n        this._root = _root;\r\n        this._settings = _settings;\r\n        this._reader = new async_1.default(this._root, this._settings);\r\n        this._stream = new stream_1.Readable({\r\n            objectMode: true,\r\n            read: () => { },\r\n            destroy: this._reader.destroy.bind(this._reader)\r\n        });\r\n    }\r\n    read() {\r\n        this._reader.onError((error) => {\r\n            this._stream.emit('error', error);\r\n        });\r\n        this._reader.onEntry((entry) => {\r\n            this._stream.push(entry);\r\n        });\r\n        this._reader.onEnd(() => {\r\n            this._stream.push(null);\r\n        });\r\n        this._reader.read();\r\n        return this._stream;\r\n    }\r\n}\r\nexports.default = StreamProvider;\r\n","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst sync_1 = require(\"../readers/sync\");\r\nclass SyncProvider {\r\n    constructor(_root, _settings) {\r\n        this._root = _root;\r\n        this._settings = _settings;\r\n        this._reader = new sync_1.default(this._root, this._settings);\r\n    }\r\n    read() {\r\n        return this._reader.read();\r\n    }\r\n}\r\nexports.default = SyncProvider;\r\n","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst events_1 = require(\"events\");\r\nconst fsScandir = require(\"@nodelib/fs.scandir\");\r\nconst fastq = require(\"fastq\");\r\nconst common = require(\"./common\");\r\nconst reader_1 = require(\"./reader\");\r\nclass AsyncReader extends reader_1.default {\r\n    constructor(_root, _settings) {\r\n        super(_root, _settings);\r\n        this._settings = _settings;\r\n        this._scandir = fsScandir.scandir;\r\n        this._emitter = new events_1.EventEmitter();\r\n        this._queue = fastq(this._worker.bind(this), this._settings.concurrency);\r\n        this._isFatalError = false;\r\n        this._isDestroyed = false;\r\n        this._queue.drain = () => {\r\n            if (!this._isFatalError) {\r\n                this._emitter.emit('end');\r\n            }\r\n        };\r\n    }\r\n    read() {\r\n        this._isFatalError = false;\r\n        this._isDestroyed = false;\r\n        setImmediate(() => {\r\n            this._pushToQueue(this._root, this._settings.basePath);\r\n        });\r\n        return this._emitter;\r\n    }\r\n    destroy() {\r\n        if (this._isDestroyed) {\r\n            throw new Error('The reader is already destroyed');\r\n        }\r\n        this._isDestroyed = true;\r\n        this._queue.killAndDrain();\r\n    }\r\n    onEntry(callback) {\r\n        this._emitter.on('entry', callback);\r\n    }\r\n    onError(callback) {\r\n        this._emitter.once('error', callback);\r\n    }\r\n    onEnd(callback) {\r\n        this._emitter.once('end', callback);\r\n    }\r\n    _pushToQueue(directory, base) {\r\n        const queueItem = { directory, base };\r\n        this._queue.push(queueItem, (error) => {\r\n            if (error !== null) {\r\n                this._handleError(error);\r\n            }\r\n        });\r\n    }\r\n    _worker(item, done) {\r\n        this._scandir(item.directory, this._settings.fsScandirSettings, (error, entries) => {\r\n            if (error !== null) {\r\n                return done(error, undefined);\r\n            }\r\n            for (const entry of entries) {\r\n                this._handleEntry(entry, item.base);\r\n            }\r\n            done(null, undefined);\r\n        });\r\n    }\r\n    _handleError(error) {\r\n        if (!common.isFatalError(this._settings, error)) {\r\n            return;\r\n        }\r\n        this._isFatalError = true;\r\n        this._isDestroyed = true;\r\n        this._emitter.emit('error', error);\r\n    }\r\n    _handleEntry(entry, base) {\r\n        if (this._isDestroyed || this._isFatalError) {\r\n            return;\r\n        }\r\n        const fullpath = entry.path;\r\n        if (base !== undefined) {\r\n            entry.path = common.joinPathSegments(base, entry.name, this._settings.pathSegmentSeparator);\r\n        }\r\n        if (common.isAppliedFilter(this._settings.entryFilter, entry)) {\r\n            this._emitEntry(entry);\r\n        }\r\n        if (entry.dirent.isDirectory() && common.isAppliedFilter(this._settings.deepFilter, entry)) {\r\n            this._pushToQueue(fullpath, entry.path);\r\n        }\r\n    }\r\n    _emitEntry(entry) {\r\n        this._emitter.emit('entry', entry);\r\n    }\r\n}\r\nexports.default = AsyncReader;\r\n","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nfunction isFatalError(settings, error) {\r\n    if (settings.errorFilter === null) {\r\n        return true;\r\n    }\r\n    return !settings.errorFilter(error);\r\n}\r\nexports.isFatalError = isFatalError;\r\nfunction isAppliedFilter(filter, value) {\r\n    return filter === null || filter(value);\r\n}\r\nexports.isAppliedFilter = isAppliedFilter;\r\nfunction replacePathSegmentSeparator(filepath, separator) {\r\n    return filepath.split(/[\\\\/]/).join(separator);\r\n}\r\nexports.replacePathSegmentSeparator = replacePathSegmentSeparator;\r\nfunction joinPathSegments(a, b, separator) {\r\n    if (a === '') {\r\n        return b;\r\n    }\r\n    return a + separator + b;\r\n}\r\nexports.joinPathSegments = joinPathSegments;\r\n","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst common = require(\"./common\");\r\nclass Reader {\r\n    constructor(_root, _settings) {\r\n        this._root = _root;\r\n        this._settings = _settings;\r\n        this._root = common.replacePathSegmentSeparator(_root, _settings.pathSegmentSeparator);\r\n    }\r\n}\r\nexports.default = Reader;\r\n","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst fsScandir = require(\"@nodelib/fs.scandir\");\r\nconst common = require(\"./common\");\r\nconst reader_1 = require(\"./reader\");\r\nclass SyncReader extends reader_1.default {\r\n    constructor() {\r\n        super(...arguments);\r\n        this._scandir = fsScandir.scandirSync;\r\n        this._storage = new Set();\r\n        this._queue = new Set();\r\n    }\r\n    read() {\r\n        this._pushToQueue(this._root, this._settings.basePath);\r\n        this._handleQueue();\r\n        return [...this._storage];\r\n    }\r\n    _pushToQueue(directory, base) {\r\n        this._queue.add({ directory, base });\r\n    }\r\n    _handleQueue() {\r\n        for (const item of this._queue.values()) {\r\n            this._handleDirectory(item.directory, item.base);\r\n        }\r\n    }\r\n    _handleDirectory(directory, base) {\r\n        try {\r\n            const entries = this._scandir(directory, this._settings.fsScandirSettings);\r\n            for (const entry of entries) {\r\n                this._handleEntry(entry, base);\r\n            }\r\n        }\r\n        catch (error) {\r\n            this._handleError(error);\r\n        }\r\n    }\r\n    _handleError(error) {\r\n        if (!common.isFatalError(this._settings, error)) {\r\n            return;\r\n        }\r\n        throw error;\r\n    }\r\n    _handleEntry(entry, base) {\r\n        const fullpath = entry.path;\r\n        if (base !== undefined) {\r\n            entry.path = common.joinPathSegments(base, entry.name, this._settings.pathSegmentSeparator);\r\n        }\r\n        if (common.isAppliedFilter(this._settings.entryFilter, entry)) {\r\n            this._pushToStorage(entry);\r\n        }\r\n        if (entry.dirent.isDirectory() && common.isAppliedFilter(this._settings.deepFilter, entry)) {\r\n            this._pushToQueue(fullpath, entry.path);\r\n        }\r\n    }\r\n    _pushToStorage(entry) {\r\n        this._storage.add(entry);\r\n    }\r\n}\r\nexports.default = SyncReader;\r\n","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst path = require(\"path\");\r\nconst fsScandir = require(\"@nodelib/fs.scandir\");\r\nclass Settings {\r\n    constructor(_options = {}) {\r\n        this._options = _options;\r\n        this.basePath = this._getValue(this._options.basePath, undefined);\r\n        this.concurrency = this._getValue(this._options.concurrency, Infinity);\r\n        this.deepFilter = this._getValue(this._options.deepFilter, null);\r\n        this.entryFilter = this._getValue(this._options.entryFilter, null);\r\n        this.errorFilter = this._getValue(this._options.errorFilter, null);\r\n        this.pathSegmentSeparator = this._getValue(this._options.pathSegmentSeparator, path.sep);\r\n        this.fsScandirSettings = new fsScandir.Settings({\r\n            followSymbolicLinks: this._options.followSymbolicLinks,\r\n            fs: this._options.fs,\r\n            pathSegmentSeparator: this._options.pathSegmentSeparator,\r\n            stats: this._options.stats,\r\n            throwErrorOnBrokenSymbolicLink: this._options.throwErrorOnBrokenSymbolicLink\r\n        });\r\n    }\r\n    _getValue(option, value) {\r\n        return option === undefined ? value : option;\r\n    }\r\n}\r\nexports.default = Settings;\r\n","'use strict';\n\nmodule.exports = (...arguments_) => {\n\treturn [...new Set([].concat(...arguments_))];\n};\n","'use strict';\n\nconst stringify = require('./lib/stringify');\nconst compile = require('./lib/compile');\nconst expand = require('./lib/expand');\nconst parse = require('./lib/parse');\n\n/**\n * Expand the given pattern or create a regex-compatible string.\n *\n * ```js\n * const braces = require('braces');\n * console.log(braces('{a,b,c}', { compile: true })); //=> ['(a|b|c)']\n * console.log(braces('{a,b,c}')); //=> ['a', 'b', 'c']\n * ```\n * @param {String} `str`\n * @param {Object} `options`\n * @return {String}\n * @api public\n */\n\nconst braces = (input, options = {}) => {\n  let output = [];\n\n  if (Array.isArray(input)) {\n    for (let pattern of input) {\n      let result = braces.create(pattern, options);\n      if (Array.isArray(result)) {\n        output.push(...result);\n      } else {\n        output.push(result);\n      }\n    }\n  } else {\n    output = [].concat(braces.create(input, options));\n  }\n\n  if (options && options.expand === true && options.nodupes === true) {\n    output = [...new Set(output)];\n  }\n  return output;\n};\n\n/**\n * Parse the given `str` with the given `options`.\n *\n * ```js\n * // braces.parse(pattern, [, options]);\n * const ast = braces.parse('a/{b,c}/d');\n * console.log(ast);\n * ```\n * @param {String} pattern Brace pattern to parse\n * @param {Object} options\n * @return {Object} Returns an AST\n * @api public\n */\n\nbraces.parse = (input, options = {}) => parse(input, options);\n\n/**\n * Creates a braces string from an AST, or an AST node.\n *\n * ```js\n * const braces = require('braces');\n * let ast = braces.parse('foo/{a,b}/bar');\n * console.log(stringify(ast.nodes[2])); //=> '{a,b}'\n * ```\n * @param {String} `input` Brace pattern or AST.\n * @param {Object} `options`\n * @return {Array} Returns an array of expanded values.\n * @api public\n */\n\nbraces.stringify = (input, options = {}) => {\n  if (typeof input === 'string') {\n    return stringify(braces.parse(input, options), options);\n  }\n  return stringify(input, options);\n};\n\n/**\n * Compiles a brace pattern into a regex-compatible, optimized string.\n * This method is called by the main [braces](#braces) function by default.\n *\n * ```js\n * const braces = require('braces');\n * console.log(braces.compile('a/{b,c}/d'));\n * //=> ['a/(b|c)/d']\n * ```\n * @param {String} `input` Brace pattern or AST.\n * @param {Object} `options`\n * @return {Array} Returns an array of expanded values.\n * @api public\n */\n\nbraces.compile = (input, options = {}) => {\n  if (typeof input === 'string') {\n    input = braces.parse(input, options);\n  }\n  return compile(input, options);\n};\n\n/**\n * Expands a brace pattern into an array. This method is called by the\n * main [braces](#braces) function when `options.expand` is true. Before\n * using this method it's recommended that you read the [performance notes](#performance))\n * and advantages of using [.compile](#compile) instead.\n *\n * ```js\n * const braces = require('braces');\n * console.log(braces.expand('a/{b,c}/d'));\n * //=> ['a/b/d', 'a/c/d'];\n * ```\n * @param {String} `pattern` Brace pattern\n * @param {Object} `options`\n * @return {Array} Returns an array of expanded values.\n * @api public\n */\n\nbraces.expand = (input, options = {}) => {\n  if (typeof input === 'string') {\n    input = braces.parse(input, options);\n  }\n\n  let result = expand(input, options);\n\n  // filter out empty strings if specified\n  if (options.noempty === true) {\n    result = result.filter(Boolean);\n  }\n\n  // filter out duplicates if specified\n  if (options.nodupes === true) {\n    result = [...new Set(result)];\n  }\n\n  return result;\n};\n\n/**\n * Processes a brace pattern and returns either an expanded array\n * (if `options.expand` is true), a highly optimized regex-compatible string.\n * This method is called by the main [braces](#braces) function.\n *\n * ```js\n * const braces = require('braces');\n * console.log(braces.create('user-{200..300}/project-{a,b,c}-{1..10}'))\n * //=> 'user-(20[0-9]|2[1-9][0-9]|300)/project-(a|b|c)-([1-9]|10)'\n * ```\n * @param {String} `pattern` Brace pattern\n * @param {Object} `options`\n * @return {Array} Returns an array of expanded values.\n * @api public\n */\n\nbraces.create = (input, options = {}) => {\n  if (input === '' || input.length < 3) {\n    return [input];\n  }\n\n return options.expand !== true\n    ? braces.compile(input, options)\n    : braces.expand(input, options);\n};\n\n/**\n * Expose \"braces\"\n */\n\nmodule.exports = braces;\n","'use strict';\n\nconst fill = require('fill-range');\nconst utils = require('./utils');\n\nconst compile = (ast, options = {}) => {\n  let walk = (node, parent = {}) => {\n    let invalidBlock = utils.isInvalidBrace(parent);\n    let invalidNode = node.invalid === true && options.escapeInvalid === true;\n    let invalid = invalidBlock === true || invalidNode === true;\n    let prefix = options.escapeInvalid === true ? '\\\\' : '';\n    let output = '';\n\n    if (node.isOpen === true) {\n      return prefix + node.value;\n    }\n    if (node.isClose === true) {\n      return prefix + node.value;\n    }\n\n    if (node.type === 'open') {\n      return invalid ? (prefix + node.value) : '(';\n    }\n\n    if (node.type === 'close') {\n      return invalid ? (prefix + node.value) : ')';\n    }\n\n    if (node.type === 'comma') {\n      return node.prev.type === 'comma' ? '' : (invalid ? node.value : '|');\n    }\n\n    if (node.value) {\n      return node.value;\n    }\n\n    if (node.nodes && node.ranges > 0) {\n      let args = utils.reduce(node.nodes);\n      let range = fill(...args, { ...options, wrap: false, toRegex: true });\n\n      if (range.length !== 0) {\n        return args.length > 1 && range.length > 1 ? `(${range})` : range;\n      }\n    }\n\n    if (node.nodes) {\n      for (let child of node.nodes) {\n        output += walk(child, node);\n      }\n    }\n    return output;\n  };\n\n  return walk(ast);\n};\n\nmodule.exports = compile;\n","'use strict';\n\nmodule.exports = {\n  MAX_LENGTH: 1024 * 64,\n\n  // Digits\n  CHAR_0: '0', /* 0 */\n  CHAR_9: '9', /* 9 */\n\n  // Alphabet chars.\n  CHAR_UPPERCASE_A: 'A', /* A */\n  CHAR_LOWERCASE_A: 'a', /* a */\n  CHAR_UPPERCASE_Z: 'Z', /* Z */\n  CHAR_LOWERCASE_Z: 'z', /* z */\n\n  CHAR_LEFT_PARENTHESES: '(', /* ( */\n  CHAR_RIGHT_PARENTHESES: ')', /* ) */\n\n  CHAR_ASTERISK: '*', /* * */\n\n  // Non-alphabetic chars.\n  CHAR_AMPERSAND: '&', /* & */\n  CHAR_AT: '@', /* @ */\n  CHAR_BACKSLASH: '\\\\', /* \\ */\n  CHAR_BACKTICK: '`', /* ` */\n  CHAR_CARRIAGE_RETURN: '\\r', /* \\r */\n  CHAR_CIRCUMFLEX_ACCENT: '^', /* ^ */\n  CHAR_COLON: ':', /* : */\n  CHAR_COMMA: ',', /* , */\n  CHAR_DOLLAR: '$', /* . */\n  CHAR_DOT: '.', /* . */\n  CHAR_DOUBLE_QUOTE: '\"', /* \" */\n  CHAR_EQUAL: '=', /* = */\n  CHAR_EXCLAMATION_MARK: '!', /* ! */\n  CHAR_FORM_FEED: '\\f', /* \\f */\n  CHAR_FORWARD_SLASH: '/', /* / */\n  CHAR_HASH: '#', /* # */\n  CHAR_HYPHEN_MINUS: '-', /* - */\n  CHAR_LEFT_ANGLE_BRACKET: '<', /* < */\n  CHAR_LEFT_CURLY_BRACE: '{', /* { */\n  CHAR_LEFT_SQUARE_BRACKET: '[', /* [ */\n  CHAR_LINE_FEED: '\\n', /* \\n */\n  CHAR_NO_BREAK_SPACE: '\\u00A0', /* \\u00A0 */\n  CHAR_PERCENT: '%', /* % */\n  CHAR_PLUS: '+', /* + */\n  CHAR_QUESTION_MARK: '?', /* ? */\n  CHAR_RIGHT_ANGLE_BRACKET: '>', /* > */\n  CHAR_RIGHT_CURLY_BRACE: '}', /* } */\n  CHAR_RIGHT_SQUARE_BRACKET: ']', /* ] */\n  CHAR_SEMICOLON: ';', /* ; */\n  CHAR_SINGLE_QUOTE: '\\'', /* ' */\n  CHAR_SPACE: ' ', /*   */\n  CHAR_TAB: '\\t', /* \\t */\n  CHAR_UNDERSCORE: '_', /* _ */\n  CHAR_VERTICAL_LINE: '|', /* | */\n  CHAR_ZERO_WIDTH_NOBREAK_SPACE: '\\uFEFF' /* \\uFEFF */\n};\n","'use strict';\n\nconst fill = require('fill-range');\nconst stringify = require('./stringify');\nconst utils = require('./utils');\n\nconst append = (queue = '', stash = '', enclose = false) => {\n  let result = [];\n\n  queue = [].concat(queue);\n  stash = [].concat(stash);\n\n  if (!stash.length) return queue;\n  if (!queue.length) {\n    return enclose ? utils.flatten(stash).map(ele => `{${ele}}`) : stash;\n  }\n\n  for (let item of queue) {\n    if (Array.isArray(item)) {\n      for (let value of item) {\n        result.push(append(value, stash, enclose));\n      }\n    } else {\n      for (let ele of stash) {\n        if (enclose === true && typeof ele === 'string') ele = `{${ele}}`;\n        result.push(Array.isArray(ele) ? append(item, ele, enclose) : (item + ele));\n      }\n    }\n  }\n  return utils.flatten(result);\n};\n\nconst expand = (ast, options = {}) => {\n  let rangeLimit = options.rangeLimit === void 0 ? 1000 : options.rangeLimit;\n\n  let walk = (node, parent = {}) => {\n    node.queue = [];\n\n    let p = parent;\n    let q = parent.queue;\n\n    while (p.type !== 'brace' && p.type !== 'root' && p.parent) {\n      p = p.parent;\n      q = p.queue;\n    }\n\n    if (node.invalid || node.dollar) {\n      q.push(append(q.pop(), stringify(node, options)));\n      return;\n    }\n\n    if (node.type === 'brace' && node.invalid !== true && node.nodes.length === 2) {\n      q.push(append(q.pop(), ['{}']));\n      return;\n    }\n\n    if (node.nodes && node.ranges > 0) {\n      let args = utils.reduce(node.nodes);\n\n      if (utils.exceedsLimit(...args, options.step, rangeLimit)) {\n        throw new RangeError('expanded array length exceeds range limit. Use options.rangeLimit to increase or disable the limit.');\n      }\n\n      let range = fill(...args, options);\n      if (range.length === 0) {\n        range = stringify(node, options);\n      }\n\n      q.push(append(q.pop(), range));\n      node.nodes = [];\n      return;\n    }\n\n    let enclose = utils.encloseBrace(node);\n    let queue = node.queue;\n    let block = node;\n\n    while (block.type !== 'brace' && block.type !== 'root' && block.parent) {\n      block = block.parent;\n      queue = block.queue;\n    }\n\n    for (let i = 0; i < node.nodes.length; i++) {\n      let child = node.nodes[i];\n\n      if (child.type === 'comma' && node.type === 'brace') {\n        if (i === 1) queue.push('');\n        queue.push('');\n        continue;\n      }\n\n      if (child.type === 'close') {\n        q.push(append(q.pop(), queue, enclose));\n        continue;\n      }\n\n      if (child.value && child.type !== 'open') {\n        queue.push(append(queue.pop(), child.value));\n        continue;\n      }\n\n      if (child.nodes) {\n        walk(child, node);\n      }\n    }\n\n    return queue;\n  };\n\n  return utils.flatten(walk(ast));\n};\n\nmodule.exports = expand;\n","'use strict';\n\nconst stringify = require('./stringify');\n\n/**\n * Constants\n */\n\nconst {\n  MAX_LENGTH,\n  CHAR_BACKSLASH, /* \\ */\n  CHAR_BACKTICK, /* ` */\n  CHAR_COMMA, /* , */\n  CHAR_DOT, /* . */\n  CHAR_LEFT_PARENTHESES, /* ( */\n  CHAR_RIGHT_PARENTHESES, /* ) */\n  CHAR_LEFT_CURLY_BRACE, /* { */\n  CHAR_RIGHT_CURLY_BRACE, /* } */\n  CHAR_LEFT_SQUARE_BRACKET, /* [ */\n  CHAR_RIGHT_SQUARE_BRACKET, /* ] */\n  CHAR_DOUBLE_QUOTE, /* \" */\n  CHAR_SINGLE_QUOTE, /* ' */\n  CHAR_NO_BREAK_SPACE,\n  CHAR_ZERO_WIDTH_NOBREAK_SPACE\n} = require('./constants');\n\n/**\n * parse\n */\n\nconst parse = (input, options = {}) => {\n  if (typeof input !== 'string') {\n    throw new TypeError('Expected a string');\n  }\n\n  let opts = options || {};\n  let max = typeof opts.maxLength === 'number' ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;\n  if (input.length > max) {\n    throw new SyntaxError(`Input length (${input.length}), exceeds max characters (${max})`);\n  }\n\n  let ast = { type: 'root', input, nodes: [] };\n  let stack = [ast];\n  let block = ast;\n  let prev = ast;\n  let brackets = 0;\n  let length = input.length;\n  let index = 0;\n  let depth = 0;\n  let value;\n  let memo = {};\n\n  /**\n   * Helpers\n   */\n\n  const advance = () => input[index++];\n  const push = node => {\n    if (node.type === 'text' && prev.type === 'dot') {\n      prev.type = 'text';\n    }\n\n    if (prev && prev.type === 'text' && node.type === 'text') {\n      prev.value += node.value;\n      return;\n    }\n\n    block.nodes.push(node);\n    node.parent = block;\n    node.prev = prev;\n    prev = node;\n    return node;\n  };\n\n  push({ type: 'bos' });\n\n  while (index < length) {\n    block = stack[stack.length - 1];\n    value = advance();\n\n    /**\n     * Invalid chars\n     */\n\n    if (value === CHAR_ZERO_WIDTH_NOBREAK_SPACE || value === CHAR_NO_BREAK_SPACE) {\n      continue;\n    }\n\n    /**\n     * Escaped chars\n     */\n\n    if (value === CHAR_BACKSLASH) {\n      push({ type: 'text', value: (options.keepEscaping ? value : '') + advance() });\n      continue;\n    }\n\n    /**\n     * Right square bracket (literal): ']'\n     */\n\n    if (value === CHAR_RIGHT_SQUARE_BRACKET) {\n      push({ type: 'text', value: '\\\\' + value });\n      continue;\n    }\n\n    /**\n     * Left square bracket: '['\n     */\n\n    if (value === CHAR_LEFT_SQUARE_BRACKET) {\n      brackets++;\n\n      let closed = true;\n      let next;\n\n      while (index < length && (next = advance())) {\n        value += next;\n\n        if (next === CHAR_LEFT_SQUARE_BRACKET) {\n          brackets++;\n          continue;\n        }\n\n        if (next === CHAR_BACKSLASH) {\n          value += advance();\n          continue;\n        }\n\n        if (next === CHAR_RIGHT_SQUARE_BRACKET) {\n          brackets--;\n\n          if (brackets === 0) {\n            break;\n          }\n        }\n      }\n\n      push({ type: 'text', value });\n      continue;\n    }\n\n    /**\n     * Parentheses\n     */\n\n    if (value === CHAR_LEFT_PARENTHESES) {\n      block = push({ type: 'paren', nodes: [] });\n      stack.push(block);\n      push({ type: 'text', value });\n      continue;\n    }\n\n    if (value === CHAR_RIGHT_PARENTHESES) {\n      if (block.type !== 'paren') {\n        push({ type: 'text', value });\n        continue;\n      }\n      block = stack.pop();\n      push({ type: 'text', value });\n      block = stack[stack.length - 1];\n      continue;\n    }\n\n    /**\n     * Quotes: '|\"|`\n     */\n\n    if (value === CHAR_DOUBLE_QUOTE || value === CHAR_SINGLE_QUOTE || value === CHAR_BACKTICK) {\n      let open = value;\n      let next;\n\n      if (options.keepQuotes !== true) {\n        value = '';\n      }\n\n      while (index < length && (next = advance())) {\n        if (next === CHAR_BACKSLASH) {\n          value += next + advance();\n          continue;\n        }\n\n        if (next === open) {\n          if (options.keepQuotes === true) value += next;\n          break;\n        }\n\n        value += next;\n      }\n\n      push({ type: 'text', value });\n      continue;\n    }\n\n    /**\n     * Left curly brace: '{'\n     */\n\n    if (value === CHAR_LEFT_CURLY_BRACE) {\n      depth++;\n\n      let dollar = prev.value && prev.value.slice(-1) === '$' || block.dollar === true;\n      let brace = {\n        type: 'brace',\n        open: true,\n        close: false,\n        dollar,\n        depth,\n        commas: 0,\n        ranges: 0,\n        nodes: []\n      };\n\n      block = push(brace);\n      stack.push(block);\n      push({ type: 'open', value });\n      continue;\n    }\n\n    /**\n     * Right curly brace: '}'\n     */\n\n    if (value === CHAR_RIGHT_CURLY_BRACE) {\n      if (block.type !== 'brace') {\n        push({ type: 'text', value });\n        continue;\n      }\n\n      let type = 'close';\n      block = stack.pop();\n      block.close = true;\n\n      push({ type, value });\n      depth--;\n\n      block = stack[stack.length - 1];\n      continue;\n    }\n\n    /**\n     * Comma: ','\n     */\n\n    if (value === CHAR_COMMA && depth > 0) {\n      if (block.ranges > 0) {\n        block.ranges = 0;\n        let open = block.nodes.shift();\n        block.nodes = [open, { type: 'text', value: stringify(block) }];\n      }\n\n      push({ type: 'comma', value });\n      block.commas++;\n      continue;\n    }\n\n    /**\n     * Dot: '.'\n     */\n\n    if (value === CHAR_DOT && depth > 0 && block.commas === 0) {\n      let siblings = block.nodes;\n\n      if (depth === 0 || siblings.length === 0) {\n        push({ type: 'text', value });\n        continue;\n      }\n\n      if (prev.type === 'dot') {\n        block.range = [];\n        prev.value += value;\n        prev.type = 'range';\n\n        if (block.nodes.length !== 3 && block.nodes.length !== 5) {\n          block.invalid = true;\n          block.ranges = 0;\n          prev.type = 'text';\n          continue;\n        }\n\n        block.ranges++;\n        block.args = [];\n        continue;\n      }\n\n      if (prev.type === 'range') {\n        siblings.pop();\n\n        let before = siblings[siblings.length - 1];\n        before.value += prev.value + value;\n        prev = before;\n        block.ranges--;\n        continue;\n      }\n\n      push({ type: 'dot', value });\n      continue;\n    }\n\n    /**\n     * Text\n     */\n\n    push({ type: 'text', value });\n  }\n\n  // Mark imbalanced braces and brackets as invalid\n  do {\n    block = stack.pop();\n\n    if (block.type !== 'root') {\n      block.nodes.forEach(node => {\n        if (!node.nodes) {\n          if (node.type === 'open') node.isOpen = true;\n          if (node.type === 'close') node.isClose = true;\n          if (!node.nodes) node.type = 'text';\n          node.invalid = true;\n        }\n      });\n\n      // get the location of the block on parent.nodes (block's siblings)\n      let parent = stack[stack.length - 1];\n      let index = parent.nodes.indexOf(block);\n      // replace the (invalid) block with it's nodes\n      parent.nodes.splice(index, 1, ...block.nodes);\n    }\n  } while (stack.length > 0);\n\n  push({ type: 'eos' });\n  return ast;\n};\n\nmodule.exports = parse;\n","'use strict';\n\nconst utils = require('./utils');\n\nmodule.exports = (ast, options = {}) => {\n  let stringify = (node, parent = {}) => {\n    let invalidBlock = options.escapeInvalid && utils.isInvalidBrace(parent);\n    let invalidNode = node.invalid === true && options.escapeInvalid === true;\n    let output = '';\n\n    if (node.value) {\n      if ((invalidBlock || invalidNode) && utils.isOpenOrClose(node)) {\n        return '\\\\' + node.value;\n      }\n      return node.value;\n    }\n\n    if (node.value) {\n      return node.value;\n    }\n\n    if (node.nodes) {\n      for (let child of node.nodes) {\n        output += stringify(child);\n      }\n    }\n    return output;\n  };\n\n  return stringify(ast);\n};\n\n","'use strict';\n\nexports.isInteger = num => {\n  if (typeof num === 'number') {\n    return Number.isInteger(num);\n  }\n  if (typeof num === 'string' && num.trim() !== '') {\n    return Number.isInteger(Number(num));\n  }\n  return false;\n};\n\n/**\n * Find a node of the given type\n */\n\nexports.find = (node, type) => node.nodes.find(node => node.type === type);\n\n/**\n * Find a node of the given type\n */\n\nexports.exceedsLimit = (min, max, step = 1, limit) => {\n  if (limit === false) return false;\n  if (!exports.isInteger(min) || !exports.isInteger(max)) return false;\n  return ((Number(max) - Number(min)) / Number(step)) >= limit;\n};\n\n/**\n * Escape the given node with '\\\\' before node.value\n */\n\nexports.escapeNode = (block, n = 0, type) => {\n  let node = block.nodes[n];\n  if (!node) return;\n\n  if ((type && node.type === type) || node.type === 'open' || node.type === 'close') {\n    if (node.escaped !== true) {\n      node.value = '\\\\' + node.value;\n      node.escaped = true;\n    }\n  }\n};\n\n/**\n * Returns true if the given brace node should be enclosed in literal braces\n */\n\nexports.encloseBrace = node => {\n  if (node.type !== 'brace') return false;\n  if ((node.commas >> 0 + node.ranges >> 0) === 0) {\n    node.invalid = true;\n    return true;\n  }\n  return false;\n};\n\n/**\n * Returns true if a brace node is invalid.\n */\n\nexports.isInvalidBrace = block => {\n  if (block.type !== 'brace') return false;\n  if (block.invalid === true || block.dollar) return true;\n  if ((block.commas >> 0 + block.ranges >> 0) === 0) {\n    block.invalid = true;\n    return true;\n  }\n  if (block.open !== true || block.close !== true) {\n    block.invalid = true;\n    return true;\n  }\n  return false;\n};\n\n/**\n * Returns true if a node is an open or close node\n */\n\nexports.isOpenOrClose = node => {\n  if (node.type === 'open' || node.type === 'close') {\n    return true;\n  }\n  return node.open === true || node.close === true;\n};\n\n/**\n * Reduce an array of text nodes.\n */\n\nexports.reduce = nodes => nodes.reduce((acc, node) => {\n  if (node.type === 'text') acc.push(node.value);\n  if (node.type === 'range') node.type = 'text';\n  return acc;\n}, []);\n\n/**\n * Flatten an array\n */\n\nexports.flatten = (...args) => {\n  const result = [];\n  const flat = arr => {\n    for (let i = 0; i < arr.length; i++) {\n      let ele = arr[i];\n      Array.isArray(ele) ? flat(ele, result) : ele !== void 0 && result.push(ele);\n    }\n    return result;\n  };\n  flat(args);\n  return result;\n};\n","'use strict';\nconst path = require('path');\nconst pathType = require('path-type');\n\nconst getExtensions = extensions => extensions.length > 1 ? `{${extensions.join(',')}}` : extensions[0];\n\nconst getPath = (filepath, cwd) => {\n\tconst pth = filepath[0] === '!' ? filepath.slice(1) : filepath;\n\treturn path.isAbsolute(pth) ? pth : path.join(cwd, pth);\n};\n\nconst addExtensions = (file, extensions) => {\n\tif (path.extname(file)) {\n\t\treturn `**/${file}`;\n\t}\n\n\treturn `**/${file}.${getExtensions(extensions)}`;\n};\n\nconst getGlob = (directory, options) => {\n\tif (options.files && !Array.isArray(options.files)) {\n\t\tthrow new TypeError(`Expected \\`files\\` to be of type \\`Array\\` but received type \\`${typeof options.files}\\``);\n\t}\n\n\tif (options.extensions && !Array.isArray(options.extensions)) {\n\t\tthrow new TypeError(`Expected \\`extensions\\` to be of type \\`Array\\` but received type \\`${typeof options.extensions}\\``);\n\t}\n\n\tif (options.files && options.extensions) {\n\t\treturn options.files.map(x => path.posix.join(directory, addExtensions(x, options.extensions)));\n\t}\n\n\tif (options.files) {\n\t\treturn options.files.map(x => path.posix.join(directory, `**/${x}`));\n\t}\n\n\tif (options.extensions) {\n\t\treturn [path.posix.join(directory, `**/*.${getExtensions(options.extensions)}`)];\n\t}\n\n\treturn [path.posix.join(directory, '**')];\n};\n\nmodule.exports = async (input, options) => {\n\toptions = {\n\t\tcwd: process.cwd(),\n\t\t...options\n\t};\n\n\tif (typeof options.cwd !== 'string') {\n\t\tthrow new TypeError(`Expected \\`cwd\\` to be of type \\`string\\` but received type \\`${typeof options.cwd}\\``);\n\t}\n\n\tconst globs = await Promise.all([].concat(input).map(async x => {\n\t\tconst isDirectory = await pathType.isDirectory(getPath(x, options.cwd));\n\t\treturn isDirectory ? getGlob(x, options) : x;\n\t}));\n\n\treturn [].concat.apply([], globs); // eslint-disable-line prefer-spread\n};\n\nmodule.exports.sync = (input, options) => {\n\toptions = {\n\t\tcwd: process.cwd(),\n\t\t...options\n\t};\n\n\tif (typeof options.cwd !== 'string') {\n\t\tthrow new TypeError(`Expected \\`cwd\\` to be of type \\`string\\` but received type \\`${typeof options.cwd}\\``);\n\t}\n\n\tconst globs = [].concat(input).map(x => pathType.isDirectorySync(getPath(x, options.cwd)) ? getGlob(x, options) : x);\n\n\treturn [].concat.apply([], globs); // eslint-disable-line prefer-spread\n};\n","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _dropbox = require(\"./src/dropbox.js\");\n\nObject.defineProperty(exports, \"Dropbox\", {\n  enumerable: true,\n  get: function get() {\n    return _dropbox[\"default\"];\n  }\n});\n\nvar _auth = require(\"./src/auth.js\");\n\nObject.defineProperty(exports, \"DropboxAuth\", {\n  enumerable: true,\n  get: function get() {\n    return _auth[\"default\"];\n  }\n});","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n// Auto-generated by Stone, do not modify.\nvar routes = {};\n/**\n * Sets a user's profile photo.\n * @function Dropbox#accountSetProfilePhoto\n * @arg {AccountSetProfilePhotoArg} arg - The request parameters.\n * @returns {Promise.<DropboxResponse<AccountSetProfilePhotoResult>, Error.<AccountSetProfilePhotoError>>}\n */\n\nroutes.accountSetProfilePhoto = function (arg) {\n  return this.request('account/set_profile_photo', arg, 'user', 'api', 'rpc');\n};\n/**\n * Creates an OAuth 2.0 access token from the supplied OAuth 1.0 access token.\n * @function Dropbox#authTokenFromOauth1\n * @arg {AuthTokenFromOAuth1Arg} arg - The request parameters.\n * @returns {Promise.<DropboxResponse<AuthTokenFromOAuth1Result>, Error.<AuthTokenFromOAuth1Error>>}\n */\n\n\nroutes.authTokenFromOauth1 = function (arg) {\n  return this.request('auth/token/from_oauth1', arg, 'app', 'api', 'rpc');\n};\n/**\n * Disables the access token used to authenticate the call.\n * @function Dropbox#authTokenRevoke\n * @returns {Promise.<DropboxResponse<void>, Error.<void>>}\n */\n\n\nroutes.authTokenRevoke = function () {\n  return this.request('auth/token/revoke', null, 'user', 'api', 'rpc');\n};\n/**\n * This endpoint performs App Authentication, validating the supplied app key\n * and secret, and returns the supplied string, to allow you to test your code\n * and connection to the Dropbox API. It has no other effect. If you receive an\n * HTTP 200 response with the supplied query, it indicates at least part of the\n * Dropbox API infrastructure is working and that the app key and secret valid.\n * @function Dropbox#checkApp\n * @arg {CheckEchoArg} arg - The request parameters.\n * @returns {Promise.<DropboxResponse<CheckEchoResult>, Error.<void>>}\n */\n\n\nroutes.checkApp = function (arg) {\n  return this.request('check/app', arg, 'app', 'api', 'rpc');\n};\n/**\n * This endpoint performs User Authentication, validating the supplied access\n * token, and returns the supplied string, to allow you to test your code and\n * connection to the Dropbox API. It has no other effect. If you receive an HTTP\n * 200 response with the supplied query, it indicates at least part of the\n * Dropbox API infrastructure is working and that the access token is valid.\n * @function Dropbox#checkUser\n * @arg {CheckEchoArg} arg - The request parameters.\n * @returns {Promise.<DropboxResponse<CheckEchoResult>, Error.<void>>}\n */\n\n\nroutes.checkUser = function (arg) {\n  return this.request('check/user', arg, 'user', 'api', 'rpc');\n};\n/**\n * Removes all manually added contacts. You'll still keep contacts who are on\n * your team or who you imported. New contacts will be added when you share.\n * @function Dropbox#contactsDeleteManualContacts\n * @returns {Promise.<DropboxResponse<void>, Error.<void>>}\n */\n\n\nroutes.contactsDeleteManualContacts = function () {\n  return this.request('contacts/delete_manual_contacts', null, 'user', 'api', 'rpc');\n};\n/**\n * Removes manually added contacts from the given list.\n * @function Dropbox#contactsDeleteManualContactsBatch\n * @arg {ContactsDeleteManualContactsArg} arg - The request parameters.\n * @returns {Promise.<DropboxResponse<void>, Error.<ContactsDeleteManualContactsError>>}\n */\n\n\nroutes.contactsDeleteManualContactsBatch = function (arg) {\n  return this.request('contacts/delete_manual_contacts_batch', arg, 'user', 'api', 'rpc');\n};\n/**\n * Add property groups to a Dropbox file. See templates/add_for_user or\n * templates/add_for_team to create new templates.\n * @function Dropbox#filePropertiesPropertiesAdd\n * @arg {FilePropertiesAddPropertiesArg} arg - The request parameters.\n * @returns {Promise.<DropboxResponse<void>, Error.<FilePropertiesAddPropertiesError>>}\n */\n\n\nroutes.filePropertiesPropertiesAdd = function (arg) {\n  return this.request('file_properties/properties/add', arg, 'user', 'api', 'rpc');\n};\n/**\n * Overwrite property groups associated with a file. This endpoint should be\n * used instead of properties/update when property groups are being updated via\n * a \"snapshot\" instead of via a \"delta\". In other words, this endpoint will\n * delete all omitted fields from a property group, whereas properties/update\n * will only delete fields that are explicitly marked for deletion.\n * @function Dropbox#filePropertiesPropertiesOverwrite\n * @arg {FilePropertiesOverwritePropertyGroupArg} arg - The request parameters.\n * @returns {Promise.<DropboxResponse<void>, Error.<FilePropertiesInvalidPropertyGroupError>>}\n */\n\n\nroutes.filePropertiesPropertiesOverwrite = function (arg) {\n  return this.request('file_properties/properties/overwrite', arg, 'user', 'api', 'rpc');\n};\n/**\n * Permanently removes the specified property group from the file. To remove\n * specific property field key value pairs, see properties/update. To update a\n * template, see templates/update_for_user or templates/update_for_team. To\n * remove a template, see templates/remove_for_user or\n * templates/remove_for_team.\n * @function Dropbox#filePropertiesPropertiesRemove\n * @arg {FilePropertiesRemovePropertiesArg} arg - The request parameters.\n * @returns {Promise.<DropboxResponse<void>, Error.<FilePropertiesRemovePropertiesError>>}\n */\n\n\nroutes.filePropertiesPropertiesRemove = function (arg) {\n  return this.request('file_properties/properties/remove', arg, 'user', 'api', 'rpc');\n};\n/**\n * Search across property templates for particular property field values.\n * @function Dropbox#filePropertiesPropertiesSearch\n * @arg {FilePropertiesPropertiesSearchArg} arg - The request parameters.\n * @returns {Promise.<DropboxResponse<FilePropertiesPropertiesSearchResult>, Error.<FilePropertiesPropertiesSearchError>>}\n */\n\n\nroutes.filePropertiesPropertiesSearch = function (arg) {\n  return this.request('file_properties/properties/search', arg, 'user', 'api', 'rpc');\n};\n/**\n * Once a cursor has been retrieved from properties/search, use this to paginate\n * through all search results.\n * @function Dropbox#filePropertiesPropertiesSearchContinue\n * @arg {FilePropertiesPropertiesSearchContinueArg} arg - The request parameters.\n * @returns {Promise.<DropboxResponse<FilePropertiesPropertiesSearchResult>, Error.<FilePropertiesPropertiesSearchContinueError>>}\n */\n\n\nroutes.filePropertiesPropertiesSearchContinue = function (arg) {\n  return this.request('file_properties/properties/search/continue', arg, 'user', 'api', 'rpc');\n};\n/**\n * Add, update or remove properties associated with the supplied file and\n * templates. This endpoint should be used instead of properties/overwrite when\n * property groups are being updated via a \"delta\" instead of via a \"snapshot\" .\n * In other words, this endpoint will not delete any omitted fields from a\n * property group, whereas properties/overwrite will delete any fields that are\n * omitted from a property group.\n * @function Dropbox#filePropertiesPropertiesUpdate\n * @arg {FilePropertiesUpdatePropertiesArg} arg - The request parameters.\n * @returns {Promise.<DropboxResponse<void>, Error.<FilePropertiesUpdatePropertiesError>>}\n */\n\n\nroutes.filePropertiesPropertiesUpdate = function (arg) {\n  return this.request('file_properties/properties/update', arg, 'user', 'api', 'rpc');\n};\n/**\n * Add a template associated with a team. See properties/add to add properties\n * to a file or folder. Note: this endpoint will create team-owned templates.\n * @function Dropbox#filePropertiesTemplatesAddForTeam\n * @arg {FilePropertiesAddTemplateArg} arg - The request parameters.\n * @returns {Promise.<DropboxResponse<FilePropertiesAddTemplateResult>, Error.<FilePropertiesModifyTemplateError>>}\n */\n\n\nroutes.filePropertiesTemplatesAddForTeam = function (arg) {\n  return this.request('file_properties/templates/add_for_team', arg, 'team', 'api', 'rpc');\n};\n/**\n * Add a template associated with a user. See properties/add to add properties\n * to a file. This endpoint can't be called on a team member or admin's behalf.\n * @function Dropbox#filePropertiesTemplatesAddForUser\n * @arg {FilePropertiesAddTemplateArg} arg - The request parameters.\n * @returns {Promise.<DropboxResponse<FilePropertiesAddTemplateResult>, Error.<FilePropertiesModifyTemplateError>>}\n */\n\n\nroutes.filePropertiesTemplatesAddForUser = function (arg) {\n  return this.request('file_properties/templates/add_for_user', arg, 'user', 'api', 'rpc');\n};\n/**\n * Get the schema for a specified template.\n * @function Dropbox#filePropertiesTemplatesGetForTeam\n * @arg {FilePropertiesGetTemplateArg} arg - The request parameters.\n * @returns {Promise.<DropboxResponse<FilePropertiesGetTemplateResult>, Error.<FilePropertiesTemplateError>>}\n */\n\n\nroutes.filePropertiesTemplatesGetForTeam = function (arg) {\n  return this.request('file_properties/templates/get_for_team', arg, 'team', 'api', 'rpc');\n};\n/**\n * Get the schema for a specified template. This endpoint can't be called on a\n * team member or admin's behalf.\n * @function Dropbox#filePropertiesTemplatesGetForUser\n * @arg {FilePropertiesGetTemplateArg} arg - The request parameters.\n * @returns {Promise.<DropboxResponse<FilePropertiesGetTemplateResult>, Error.<FilePropertiesTemplateError>>}\n */\n\n\nroutes.filePropertiesTemplatesGetForUser = function (arg) {\n  return this.request('file_properties/templates/get_for_user', arg, 'user', 'api', 'rpc');\n};\n/**\n * Get the template identifiers for a team. To get the schema of each template\n * use templates/get_for_team.\n * @function Dropbox#filePropertiesTemplatesListForTeam\n * @returns {Promise.<DropboxResponse<FilePropertiesListTemplateResult>, Error.<FilePropertiesTemplateError>>}\n */\n\n\nroutes.filePropertiesTemplatesListForTeam = function () {\n  return this.request('file_properties/templates/list_for_team', null, 'team', 'api', 'rpc');\n};\n/**\n * Get the template identifiers for a team. To get the schema of each template\n * use templates/get_for_user. This endpoint can't be called on a team member or\n * admin's behalf.\n * @function Dropbox#filePropertiesTemplatesListForUser\n * @returns {Promise.<DropboxResponse<FilePropertiesListTemplateResult>, Error.<FilePropertiesTemplateError>>}\n */\n\n\nroutes.filePropertiesTemplatesListForUser = function () {\n  return this.request('file_properties/templates/list_for_user', null, 'user', 'api', 'rpc');\n};\n/**\n * Permanently removes the specified template created from\n * templates/add_for_user. All properties associated with the template will also\n * be removed. This action cannot be undone.\n * @function Dropbox#filePropertiesTemplatesRemoveForTeam\n * @arg {FilePropertiesRemoveTemplateArg} arg - The request parameters.\n * @returns {Promise.<DropboxResponse<void>, Error.<FilePropertiesTemplateError>>}\n */\n\n\nroutes.filePropertiesTemplatesRemoveForTeam = function (arg) {\n  return this.request('file_properties/templates/remove_for_team', arg, 'team', 'api', 'rpc');\n};\n/**\n * Permanently removes the specified template created from\n * templates/add_for_user. All properties associated with the template will also\n * be removed. This action cannot be undone.\n * @function Dropbox#filePropertiesTemplatesRemoveForUser\n * @arg {FilePropertiesRemoveTemplateArg} arg - The request parameters.\n * @returns {Promise.<DropboxResponse<void>, Error.<FilePropertiesTemplateError>>}\n */\n\n\nroutes.filePropertiesTemplatesRemoveForUser = function (arg) {\n  return this.request('file_properties/templates/remove_for_user', arg, 'user', 'api', 'rpc');\n};\n/**\n * Update a template associated with a team. This route can update the template\n * name, the template description and add optional properties to templates.\n * @function Dropbox#filePropertiesTemplatesUpdateForTeam\n * @arg {FilePropertiesUpdateTemplateArg} arg - The request parameters.\n * @returns {Promise.<DropboxResponse<FilePropertiesUpdateTemplateResult>, Error.<FilePropertiesModifyTemplateError>>}\n */\n\n\nroutes.filePropertiesTemplatesUpdateForTeam = function (arg) {\n  return this.request('file_properties/templates/update_for_team', arg, 'team', 'api', 'rpc');\n};\n/**\n * Update a template associated with a user. This route can update the template\n * name, the template description and add optional properties to templates. This\n * endpoint can't be called on a team member or admin's behalf.\n * @function Dropbox#filePropertiesTemplatesUpdateForUser\n * @arg {FilePropertiesUpdateTemplateArg} arg - The request parameters.\n * @returns {Promise.<DropboxResponse<FilePropertiesUpdateTemplateResult>, Error.<FilePropertiesModifyTemplateError>>}\n */\n\n\nroutes.filePropertiesTemplatesUpdateForUser = function (arg) {\n  return this.request('file_properties/templates/update_for_user', arg, 'user', 'api', 'rpc');\n};\n/**\n * Returns the total number of file requests owned by this user. Includes both\n * open and closed file requests.\n * @function Dropbox#fileRequestsCount\n * @returns {Promise.<DropboxResponse<FileRequestsCountFileRequestsResult>, Error.<FileRequestsCountFileRequestsError>>}\n */\n\n\nroutes.fileRequestsCount = function () {\n  return this.request('file_requests/count', null, 'user', 'api', 'rpc');\n};\n/**\n * Creates a file request for this user.\n * @function Dropbox#fileRequestsCreate\n * @arg {FileRequestsCreateFileRequestArgs} arg - The request parameters.\n * @returns {Promise.<DropboxResponse<FileRequestsFileRequest>, Error.<FileRequestsCreateFileRequestError>>}\n */\n\n\nroutes.fileRequestsCreate = function (arg) {\n  return this.request('file_requests/create', arg, 'user', 'api', 'rpc');\n};\n/**\n * Delete a batch of closed file requests.\n * @function Dropbox#fileRequestsDelete\n * @arg {FileRequestsDeleteFileRequestArgs} arg - The request parameters.\n * @returns {Promise.<DropboxResponse<FileRequestsDeleteFileRequestsResult>, Error.<FileRequestsDeleteFileRequestError>>}\n */\n\n\nroutes.fileRequestsDelete = function (arg) {\n  return this.request('file_requests/delete', arg, 'user', 'api', 'rpc');\n};\n/**\n * Delete all closed file requests owned by this user.\n * @function Dropbox#fileRequestsDeleteAllClosed\n * @returns {Promise.<DropboxResponse<FileRequestsDeleteAllClosedFileRequestsResult>, Error.<FileRequestsDeleteAllClosedFileRequestsError>>}\n */\n\n\nroutes.fileRequestsDeleteAllClosed = function () {\n  return this.request('file_requests/delete_all_closed', null, 'user', 'api', 'rpc');\n};\n/**\n * Returns the specified file request.\n * @function Dropbox#fileRequestsGet\n * @arg {FileRequestsGetFileRequestArgs} arg - The request parameters.\n * @returns {Promise.<DropboxResponse<FileRequestsFileRequest>, Error.<FileRequestsGetFileRequestError>>}\n */\n\n\nroutes.fileRequestsGet = function (arg) {\n  return this.request('file_requests/get', arg, 'user', 'api', 'rpc');\n};\n/**\n * Returns a list of file requests owned by this user. For apps with the app\n * folder permission, this will only return file requests with destinations in\n * the app folder.\n * @function Dropbox#fileRequestsListV2\n * @arg {FileRequestsListFileRequestsArg} arg - The request parameters.\n * @returns {Promise.<DropboxResponse<FileRequestsListFileRequestsV2Result>, Error.<FileRequestsListFileRequestsError>>}\n */\n\n\nroutes.fileRequestsListV2 = function (arg) {\n  return this.request('file_requests/list_v2', arg, 'user', 'api', 'rpc');\n};\n/**\n * Returns a list of file requests owned by this user. For apps with the app\n * folder permission, this will only return file requests with destinations in\n * the app folder.\n * @function Dropbox#fileRequestsList\n * @returns {Promise.<DropboxResponse<FileRequestsListFileRequestsResult>, Error.<FileRequestsListFileRequestsError>>}\n */\n\n\nroutes.fileRequestsList = function () {\n  return this.request('file_requests/list', null, 'user', 'api', 'rpc');\n};\n/**\n * Once a cursor has been retrieved from list_v2, use this to paginate through\n * all file requests. The cursor must come from a previous call to list_v2 or\n * list/continue.\n * @function Dropbox#fileRequestsListContinue\n * @arg {FileRequestsListFileRequestsContinueArg} arg - The request parameters.\n * @returns {Promise.<DropboxResponse<FileRequestsListFileRequestsV2Result>, Error.<FileRequestsListFileRequestsContinueError>>}\n */\n\n\nroutes.fileRequestsListContinue = function (arg) {\n  return this.request('file_requests/list/continue', arg, 'user', 'api', 'rpc');\n};\n/**\n * Update a file request.\n * @function Dropbox#fileRequestsUpdate\n * @arg {FileRequestsUpdateFileRequestArgs} arg - The request parameters.\n * @returns {Promise.<DropboxResponse<FileRequestsFileRequest>, Error.<FileRequestsUpdateFileRequestError>>}\n */\n\n\nroutes.fileRequestsUpdate = function (arg) {\n  return this.request('file_requests/update', arg, 'user', 'api', 'rpc');\n};\n/**\n * Returns the metadata for a file or folder. This is an alpha endpoint\n * compatible with the properties API. Note: Metadata for the root folder is\n * unsupported.\n * @function Dropbox#filesAlphaGetMetadata\n * @deprecated\n * @arg {FilesAlphaGetMetadataArg} arg - The request parameters.\n * @returns {Promise.<DropboxResponse<(FilesFileMetadata|FilesFolderMetadata|FilesDeletedMetadata)>, Error.<FilesAlphaGetMetadataError>>}\n */\n\n\nroutes.filesAlphaGetMetadata = function (arg) {\n  return this.request('files/alpha/get_metadata', arg, 'user', 'api', 'rpc');\n};\n/**\n * Create a new file with the contents provided in the request. Note that this\n * endpoint is part of the properties API alpha and is slightly different from\n * upload. Do not use this to upload a file larger than 150 MB. Instead, create\n * an upload session with upload_session/start.\n * @function Dropbox#filesAlphaUpload\n * @deprecated\n * @arg {FilesCommitInfoWithProperties} arg - The request parameters.\n * @returns {Promise.<DropboxResponse<FilesFileMetadata>, Error.<FilesUploadErrorWithProperties>>}\n */\n\n\nroutes.filesAlphaUpload = function (arg) {\n  return this.request('files/alpha/upload', arg, 'user', 'content', 'upload');\n};\n/**\n * Copy a file or folder to a different location in the user's Dropbox. If the\n * source path is a folder all its contents will be copied.\n * @function Dropbox#filesCopyV2\n * @arg {FilesRelocationArg} arg - The request parameters.\n * @returns {Promise.<DropboxResponse<FilesRelocationResult>, Error.<FilesRelocationError>>}\n */\n\n\nroutes.filesCopyV2 = function (arg) {\n  return this.request('files/copy_v2', arg, 'user', 'api', 'rpc');\n};\n/**\n * Copy a file or folder to a different location in the user's Dropbox. If the\n * source path is a folder all its contents will be copied.\n * @function Dropbox#filesCopy\n * @deprecated\n * @arg {FilesRelocationArg} arg - The request parameters.\n * @returns {Promise.<DropboxResponse<(FilesFileMetadata|FilesFolderMetadata|FilesDeletedMetadata)>, Error.<FilesRelocationError>>}\n */\n\n\nroutes.filesCopy = function (arg) {\n  return this.request('files/copy', arg, 'user', 'api', 'rpc');\n};\n/**\n * Copy multiple files or folders to different locations at once in the user's\n * Dropbox. This route will replace copy_batch. The main difference is this\n * route will return status for each entry, while copy_batch raises failure if\n * any entry fails. This route will either finish synchronously, or return a job\n * ID and do the async copy job in background. Please use copy_batch/check_v2 to\n * check the job status.\n * @function Dropbox#filesCopyBatchV2\n * @arg {Object} arg - The request parameters.\n * @returns {Promise.<DropboxResponse<FilesRelocationBatchV2Launch>, Error.<void>>}\n */\n\n\nroutes.filesCopyBatchV2 = function (arg) {\n  return this.request('files/copy_batch_v2', arg, 'user', 'api', 'rpc');\n};\n/**\n * Copy multiple files or folders to different locations at once in the user's\n * Dropbox. This route will return job ID immediately and do the async copy job\n * in background. Please use copy_batch/check to check the job status.\n * @function Dropbox#filesCopyBatch\n * @deprecated\n * @arg {FilesRelocationBatchArg} arg - The request parameters.\n * @returns {Promise.<DropboxResponse<FilesRelocationBatchLaunch>, Error.<void>>}\n */\n\n\nroutes.filesCopyBatch = function (arg) {\n  return this.request('files/copy_batch', arg, 'user', 'api', 'rpc');\n};\n/**\n * Returns the status of an asynchronous job for copy_batch_v2. It returns list\n * of results for each entry.\n * @function Dropbox#filesCopyBatchCheckV2\n * @arg {AsyncPollArg} arg - The request parameters.\n * @returns {Promise.<DropboxResponse<FilesRelocationBatchV2JobStatus>, Error.<AsyncPollError>>}\n */\n\n\nroutes.filesCopyBatchCheckV2 = function (arg) {\n  return this.request('files/copy_batch/check_v2', arg, 'user', 'api', 'rpc');\n};\n/**\n * Returns the status of an asynchronous job for copy_batch. If success, it\n * returns list of results for each entry.\n * @function Dropbox#filesCopyBatchCheck\n * @deprecated\n * @arg {AsyncPollArg} arg - The request parameters.\n * @returns {Promise.<DropboxResponse<FilesRelocationBatchJobStatus>, Error.<AsyncPollError>>}\n */\n\n\nroutes.filesCopyBatchCheck = function (arg) {\n  return this.request('files/copy_batch/check', arg, 'user', 'api', 'rpc');\n};\n/**\n * Get a copy reference to a file or folder. This reference string can be used\n * to save that file or folder to another user's Dropbox by passing it to\n * copy_reference/save.\n * @function Dropbox#filesCopyReferenceGet\n * @arg {FilesGetCopyReferenceArg} arg - The request parameters.\n * @returns {Promise.<DropboxResponse<FilesGetCopyReferenceResult>, Error.<FilesGetCopyReferenceError>>}\n */\n\n\nroutes.filesCopyReferenceGet = function (arg) {\n  return this.request('files/copy_reference/get', arg, 'user', 'api', 'rpc');\n};\n/**\n * Save a copy reference returned by copy_reference/get to the user's Dropbox.\n * @function Dropbox#filesCopyReferenceSave\n * @arg {FilesSaveCopyReferenceArg} arg - The request parameters.\n * @returns {Promise.<DropboxResponse<FilesSaveCopyReferenceResult>, Error.<FilesSaveCopyReferenceError>>}\n */\n\n\nroutes.filesCopyReferenceSave = function (arg) {\n  return this.request('files/copy_reference/save', arg, 'user', 'api', 'rpc');\n};\n/**\n * Create a folder at a given path.\n * @function Dropbox#filesCreateFolderV2\n * @arg {FilesCreateFolderArg} arg - The request parameters.\n * @returns {Promise.<DropboxResponse<FilesCreateFolderResult>, Error.<FilesCreateFolderError>>}\n */\n\n\nroutes.filesCreateFolderV2 = function (arg) {\n  return this.request('files/create_folder_v2', arg, 'user', 'api', 'rpc');\n};\n/**\n * Create a folder at a given path.\n * @function Dropbox#filesCreateFolder\n * @deprecated\n * @arg {FilesCreateFolderArg} arg - The request parameters.\n * @returns {Promise.<DropboxResponse<FilesFolderMetadata>, Error.<FilesCreateFolderError>>}\n */\n\n\nroutes.filesCreateFolder = function (arg) {\n  return this.request('files/create_folder', arg, 'user', 'api', 'rpc');\n};\n/**\n * Create multiple folders at once. This route is asynchronous for large\n * batches, which returns a job ID immediately and runs the create folder batch\n * asynchronously. Otherwise, creates the folders and returns the result\n * synchronously for smaller inputs. You can force asynchronous behaviour by\n * using the CreateFolderBatchArg.force_async flag.  Use\n * create_folder_batch/check to check the job status.\n * @function Dropbox#filesCreateFolderBatch\n * @arg {FilesCreateFolderBatchArg} arg - The request parameters.\n * @returns {Promise.<DropboxResponse<FilesCreateFolderBatchLaunch>, Error.<void>>}\n */\n\n\nroutes.filesCreateFolderBatch = function (arg) {\n  return this.request('files/create_folder_batch', arg, 'user', 'api', 'rpc');\n};\n/**\n * Returns the status of an asynchronous job for create_folder_batch. If\n * success, it returns list of result for each entry.\n * @function Dropbox#filesCreateFolderBatchCheck\n * @arg {AsyncPollArg} arg - The request parameters.\n * @returns {Promise.<DropboxResponse<FilesCreateFolderBatchJobStatus>, Error.<AsyncPollError>>}\n */\n\n\nroutes.filesCreateFolderBatchCheck = function (arg) {\n  return this.request('files/create_folder_batch/check', arg, 'user', 'api', 'rpc');\n};\n/**\n * Delete the file or folder at a given path. If the path is a folder, all its\n * contents will be deleted too. A successful response indicates that the file\n * or folder was deleted. The returned metadata will be the corresponding\n * FileMetadata or FolderMetadata for the item at time of deletion, and not a\n * DeletedMetadata object.\n * @function Dropbox#filesDeleteV2\n * @arg {FilesDeleteArg} arg - The request parameters.\n * @returns {Promise.<DropboxResponse<FilesDeleteResult>, Error.<FilesDeleteError>>}\n */\n\n\nroutes.filesDeleteV2 = function (arg) {\n  return this.request('files/delete_v2', arg, 'user', 'api', 'rpc');\n};\n/**\n * Delete the file or folder at a given path. If the path is a folder, all its\n * contents will be deleted too. A successful response indicates that the file\n * or folder was deleted. The returned metadata will be the corresponding\n * FileMetadata or FolderMetadata for the item at time of deletion, and not a\n * DeletedMetadata object.\n * @function Dropbox#filesDelete\n * @deprecated\n * @arg {FilesDeleteArg} arg - The request parameters.\n * @returns {Promise.<DropboxResponse<(FilesFileMetadata|FilesFolderMetadata|FilesDeletedMetadata)>, Error.<FilesDeleteError>>}\n */\n\n\nroutes.filesDelete = function (arg) {\n  return this.request('files/delete', arg, 'user', 'api', 'rpc');\n};\n/**\n * Delete multiple files/folders at once. This route is asynchronous, which\n * returns a job ID immediately and runs the delete batch asynchronously. Use\n * delete_batch/check to check the job status.\n * @function Dropbox#filesDeleteBatch\n * @arg {FilesDeleteBatchArg} arg - The request parameters.\n * @returns {Promise.<DropboxResponse<FilesDeleteBatchLaunch>, Error.<void>>}\n */\n\n\nroutes.filesDeleteBatch = function (arg) {\n  return this.request('files/delete_batch', arg, 'user', 'api', 'rpc');\n};\n/**\n * Returns the status of an asynchronous job for delete_batch. If success, it\n * returns list of result for each entry.\n * @function Dropbox#filesDeleteBatchCheck\n * @arg {AsyncPollArg} arg - The request parameters.\n * @returns {Promise.<DropboxResponse<FilesDeleteBatchJobStatus>, Error.<AsyncPollError>>}\n */\n\n\nroutes.filesDeleteBatchCheck = function (arg) {\n  return this.request('files/delete_batch/check', arg, 'user', 'api', 'rpc');\n};\n/**\n * Download a file from a user's Dropbox.\n * @function Dropbox#filesDownload\n * @arg {FilesDownloadArg} arg - The request parameters.\n * @returns {Promise.<DropboxResponse<FilesFileMetadata>, Error.<FilesDownloadError>>}\n */\n\n\nroutes.filesDownload = function (arg) {\n  return this.request('files/download', arg, 'user', 'content', 'download');\n};\n/**\n * Download a folder from the user's Dropbox, as a zip file. The folder must be\n * less than 20 GB in size and have fewer than 10,000 total files. The input\n * cannot be a single file. Any single file must be less than 4GB in size.\n * @function Dropbox#filesDownloadZip\n * @arg {FilesDownloadZipArg} arg - The request parameters.\n * @returns {Promise.<DropboxResponse<FilesDownloadZipResult>, Error.<FilesDownloadZipError>>}\n */\n\n\nroutes.filesDownloadZip = function (arg) {\n  return this.request('files/download_zip', arg, 'user', 'content', 'download');\n};\n/**\n * Export a file from a user's Dropbox. This route only supports exporting files\n * that cannot be downloaded directly  and whose ExportResult.file_metadata has\n * ExportInfo.export_as populated.\n * @function Dropbox#filesExport\n * @arg {FilesExportArg} arg - The request parameters.\n * @returns {Promise.<DropboxResponse<FilesExportResult>, Error.<FilesExportError>>}\n */\n\n\nroutes.filesExport = function (arg) {\n  return this.request('files/export', arg, 'user', 'content', 'download');\n};\n/**\n * Return the lock metadata for the given list of paths.\n * @function Dropbox#filesGetFileLockBatch\n * @arg {FilesLockFileBatchArg} arg - The request parameters.\n * @returns {Promise.<DropboxResponse<FilesLockFileBatchResult>, Error.<FilesLockFileError>>}\n */\n\n\nroutes.filesGetFileLockBatch = function (arg) {\n  return this.request('files/get_file_lock_batch', arg, 'user', 'api', 'rpc');\n};\n/**\n * Returns the metadata for a file or folder. Note: Metadata for the root folder\n * is unsupported.\n * @function Dropbox#filesGetMetadata\n * @arg {FilesGetMetadataArg} arg - The request parameters.\n * @returns {Promise.<DropboxResponse<(FilesFileMetadata|FilesFolderMetadata|FilesDeletedMetadata)>, Error.<FilesGetMetadataError>>}\n */\n\n\nroutes.filesGetMetadata = function (arg) {\n  return this.request('files/get_metadata', arg, 'user', 'api', 'rpc');\n};\n/**\n * Get a preview for a file. Currently, PDF previews are generated for files\n * with the following extensions: .ai, .doc, .docm, .docx, .eps, .gdoc,\n * .gslides, .odp, .odt, .pps, .ppsm, .ppsx, .ppt, .pptm, .pptx, .rtf. HTML\n * previews are generated for files with the following extensions: .csv, .ods,\n * .xls, .xlsm, .gsheet, .xlsx. Other formats will return an unsupported\n * extension error.\n * @function Dropbox#filesGetPreview\n * @arg {FilesPreviewArg} arg - The request parameters.\n * @returns {Promise.<DropboxResponse<FilesFileMetadata>, Error.<FilesPreviewError>>}\n */\n\n\nroutes.filesGetPreview = function (arg) {\n  return this.request('files/get_preview', arg, 'user', 'content', 'download');\n};\n/**\n * Get a temporary link to stream content of a file. This link will expire in\n * four hours and afterwards you will get 410 Gone. This URL should not be used\n * to display content directly in the browser. The Content-Type of the link is\n * determined automatically by the file's mime type.\n * @function Dropbox#filesGetTemporaryLink\n * @arg {FilesGetTemporaryLinkArg} arg - The request parameters.\n * @returns {Promise.<DropboxResponse<FilesGetTemporaryLinkResult>, Error.<FilesGetTemporaryLinkError>>}\n */\n\n\nroutes.filesGetTemporaryLink = function (arg) {\n  return this.request('files/get_temporary_link', arg, 'user', 'api', 'rpc');\n};\n/**\n * Get a one-time use temporary upload link to upload a file to a Dropbox\n * location.  This endpoint acts as a delayed upload. The returned temporary\n * upload link may be used to make a POST request with the data to be uploaded.\n * The upload will then be perfomed with the CommitInfo previously provided to\n * get_temporary_upload_link but evaluated only upon consumption. Hence, errors\n * stemming from invalid CommitInfo with respect to the state of the user's\n * Dropbox will only be communicated at consumption time. Additionally, these\n * errors are surfaced as generic HTTP 409 Conflict responses, potentially\n * hiding issue details. The maximum temporary upload link duration is 4 hours.\n * Upon consumption or expiration, a new link will have to be generated.\n * Multiple links may exist for a specific upload path at any given time.  The\n * POST request on the temporary upload link must have its Content-Type set to\n * \"application/octet-stream\".  Example temporary upload link consumption\n * request:  curl -X POST\n * https://content.dropboxapi.com/apitul/1/bNi2uIYF51cVBND --header\n * \"Content-Type: application/octet-stream\" --data-binary @local_file.txt  A\n * successful temporary upload link consumption request returns the content hash\n * of the uploaded data in JSON format.  Example succesful temporary upload link\n * consumption response: {\"content-hash\":\n * \"599d71033d700ac892a0e48fa61b125d2f5994\"}  An unsuccessful temporary upload\n * link consumption request returns any of the following status codes:  HTTP 400\n * Bad Request: Content-Type is not one of application/octet-stream and\n * text/plain or request is invalid. HTTP 409 Conflict: The temporary upload\n * link does not exist or is currently unavailable, the upload failed, or\n * another error happened. HTTP 410 Gone: The temporary upload link is expired\n * or consumed.  Example unsuccessful temporary upload link consumption\n * response: Temporary upload link has been recently consumed.\n * @function Dropbox#filesGetTemporaryUploadLink\n * @arg {FilesGetTemporaryUploadLinkArg} arg - The request parameters.\n * @returns {Promise.<DropboxResponse<FilesGetTemporaryUploadLinkResult>, Error.<void>>}\n */\n\n\nroutes.filesGetTemporaryUploadLink = function (arg) {\n  return this.request('files/get_temporary_upload_link', arg, 'user', 'api', 'rpc');\n};\n/**\n * Get a thumbnail for an image. This method currently supports files with the\n * following file extensions: jpg, jpeg, png, tiff, tif, gif and bmp. Photos\n * that are larger than 20MB in size won't be converted to a thumbnail.\n * @function Dropbox#filesGetThumbnail\n * @arg {FilesThumbnailArg} arg - The request parameters.\n * @returns {Promise.<DropboxResponse<FilesFileMetadata>, Error.<FilesThumbnailError>>}\n */\n\n\nroutes.filesGetThumbnail = function (arg) {\n  return this.request('files/get_thumbnail', arg, 'user', 'content', 'download');\n};\n/**\n * Get a thumbnail for a file.\n * @function Dropbox#filesGetThumbnailV2\n * @arg {FilesThumbnailV2Arg} arg - The request parameters.\n * @returns {Promise.<DropboxResponse<FilesPreviewResult>, Error.<FilesThumbnailV2Error>>}\n */\n\n\nroutes.filesGetThumbnailV2 = function (arg) {\n  return this.request('files/get_thumbnail_v2', arg, 'app, user', 'content', 'download');\n};\n/**\n * Get thumbnails for a list of images. We allow up to 25 thumbnails in a single\n * batch. This method currently supports files with the following file\n * extensions: jpg, jpeg, png, tiff, tif, gif and bmp. Photos that are larger\n * than 20MB in size won't be converted to a thumbnail.\n * @function Dropbox#filesGetThumbnailBatch\n * @arg {FilesGetThumbnailBatchArg} arg - The request parameters.\n * @returns {Promise.<DropboxResponse<FilesGetThumbnailBatchResult>, Error.<FilesGetThumbnailBatchError>>}\n */\n\n\nroutes.filesGetThumbnailBatch = function (arg) {\n  return this.request('files/get_thumbnail_batch', arg, 'user', 'content', 'rpc');\n};\n/**\n * Starts returning the contents of a folder. If the result's\n * ListFolderResult.has_more field is true, call list_folder/continue with the\n * returned ListFolderResult.cursor to retrieve more entries. If you're using\n * ListFolderArg.recursive set to true to keep a local cache of the contents of\n * a Dropbox account, iterate through each entry in order and process them as\n * follows to keep your local state in sync: For each FileMetadata, store the\n * new entry at the given path in your local state. If the required parent\n * folders don't exist yet, create them. If there's already something else at\n * the given path, replace it and remove all its children. For each\n * FolderMetadata, store the new entry at the given path in your local state. If\n * the required parent folders don't exist yet, create them. If there's already\n * something else at the given path, replace it but leave the children as they\n * are. Check the new entry's FolderSharingInfo.read_only and set all its\n * children's read-only statuses to match. For each DeletedMetadata, if your\n * local state has something at the given path, remove it and all its children.\n * If there's nothing at the given path, ignore this entry. Note:\n * auth.RateLimitError may be returned if multiple list_folder or\n * list_folder/continue calls with same parameters are made simultaneously by\n * same API app for same user. If your app implements retry logic, please hold\n * off the retry until the previous request finishes.\n * @function Dropbox#filesListFolder\n * @arg {FilesListFolderArg} arg - The request parameters.\n * @returns {Promise.<DropboxResponse<FilesListFolderResult>, Error.<FilesListFolderError>>}\n */\n\n\nroutes.filesListFolder = function (arg) {\n  return this.request('files/list_folder', arg, 'user', 'api', 'rpc');\n};\n/**\n * Once a cursor has been retrieved from list_folder, use this to paginate\n * through all files and retrieve updates to the folder, following the same\n * rules as documented for list_folder.\n * @function Dropbox#filesListFolderContinue\n * @arg {FilesListFolderContinueArg} arg - The request parameters.\n * @returns {Promise.<DropboxResponse<FilesListFolderResult>, Error.<FilesListFolderContinueError>>}\n */\n\n\nroutes.filesListFolderContinue = function (arg) {\n  return this.request('files/list_folder/continue', arg, 'user', 'api', 'rpc');\n};\n/**\n * A way to quickly get a cursor for the folder's state. Unlike list_folder,\n * list_folder/get_latest_cursor doesn't return any entries. This endpoint is\n * for app which only needs to know about new files and modifications and\n * doesn't need to know about files that already exist in Dropbox.\n * @function Dropbox#filesListFolderGetLatestCursor\n * @arg {FilesListFolderArg} arg - The request parameters.\n * @returns {Promise.<DropboxResponse<FilesListFolderGetLatestCursorResult>, Error.<FilesListFolderError>>}\n */\n\n\nroutes.filesListFolderGetLatestCursor = function (arg) {\n  return this.request('files/list_folder/get_latest_cursor', arg, 'user', 'api', 'rpc');\n};\n/**\n * A longpoll endpoint to wait for changes on an account. In conjunction with\n * list_folder/continue, this call gives you a low-latency way to monitor an\n * account for file changes. The connection will block until there are changes\n * available or a timeout occurs. This endpoint is useful mostly for client-side\n * apps. If you're looking for server-side notifications, check out our webhooks\n * documentation https://www.dropbox.com/developers/reference/webhooks.\n * @function Dropbox#filesListFolderLongpoll\n * @arg {FilesListFolderLongpollArg} arg - The request parameters.\n * @returns {Promise.<DropboxResponse<FilesListFolderLongpollResult>, Error.<FilesListFolderLongpollError>>}\n */\n\n\nroutes.filesListFolderLongpoll = function (arg) {\n  return this.request('files/list_folder/longpoll', arg, 'noauth', 'notify', 'rpc');\n};\n/**\n * Returns revisions for files based on a file path or a file id. The file path\n * or file id is identified from the latest file entry at the given file path or\n * id. This end point allows your app to query either by file path or file id by\n * setting the mode parameter appropriately. In the ListRevisionsMode.path\n * (default) mode, all revisions at the same file path as the latest file entry\n * are returned. If revisions with the same file id are desired, then mode must\n * be set to ListRevisionsMode.id. The ListRevisionsMode.id mode is useful to\n * retrieve revisions for a given file across moves or renames.\n * @function Dropbox#filesListRevisions\n * @arg {FilesListRevisionsArg} arg - The request parameters.\n * @returns {Promise.<DropboxResponse<FilesListRevisionsResult>, Error.<FilesListRevisionsError>>}\n */\n\n\nroutes.filesListRevisions = function (arg) {\n  return this.request('files/list_revisions', arg, 'user', 'api', 'rpc');\n};\n/**\n * Lock the files at the given paths. A locked file will be writable only by the\n * lock holder. A successful response indicates that the file has been locked.\n * Returns a list of the locked file paths and their metadata after this\n * operation.\n * @function Dropbox#filesLockFileBatch\n * @arg {FilesLockFileBatchArg} arg - The request parameters.\n * @returns {Promise.<DropboxResponse<FilesLockFileBatchResult>, Error.<FilesLockFileError>>}\n */\n\n\nroutes.filesLockFileBatch = function (arg) {\n  return this.request('files/lock_file_batch', arg, 'user', 'api', 'rpc');\n};\n/**\n * Move a file or folder to a different location in the user's Dropbox. If the\n * source path is a folder all its contents will be moved. Note that we do not\n * currently support case-only renaming.\n * @function Dropbox#filesMoveV2\n * @arg {FilesRelocationArg} arg - The request parameters.\n * @returns {Promise.<DropboxResponse<FilesRelocationResult>, Error.<FilesRelocationError>>}\n */\n\n\nroutes.filesMoveV2 = function (arg) {\n  return this.request('files/move_v2', arg, 'user', 'api', 'rpc');\n};\n/**\n * Move a file or folder to a different location in the user's Dropbox. If the\n * source path is a folder all its contents will be moved.\n * @function Dropbox#filesMove\n * @deprecated\n * @arg {FilesRelocationArg} arg - The request parameters.\n * @returns {Promise.<DropboxResponse<(FilesFileMetadata|FilesFolderMetadata|FilesDeletedMetadata)>, Error.<FilesRelocationError>>}\n */\n\n\nroutes.filesMove = function (arg) {\n  return this.request('files/move', arg, 'user', 'api', 'rpc');\n};\n/**\n * Move multiple files or folders to different locations at once in the user's\n * Dropbox. Note that we do not currently support case-only renaming. This route\n * will replace move_batch. The main difference is this route will return status\n * for each entry, while move_batch raises failure if any entry fails. This\n * route will either finish synchronously, or return a job ID and do the async\n * move job in background. Please use move_batch/check_v2 to check the job\n * status.\n * @function Dropbox#filesMoveBatchV2\n * @arg {FilesMoveBatchArg} arg - The request parameters.\n * @returns {Promise.<DropboxResponse<FilesRelocationBatchV2Launch>, Error.<void>>}\n */\n\n\nroutes.filesMoveBatchV2 = function (arg) {\n  return this.request('files/move_batch_v2', arg, 'user', 'api', 'rpc');\n};\n/**\n * Move multiple files or folders to different locations at once in the user's\n * Dropbox. This route will return job ID immediately and do the async moving\n * job in background. Please use move_batch/check to check the job status.\n * @function Dropbox#filesMoveBatch\n * @deprecated\n * @arg {FilesRelocationBatchArg} arg - The request parameters.\n * @returns {Promise.<DropboxResponse<FilesRelocationBatchLaunch>, Error.<void>>}\n */\n\n\nroutes.filesMoveBatch = function (arg) {\n  return this.request('files/move_batch', arg, 'user', 'api', 'rpc');\n};\n/**\n * Returns the status of an asynchronous job for move_batch_v2. It returns list\n * of results for each entry.\n * @function Dropbox#filesMoveBatchCheckV2\n * @arg {AsyncPollArg} arg - The request parameters.\n * @returns {Promise.<DropboxResponse<FilesRelocationBatchV2JobStatus>, Error.<AsyncPollError>>}\n */\n\n\nroutes.filesMoveBatchCheckV2 = function (arg) {\n  return this.request('files/move_batch/check_v2', arg, 'user', 'api', 'rpc');\n};\n/**\n * Returns the status of an asynchronous job for move_batch. If success, it\n * returns list of results for each entry.\n * @function Dropbox#filesMoveBatchCheck\n * @deprecated\n * @arg {AsyncPollArg} arg - The request parameters.\n * @returns {Promise.<DropboxResponse<FilesRelocationBatchJobStatus>, Error.<AsyncPollError>>}\n */\n\n\nroutes.filesMoveBatchCheck = function (arg) {\n  return this.request('files/move_batch/check', arg, 'user', 'api', 'rpc');\n};\n/**\n * Permanently delete the file or folder at a given path (see\n * https://www.dropbox.com/en/help/40). If the given file or folder is not yet\n * deleted, this route will first delete it. It is possible for this route to\n * successfully delete, then fail to permanently delete. Note: This endpoint is\n * only available for Dropbox Business apps.\n * @function Dropbox#filesPermanentlyDelete\n * @arg {FilesDeleteArg} arg - The request parameters.\n * @returns {Promise.<DropboxResponse<void>, Error.<FilesDeleteError>>}\n */\n\n\nroutes.filesPermanentlyDelete = function (arg) {\n  return this.request('files/permanently_delete', arg, 'user', 'api', 'rpc');\n};\n/**\n * @function Dropbox#filesPropertiesAdd\n * @deprecated\n * @arg {FilePropertiesAddPropertiesArg} arg - The request parameters.\n * @returns {Promise.<DropboxResponse<void>, Error.<FilePropertiesAddPropertiesError>>}\n */\n\n\nroutes.filesPropertiesAdd = function (arg) {\n  return this.request('files/properties/add', arg, 'user', 'api', 'rpc');\n};\n/**\n * @function Dropbox#filesPropertiesOverwrite\n * @deprecated\n * @arg {FilePropertiesOverwritePropertyGroupArg} arg - The request parameters.\n * @returns {Promise.<DropboxResponse<void>, Error.<FilePropertiesInvalidPropertyGroupError>>}\n */\n\n\nroutes.filesPropertiesOverwrite = function (arg) {\n  return this.request('files/properties/overwrite', arg, 'user', 'api', 'rpc');\n};\n/**\n * @function Dropbox#filesPropertiesRemove\n * @deprecated\n * @arg {FilePropertiesRemovePropertiesArg} arg - The request parameters.\n * @returns {Promise.<DropboxResponse<void>, Error.<FilePropertiesRemovePropertiesError>>}\n */\n\n\nroutes.filesPropertiesRemove = function (arg) {\n  return this.request('files/properties/remove', arg, 'user', 'api', 'rpc');\n};\n/**\n * @function Dropbox#filesPropertiesTemplateGet\n * @deprecated\n * @arg {FilePropertiesGetTemplateArg} arg - The request parameters.\n * @returns {Promise.<DropboxResponse<FilePropertiesGetTemplateResult>, Error.<FilePropertiesTemplateError>>}\n */\n\n\nroutes.filesPropertiesTemplateGet = function (arg) {\n  return this.request('files/properties/template/get', arg, 'user', 'api', 'rpc');\n};\n/**\n * @function Dropbox#filesPropertiesTemplateList\n * @deprecated\n * @returns {Promise.<DropboxResponse<FilePropertiesListTemplateResult>, Error.<FilePropertiesTemplateError>>}\n */\n\n\nroutes.filesPropertiesTemplateList = function () {\n  return this.request('files/properties/template/list', null, 'user', 'api', 'rpc');\n};\n/**\n * @function Dropbox#filesPropertiesUpdate\n * @deprecated\n * @arg {FilePropertiesUpdatePropertiesArg} arg - The request parameters.\n * @returns {Promise.<DropboxResponse<void>, Error.<FilePropertiesUpdatePropertiesError>>}\n */\n\n\nroutes.filesPropertiesUpdate = function (arg) {\n  return this.request('files/properties/update', arg, 'user', 'api', 'rpc');\n};\n/**\n * Restore a specific revision of a file to the given path.\n * @function Dropbox#filesRestore\n * @arg {FilesRestoreArg} arg - The request parameters.\n * @returns {Promise.<DropboxResponse<FilesFileMetadata>, Error.<FilesRestoreError>>}\n */\n\n\nroutes.filesRestore = function (arg) {\n  return this.request('files/restore', arg, 'user', 'api', 'rpc');\n};\n/**\n * Save the data from a specified URL into a file in user's Dropbox. Note that\n * the transfer from the URL must complete within 5 minutes, or the operation\n * will time out and the job will fail. If the given path already exists, the\n * file will be renamed to avoid the conflict (e.g. myfile (1).txt).\n * @function Dropbox#filesSaveUrl\n * @arg {FilesSaveUrlArg} arg - The request parameters.\n * @returns {Promise.<DropboxResponse<FilesSaveUrlResult>, Error.<FilesSaveUrlError>>}\n */\n\n\nroutes.filesSaveUrl = function (arg) {\n  return this.request('files/save_url', arg, 'user', 'api', 'rpc');\n};\n/**\n * Check the status of a save_url job.\n * @function Dropbox#filesSaveUrlCheckJobStatus\n * @arg {AsyncPollArg} arg - The request parameters.\n * @returns {Promise.<DropboxResponse<FilesSaveUrlJobStatus>, Error.<AsyncPollError>>}\n */\n\n\nroutes.filesSaveUrlCheckJobStatus = function (arg) {\n  return this.request('files/save_url/check_job_status', arg, 'user', 'api', 'rpc');\n};\n/**\n * Searches for files and folders. Note: Recent changes will be reflected in\n * search results within a few seconds and older revisions of existing files may\n * still match your query for up to a few days.\n * @function Dropbox#filesSearch\n * @deprecated\n * @arg {FilesSearchArg} arg - The request parameters.\n * @returns {Promise.<DropboxResponse<FilesSearchResult>, Error.<FilesSearchError>>}\n */\n\n\nroutes.filesSearch = function (arg) {\n  return this.request('files/search', arg, 'user', 'api', 'rpc');\n};\n/**\n * Searches for files and folders. Note: search_v2 along with search/continue_v2\n * can only be used to retrieve a maximum of 10,000 matches. Recent changes may\n * not immediately be reflected in search results due to a short delay in\n * indexing. Duplicate results may be returned across pages. Some results may\n * not be returned.\n * @function Dropbox#filesSearchV2\n * @arg {FilesSearchV2Arg} arg - The request parameters.\n * @returns {Promise.<DropboxResponse<FilesSearchV2Result>, Error.<FilesSearchError>>}\n */\n\n\nroutes.filesSearchV2 = function (arg) {\n  return this.request('files/search_v2', arg, 'user', 'api', 'rpc');\n};\n/**\n * Fetches the next page of search results returned from search_v2. Note:\n * search_v2 along with search/continue_v2 can only be used to retrieve a\n * maximum of 10,000 matches. Recent changes may not immediately be reflected in\n * search results due to a short delay in indexing. Duplicate results may be\n * returned across pages. Some results may not be returned.\n * @function Dropbox#filesSearchContinueV2\n * @arg {FilesSearchV2ContinueArg} arg - The request parameters.\n * @returns {Promise.<DropboxResponse<FilesSearchV2Result>, Error.<FilesSearchError>>}\n */\n\n\nroutes.filesSearchContinueV2 = function (arg) {\n  return this.request('files/search/continue_v2', arg, 'user', 'api', 'rpc');\n};\n/**\n * Unlock the files at the given paths. A locked file can only be unlocked by\n * the lock holder or, if a business account, a team admin. A successful\n * response indicates that the file has been unlocked. Returns a list of the\n * unlocked file paths and their metadata after this operation.\n * @function Dropbox#filesUnlockFileBatch\n * @arg {FilesUnlockFileBatchArg} arg - The request parameters.\n * @returns {Promise.<DropboxResponse<FilesLockFileBatchResult>, Error.<FilesLockFileError>>}\n */\n\n\nroutes.filesUnlockFileBatch = function (arg) {\n  return this.request('files/unlock_file_batch', arg, 'user', 'api', 'rpc');\n};\n/**\n * Create a new file with the contents provided in the request. Do not use this\n * to upload a file larger than 150 MB. Instead, create an upload session with\n * upload_session/start. Calls to this endpoint will count as data transport\n * calls for any Dropbox Business teams with a limit on the number of data\n * transport calls allowed per month. For more information, see the Data\n * transport limit page\n * https://www.dropbox.com/developers/reference/data-transport-limit.\n * @function Dropbox#filesUpload\n * @arg {FilesCommitInfo} arg - The request parameters.\n * @returns {Promise.<DropboxResponse<FilesFileMetadata>, Error.<FilesUploadError>>}\n */\n\n\nroutes.filesUpload = function (arg) {\n  return this.request('files/upload', arg, 'user', 'content', 'upload');\n};\n/**\n * Append more data to an upload session. When the parameter close is set, this\n * call will close the session. A single request should not upload more than 150\n * MB. The maximum size of a file one can upload to an upload session is 350 GB.\n * Calls to this endpoint will count as data transport calls for any Dropbox\n * Business teams with a limit on the number of data transport calls allowed per\n * month. For more information, see the Data transport limit page\n * https://www.dropbox.com/developers/reference/data-transport-limit.\n * @function Dropbox#filesUploadSessionAppendV2\n * @arg {FilesUploadSessionAppendArg} arg - The request parameters.\n * @returns {Promise.<DropboxResponse<void>, Error.<FilesUploadSessionLookupError>>}\n */\n\n\nroutes.filesUploadSessionAppendV2 = function (arg) {\n  return this.request('files/upload_session/append_v2', arg, 'user', 'content', 'upload');\n};\n/**\n * Append more data to an upload session. A single request should not upload\n * more than 150 MB. The maximum size of a file one can upload to an upload\n * session is 350 GB. Calls to this endpoint will count as data transport calls\n * for any Dropbox Business teams with a limit on the number of data transport\n * calls allowed per month. For more information, see the Data transport limit\n * page https://www.dropbox.com/developers/reference/data-transport-limit.\n * @function Dropbox#filesUploadSessionAppend\n * @deprecated\n * @arg {FilesUploadSessionCursor} arg - The request parameters.\n * @returns {Promise.<DropboxResponse<void>, Error.<FilesUploadSessionLookupError>>}\n */\n\n\nroutes.filesUploadSessionAppend = function (arg) {\n  return this.request('files/upload_session/append', arg, 'user', 'content', 'upload');\n};\n/**\n * Finish an upload session and save the uploaded data to the given file path. A\n * single request should not upload more than 150 MB. The maximum size of a file\n * one can upload to an upload session is 350 GB. Calls to this endpoint will\n * count as data transport calls for any Dropbox Business teams with a limit on\n * the number of data transport calls allowed per month. For more information,\n * see the Data transport limit page\n * https://www.dropbox.com/developers/reference/data-transport-limit.\n * @function Dropbox#filesUploadSessionFinish\n * @arg {FilesUploadSessionFinishArg} arg - The request parameters.\n * @returns {Promise.<DropboxResponse<FilesFileMetadata>, Error.<FilesUploadSessionFinishError>>}\n */\n\n\nroutes.filesUploadSessionFinish = function (arg) {\n  return this.request('files/upload_session/finish', arg, 'user', 'content', 'upload');\n};\n/**\n * This route helps you commit many files at once into a user's Dropbox. Use\n * upload_session/start and upload_session/append_v2 to upload file contents. We\n * recommend uploading many files in parallel to increase throughput. Once the\n * file contents have been uploaded, rather than calling upload_session/finish,\n * use this route to finish all your upload sessions in a single request.\n * UploadSessionStartArg.close or UploadSessionAppendArg.close needs to be true\n * for the last upload_session/start or upload_session/append_v2 call. The\n * maximum size of a file one can upload to an upload session is 350 GB. This\n * route will return a job_id immediately and do the async commit job in\n * background. Use upload_session/finish_batch/check to check the job status.\n * For the same account, this route should be executed serially. That means you\n * should not start the next job before current job finishes. We allow up to\n * 1000 entries in a single request. Calls to this endpoint will count as data\n * transport calls for any Dropbox Business teams with a limit on the number of\n * data transport calls allowed per month. For more information, see the Data\n * transport limit page\n * https://www.dropbox.com/developers/reference/data-transport-limit.\n * @function Dropbox#filesUploadSessionFinishBatch\n * @arg {FilesUploadSessionFinishBatchArg} arg - The request parameters.\n * @returns {Promise.<DropboxResponse<FilesUploadSessionFinishBatchLaunch>, Error.<void>>}\n */\n\n\nroutes.filesUploadSessionFinishBatch = function (arg) {\n  return this.request('files/upload_session/finish_batch', arg, 'user', 'api', 'rpc');\n};\n/**\n * Returns the status of an asynchronous job for upload_session/finish_batch. If\n * success, it returns list of result for each entry.\n * @function Dropbox#filesUploadSessionFinishBatchCheck\n * @arg {AsyncPollArg} arg - The request parameters.\n * @returns {Promise.<DropboxResponse<FilesUploadSessionFinishBatchJobStatus>, Error.<AsyncPollError>>}\n */\n\n\nroutes.filesUploadSessionFinishBatchCheck = function (arg) {\n  return this.request('files/upload_session/finish_batch/check', arg, 'user', 'api', 'rpc');\n};\n/**\n * Upload sessions allow you to upload a single file in one or more requests,\n * for example where the size of the file is greater than 150 MB.  This call\n * starts a new upload session with the given data. You can then use\n * upload_session/append_v2 to add more data and upload_session/finish to save\n * all the data to a file in Dropbox. A single request should not upload more\n * than 150 MB. The maximum size of a file one can upload to an upload session\n * is 350 GB. An upload session can be used for a maximum of 48 hours.\n * Attempting to use an UploadSessionStartResult.session_id with\n * upload_session/append_v2 or upload_session/finish more than 48 hours after\n * its creation will return a UploadSessionLookupError.not_found. Calls to this\n * endpoint will count as data transport calls for any Dropbox Business teams\n * with a limit on the number of data transport calls allowed per month. For\n * more information, see the Data transport limit page\n * https://www.dropbox.com/developers/reference/data-transport-limit. By\n * default, upload sessions require you to send content of the file in\n * sequential order via consecutive upload_session/start,\n * upload_session/append_v2, upload_session/finish calls. For better\n * performance, you can instead optionally use a UploadSessionType.concurrent\n * upload session. To start a new concurrent session, set\n * UploadSessionStartArg.session_type to UploadSessionType.concurrent. After\n * that, you can send file data in concurrent upload_session/append_v2 requests.\n * Finally finish the session with upload_session/finish. There are couple of\n * constraints with concurrent sessions to make them work. You can not send data\n * with upload_session/start or upload_session/finish call, only with\n * upload_session/append_v2 call. Also data uploaded in upload_session/append_v2\n * call must be multiple of 4194304 bytes (except for last\n * upload_session/append_v2 with UploadSessionStartArg.close to true, that may\n * contain any remaining data).\n * @function Dropbox#filesUploadSessionStart\n * @arg {FilesUploadSessionStartArg} arg - The request parameters.\n * @returns {Promise.<DropboxResponse<FilesUploadSessionStartResult>, Error.<FilesUploadSessionStartError>>}\n */\n\n\nroutes.filesUploadSessionStart = function (arg) {\n  return this.request('files/upload_session/start', arg, 'user', 'content', 'upload');\n};\n/**\n * Marks the given Paper doc as archived. This action can be performed or undone\n * by anyone with edit permissions to the doc. Note that this endpoint will\n * continue to work for content created by users on the older version of Paper.\n * To check which version of Paper a user is on, use /users/features/get_values.\n * If the paper_as_files feature is enabled, then the user is running the new\n * version of Paper. This endpoint will be retired in September 2020. Refer to\n * the Paper Migration Guide\n * https://www.dropbox.com/lp/developers/reference/paper-migration-guide for\n * more information.\n * @function Dropbox#paperDocsArchive\n * @deprecated\n * @arg {PaperRefPaperDoc} arg - The request parameters.\n * @returns {Promise.<DropboxResponse<void>, Error.<PaperDocLookupError>>}\n */\n\n\nroutes.paperDocsArchive = function (arg) {\n  return this.request('paper/docs/archive', arg, 'user', 'api', 'rpc');\n};\n/**\n * Creates a new Paper doc with the provided content. Note that this endpoint\n * will continue to work for content created by users on the older version of\n * Paper. To check which version of Paper a user is on, use\n * /users/features/get_values. If the paper_as_files feature is enabled, then\n * the user is running the new version of Paper. This endpoint will be retired\n * in September 2020. Refer to the Paper Migration Guide\n * https://www.dropbox.com/lp/developers/reference/paper-migration-guide for\n * more information.\n * @function Dropbox#paperDocsCreate\n * @deprecated\n * @arg {PaperPaperDocCreateArgs} arg - The request parameters.\n * @returns {Promise.<DropboxResponse<PaperPaperDocCreateUpdateResult>, Error.<PaperPaperDocCreateError>>}\n */\n\n\nroutes.paperDocsCreate = function (arg) {\n  return this.request('paper/docs/create', arg, 'user', 'api', 'upload');\n};\n/**\n * Exports and downloads Paper doc either as HTML or markdown. Note that this\n * endpoint will continue to work for content created by users on the older\n * version of Paper. To check which version of Paper a user is on, use\n * /users/features/get_values. If the paper_as_files feature is enabled, then\n * the user is running the new version of Paper. Refer to the Paper Migration\n * Guide https://www.dropbox.com/lp/developers/reference/paper-migration-guide\n * for migration information.\n * @function Dropbox#paperDocsDownload\n * @deprecated\n * @arg {PaperPaperDocExport} arg - The request parameters.\n * @returns {Promise.<DropboxResponse<PaperPaperDocExportResult>, Error.<PaperDocLookupError>>}\n */\n\n\nroutes.paperDocsDownload = function (arg) {\n  return this.request('paper/docs/download', arg, 'user', 'api', 'download');\n};\n/**\n * Lists the users who are explicitly invited to the Paper folder in which the\n * Paper doc is contained. For private folders all users (including owner)\n * shared on the folder are listed and for team folders all non-team users\n * shared on the folder are returned. Note that this endpoint will continue to\n * work for content created by users on the older version of Paper. To check\n * which version of Paper a user is on, use /users/features/get_values. If the\n * paper_as_files feature is enabled, then the user is running the new version\n * of Paper. Refer to the Paper Migration Guide\n * https://www.dropbox.com/lp/developers/reference/paper-migration-guide for\n * migration information.\n * @function Dropbox#paperDocsFolderUsersList\n * @deprecated\n * @arg {PaperListUsersOnFolderArgs} arg - The request parameters.\n * @returns {Promise.<DropboxResponse<PaperListUsersOnFolderResponse>, Error.<PaperDocLookupError>>}\n */\n\n\nroutes.paperDocsFolderUsersList = function (arg) {\n  return this.request('paper/docs/folder_users/list', arg, 'user', 'api', 'rpc');\n};\n/**\n * Once a cursor has been retrieved from docs/folder_users/list, use this to\n * paginate through all users on the Paper folder. Note that this endpoint will\n * continue to work for content created by users on the older version of Paper.\n * To check which version of Paper a user is on, use /users/features/get_values.\n * If the paper_as_files feature is enabled, then the user is running the new\n * version of Paper. Refer to the Paper Migration Guide\n * https://www.dropbox.com/lp/developers/reference/paper-migration-guide for\n * migration information.\n * @function Dropbox#paperDocsFolderUsersListContinue\n * @deprecated\n * @arg {PaperListUsersOnFolderContinueArgs} arg - The request parameters.\n * @returns {Promise.<DropboxResponse<PaperListUsersOnFolderResponse>, Error.<PaperListUsersCursorError>>}\n */\n\n\nroutes.paperDocsFolderUsersListContinue = function (arg) {\n  return this.request('paper/docs/folder_users/list/continue', arg, 'user', 'api', 'rpc');\n};\n/**\n * Retrieves folder information for the given Paper doc. This includes:   -\n * folder sharing policy; permissions for subfolders are set by the top-level\n * folder.   - full 'filepath', i.e. the list of folders (both folderId and\n * folderName) from     the root folder to the folder directly containing the\n * Paper doc.  If the Paper doc is not in any folder (aka unfiled) the response\n * will be empty. Note that this endpoint will continue to work for content\n * created by users on the older version of Paper. To check which version of\n * Paper a user is on, use /users/features/get_values. If the paper_as_files\n * feature is enabled, then the user is running the new version of Paper. Refer\n * to the Paper Migration Guide\n * https://www.dropbox.com/lp/developers/reference/paper-migration-guide for\n * migration information.\n * @function Dropbox#paperDocsGetFolderInfo\n * @deprecated\n * @arg {PaperRefPaperDoc} arg - The request parameters.\n * @returns {Promise.<DropboxResponse<PaperFoldersContainingPaperDoc>, Error.<PaperDocLookupError>>}\n */\n\n\nroutes.paperDocsGetFolderInfo = function (arg) {\n  return this.request('paper/docs/get_folder_info', arg, 'user', 'api', 'rpc');\n};\n/**\n * Return the list of all Paper docs according to the argument specifications.\n * To iterate over through the full pagination, pass the cursor to\n * docs/list/continue. Note that this endpoint will continue to work for content\n * created by users on the older version of Paper. To check which version of\n * Paper a user is on, use /users/features/get_values. If the paper_as_files\n * feature is enabled, then the user is running the new version of Paper. Refer\n * to the Paper Migration Guide\n * https://www.dropbox.com/lp/developers/reference/paper-migration-guide for\n * migration information.\n * @function Dropbox#paperDocsList\n * @deprecated\n * @arg {PaperListPaperDocsArgs} arg - The request parameters.\n * @returns {Promise.<DropboxResponse<PaperListPaperDocsResponse>, Error.<void>>}\n */\n\n\nroutes.paperDocsList = function (arg) {\n  return this.request('paper/docs/list', arg, 'user', 'api', 'rpc');\n};\n/**\n * Once a cursor has been retrieved from docs/list, use this to paginate through\n * all Paper doc. Note that this endpoint will continue to work for content\n * created by users on the older version of Paper. To check which version of\n * Paper a user is on, use /users/features/get_values. If the paper_as_files\n * feature is enabled, then the user is running the new version of Paper. Refer\n * to the Paper Migration Guide\n * https://www.dropbox.com/lp/developers/reference/paper-migration-guide for\n * migration information.\n * @function Dropbox#paperDocsListContinue\n * @deprecated\n * @arg {PaperListPaperDocsContinueArgs} arg - The request parameters.\n * @returns {Promise.<DropboxResponse<PaperListPaperDocsResponse>, Error.<PaperListDocsCursorError>>}\n */\n\n\nroutes.paperDocsListContinue = function (arg) {\n  return this.request('paper/docs/list/continue', arg, 'user', 'api', 'rpc');\n};\n/**\n * Permanently deletes the given Paper doc. This operation is final as the doc\n * cannot be recovered. This action can be performed only by the doc owner. Note\n * that this endpoint will continue to work for content created by users on the\n * older version of Paper. To check which version of Paper a user is on, use\n * /users/features/get_values. If the paper_as_files feature is enabled, then\n * the user is running the new version of Paper. Refer to the Paper Migration\n * Guide https://www.dropbox.com/lp/developers/reference/paper-migration-guide\n * for migration information.\n * @function Dropbox#paperDocsPermanentlyDelete\n * @deprecated\n * @arg {PaperRefPaperDoc} arg - The request parameters.\n * @returns {Promise.<DropboxResponse<void>, Error.<PaperDocLookupError>>}\n */\n\n\nroutes.paperDocsPermanentlyDelete = function (arg) {\n  return this.request('paper/docs/permanently_delete', arg, 'user', 'api', 'rpc');\n};\n/**\n * Gets the default sharing policy for the given Paper doc. Note that this\n * endpoint will continue to work for content created by users on the older\n * version of Paper. To check which version of Paper a user is on, use\n * /users/features/get_values. If the paper_as_files feature is enabled, then\n * the user is running the new version of Paper. Refer to the Paper Migration\n * Guide https://www.dropbox.com/lp/developers/reference/paper-migration-guide\n * for migration information.\n * @function Dropbox#paperDocsSharingPolicyGet\n * @deprecated\n * @arg {PaperRefPaperDoc} arg - The request parameters.\n * @returns {Promise.<DropboxResponse<PaperSharingPolicy>, Error.<PaperDocLookupError>>}\n */\n\n\nroutes.paperDocsSharingPolicyGet = function (arg) {\n  return this.request('paper/docs/sharing_policy/get', arg, 'user', 'api', 'rpc');\n};\n/**\n * Sets the default sharing policy for the given Paper doc. The default\n * 'team_sharing_policy' can be changed only by teams, omit this field for\n * personal accounts. The 'public_sharing_policy' policy can't be set to the\n * value 'disabled' because this setting can be changed only via the team admin\n * console. Note that this endpoint will continue to work for content created by\n * users on the older version of Paper. To check which version of Paper a user\n * is on, use /users/features/get_values. If the paper_as_files feature is\n * enabled, then the user is running the new version of Paper. Refer to the\n * Paper Migration Guide\n * https://www.dropbox.com/lp/developers/reference/paper-migration-guide for\n * migration information.\n * @function Dropbox#paperDocsSharingPolicySet\n * @deprecated\n * @arg {PaperPaperDocSharingPolicy} arg - The request parameters.\n * @returns {Promise.<DropboxResponse<void>, Error.<PaperDocLookupError>>}\n */\n\n\nroutes.paperDocsSharingPolicySet = function (arg) {\n  return this.request('paper/docs/sharing_policy/set', arg, 'user', 'api', 'rpc');\n};\n/**\n * Updates an existing Paper doc with the provided content. Note that this\n * endpoint will continue to work for content created by users on the older\n * version of Paper. To check which version of Paper a user is on, use\n * /users/features/get_values. If the paper_as_files feature is enabled, then\n * the user is running the new version of Paper. This endpoint will be retired\n * in September 2020. Refer to the Paper Migration Guide\n * https://www.dropbox.com/lp/developers/reference/paper-migration-guide for\n * more information.\n * @function Dropbox#paperDocsUpdate\n * @deprecated\n * @arg {PaperPaperDocUpdateArgs} arg - The request parameters.\n * @returns {Promise.<DropboxResponse<PaperPaperDocCreateUpdateResult>, Error.<PaperPaperDocUpdateError>>}\n */\n\n\nroutes.paperDocsUpdate = function (arg) {\n  return this.request('paper/docs/update', arg, 'user', 'api', 'upload');\n};\n/**\n * Allows an owner or editor to add users to a Paper doc or change their\n * permissions using their email address or Dropbox account ID. The doc owner's\n * permissions cannot be changed. Note that this endpoint will continue to work\n * for content created by users on the older version of Paper. To check which\n * version of Paper a user is on, use /users/features/get_values. If the\n * paper_as_files feature is enabled, then the user is running the new version\n * of Paper. Refer to the Paper Migration Guide\n * https://www.dropbox.com/lp/developers/reference/paper-migration-guide for\n * migration information.\n * @function Dropbox#paperDocsUsersAdd\n * @deprecated\n * @arg {PaperAddPaperDocUser} arg - The request parameters.\n * @returns {Promise.<DropboxResponse<Array.<PaperAddPaperDocUserMemberResult>>, Error.<PaperDocLookupError>>}\n */\n\n\nroutes.paperDocsUsersAdd = function (arg) {\n  return this.request('paper/docs/users/add', arg, 'user', 'api', 'rpc');\n};\n/**\n * Lists all users who visited the Paper doc or users with explicit access. This\n * call excludes users who have been removed. The list is sorted by the date of\n * the visit or the share date. The list will include both users, the explicitly\n * shared ones as well as those who came in using the Paper url link. Note that\n * this endpoint will continue to work for content created by users on the older\n * version of Paper. To check which version of Paper a user is on, use\n * /users/features/get_values. If the paper_as_files feature is enabled, then\n * the user is running the new version of Paper. Refer to the Paper Migration\n * Guide https://www.dropbox.com/lp/developers/reference/paper-migration-guide\n * for migration information.\n * @function Dropbox#paperDocsUsersList\n * @deprecated\n * @arg {PaperListUsersOnPaperDocArgs} arg - The request parameters.\n * @returns {Promise.<DropboxResponse<PaperListUsersOnPaperDocResponse>, Error.<PaperDocLookupError>>}\n */\n\n\nroutes.paperDocsUsersList = function (arg) {\n  return this.request('paper/docs/users/list', arg, 'user', 'api', 'rpc');\n};\n/**\n * Once a cursor has been retrieved from docs/users/list, use this to paginate\n * through all users on the Paper doc. Note that this endpoint will continue to\n * work for content created by users on the older version of Paper. To check\n * which version of Paper a user is on, use /users/features/get_values. If the\n * paper_as_files feature is enabled, then the user is running the new version\n * of Paper. Refer to the Paper Migration Guide\n * https://www.dropbox.com/lp/developers/reference/paper-migration-guide for\n * migration information.\n * @function Dropbox#paperDocsUsersListContinue\n * @deprecated\n * @arg {PaperListUsersOnPaperDocContinueArgs} arg - The request parameters.\n * @returns {Promise.<DropboxResponse<PaperListUsersOnPaperDocResponse>, Error.<PaperListUsersCursorError>>}\n */\n\n\nroutes.paperDocsUsersListContinue = function (arg) {\n  return this.request('paper/docs/users/list/continue', arg, 'user', 'api', 'rpc');\n};\n/**\n * Allows an owner or editor to remove users from a Paper doc using their email\n * address or Dropbox account ID. The doc owner cannot be removed. Note that\n * this endpoint will continue to work for content created by users on the older\n * version of Paper. To check which version of Paper a user is on, use\n * /users/features/get_values. If the paper_as_files feature is enabled, then\n * the user is running the new version of Paper. Refer to the Paper Migration\n * Guide https://www.dropbox.com/lp/developers/reference/paper-migration-guide\n * for migration information.\n * @function Dropbox#paperDocsUsersRemove\n * @deprecated\n * @arg {PaperRemovePaperDocUser} arg - The request parameters.\n * @returns {Promise.<DropboxResponse<void>, Error.<PaperDocLookupError>>}\n */\n\n\nroutes.paperDocsUsersRemove = function (arg) {\n  return this.request('paper/docs/users/remove', arg, 'user', 'api', 'rpc');\n};\n/**\n * Create a new Paper folder with the provided info. Note that this endpoint\n * will continue to work for content created by users on the older version of\n * Paper. To check which version of Paper a user is on, use\n * /users/features/get_values. If the paper_as_files feature is enabled, then\n * the user is running the new version of Paper. Refer to the Paper Migration\n * Guide https://www.dropbox.com/lp/developers/reference/paper-migration-guide\n * for migration information.\n * @function Dropbox#paperFoldersCreate\n * @deprecated\n * @arg {PaperPaperFolderCreateArg} arg - The request parameters.\n * @returns {Promise.<DropboxResponse<PaperPaperFolderCreateResult>, Error.<PaperPaperFolderCreateError>>}\n */\n\n\nroutes.paperFoldersCreate = function (arg) {\n  return this.request('paper/folders/create', arg, 'user', 'api', 'rpc');\n};\n/**\n * Adds specified members to a file.\n * @function Dropbox#sharingAddFileMember\n * @arg {SharingAddFileMemberArgs} arg - The request parameters.\n * @returns {Promise.<DropboxResponse<Array.<SharingFileMemberActionResult>>, Error.<SharingAddFileMemberError>>}\n */\n\n\nroutes.sharingAddFileMember = function (arg) {\n  return this.request('sharing/add_file_member', arg, 'user', 'api', 'rpc');\n};\n/**\n * Allows an owner or editor (if the ACL update policy allows) of a shared\n * folder to add another member. For the new member to get access to all the\n * functionality for this folder, you will need to call mount_folder on their\n * behalf.\n * @function Dropbox#sharingAddFolderMember\n * @arg {SharingAddFolderMemberArg} arg - The request parameters.\n * @returns {Promise.<DropboxResponse<void>, Error.<SharingAddFolderMemberError>>}\n */\n\n\nroutes.sharingAddFolderMember = function (arg) {\n  return this.request('sharing/add_folder_member', arg, 'user', 'api', 'rpc');\n};\n/**\n * Identical to update_file_member but with less information returned.\n * @function Dropbox#sharingChangeFileMemberAccess\n * @deprecated\n * @arg {SharingChangeFileMemberAccessArgs} arg - The request parameters.\n * @returns {Promise.<DropboxResponse<SharingFileMemberActionResult>, Error.<SharingFileMemberActionError>>}\n */\n\n\nroutes.sharingChangeFileMemberAccess = function (arg) {\n  return this.request('sharing/change_file_member_access', arg, 'user', 'api', 'rpc');\n};\n/**\n * Returns the status of an asynchronous job.\n * @function Dropbox#sharingCheckJobStatus\n * @arg {AsyncPollArg} arg - The request parameters.\n * @returns {Promise.<DropboxResponse<SharingJobStatus>, Error.<AsyncPollError>>}\n */\n\n\nroutes.sharingCheckJobStatus = function (arg) {\n  return this.request('sharing/check_job_status', arg, 'user', 'api', 'rpc');\n};\n/**\n * Returns the status of an asynchronous job for sharing a folder.\n * @function Dropbox#sharingCheckRemoveMemberJobStatus\n * @arg {AsyncPollArg} arg - The request parameters.\n * @returns {Promise.<DropboxResponse<SharingRemoveMemberJobStatus>, Error.<AsyncPollError>>}\n */\n\n\nroutes.sharingCheckRemoveMemberJobStatus = function (arg) {\n  return this.request('sharing/check_remove_member_job_status', arg, 'user', 'api', 'rpc');\n};\n/**\n * Returns the status of an asynchronous job for sharing a folder.\n * @function Dropbox#sharingCheckShareJobStatus\n * @arg {AsyncPollArg} arg - The request parameters.\n * @returns {Promise.<DropboxResponse<SharingShareFolderJobStatus>, Error.<AsyncPollError>>}\n */\n\n\nroutes.sharingCheckShareJobStatus = function (arg) {\n  return this.request('sharing/check_share_job_status', arg, 'user', 'api', 'rpc');\n};\n/**\n * Create a shared link. If a shared link already exists for the given path,\n * that link is returned. Note that in the returned PathLinkMetadata, the\n * PathLinkMetadata.url field is the shortened URL if\n * CreateSharedLinkArg.short_url argument is set to true. Previously, it was\n * technically possible to break a shared link by moving or renaming the\n * corresponding file or folder. In the future, this will no longer be the case,\n * so your app shouldn't rely on this behavior. Instead, if your app needs to\n * revoke a shared link, use revoke_shared_link.\n * @function Dropbox#sharingCreateSharedLink\n * @deprecated\n * @arg {SharingCreateSharedLinkArg} arg - The request parameters.\n * @returns {Promise.<DropboxResponse<SharingPathLinkMetadata>, Error.<SharingCreateSharedLinkError>>}\n */\n\n\nroutes.sharingCreateSharedLink = function (arg) {\n  return this.request('sharing/create_shared_link', arg, 'user', 'api', 'rpc');\n};\n/**\n * Create a shared link with custom settings. If no settings are given then the\n * default visibility is RequestedVisibility.public (The resolved visibility,\n * though, may depend on other aspects such as team and shared folder settings).\n * @function Dropbox#sharingCreateSharedLinkWithSettings\n * @arg {SharingCreateSharedLinkWithSettingsArg} arg - The request parameters.\n * @returns {Promise.<DropboxResponse<(SharingFileLinkMetadata|SharingFolderLinkMetadata|SharingSharedLinkMetadata)>, Error.<SharingCreateSharedLinkWithSettingsError>>}\n */\n\n\nroutes.sharingCreateSharedLinkWithSettings = function (arg) {\n  return this.request('sharing/create_shared_link_with_settings', arg, 'user', 'api', 'rpc');\n};\n/**\n * Returns shared file metadata.\n * @function Dropbox#sharingGetFileMetadata\n * @arg {SharingGetFileMetadataArg} arg - The request parameters.\n * @returns {Promise.<DropboxResponse<SharingSharedFileMetadata>, Error.<SharingGetFileMetadataError>>}\n */\n\n\nroutes.sharingGetFileMetadata = function (arg) {\n  return this.request('sharing/get_file_metadata', arg, 'user', 'api', 'rpc');\n};\n/**\n * Returns shared file metadata.\n * @function Dropbox#sharingGetFileMetadataBatch\n * @arg {SharingGetFileMetadataBatchArg} arg - The request parameters.\n * @returns {Promise.<DropboxResponse<Array.<SharingGetFileMetadataBatchResult>>, Error.<SharingSharingUserError>>}\n */\n\n\nroutes.sharingGetFileMetadataBatch = function (arg) {\n  return this.request('sharing/get_file_metadata/batch', arg, 'user', 'api', 'rpc');\n};\n/**\n * Returns shared folder metadata by its folder ID.\n * @function Dropbox#sharingGetFolderMetadata\n * @arg {SharingGetMetadataArgs} arg - The request parameters.\n * @returns {Promise.<DropboxResponse<SharingSharedFolderMetadata>, Error.<SharingSharedFolderAccessError>>}\n */\n\n\nroutes.sharingGetFolderMetadata = function (arg) {\n  return this.request('sharing/get_folder_metadata', arg, 'user', 'api', 'rpc');\n};\n/**\n * Download the shared link's file from a user's Dropbox.\n * @function Dropbox#sharingGetSharedLinkFile\n * @arg {Object} arg - The request parameters.\n * @returns {Promise.<DropboxResponse<(SharingFileLinkMetadata|SharingFolderLinkMetadata|SharingSharedLinkMetadata)>, Error.<SharingGetSharedLinkFileError>>}\n */\n\n\nroutes.sharingGetSharedLinkFile = function (arg) {\n  return this.request('sharing/get_shared_link_file', arg, 'user', 'content', 'download');\n};\n/**\n * Get the shared link's metadata.\n * @function Dropbox#sharingGetSharedLinkMetadata\n * @arg {SharingGetSharedLinkMetadataArg} arg - The request parameters.\n * @returns {Promise.<DropboxResponse<(SharingFileLinkMetadata|SharingFolderLinkMetadata|SharingSharedLinkMetadata)>, Error.<SharingSharedLinkError>>}\n */\n\n\nroutes.sharingGetSharedLinkMetadata = function (arg) {\n  return this.request('sharing/get_shared_link_metadata', arg, 'user', 'api', 'rpc');\n};\n/**\n * Returns a list of LinkMetadata objects for this user, including collection\n * links. If no path is given, returns a list of all shared links for the\n * current user, including collection links, up to a maximum of 1000 links. If a\n * non-empty path is given, returns a list of all shared links that allow access\n * to the given path.  Collection links are never returned in this case. Note\n * that the url field in the response is never the shortened URL.\n * @function Dropbox#sharingGetSharedLinks\n * @deprecated\n * @arg {SharingGetSharedLinksArg} arg - The request parameters.\n * @returns {Promise.<DropboxResponse<SharingGetSharedLinksResult>, Error.<SharingGetSharedLinksError>>}\n */\n\n\nroutes.sharingGetSharedLinks = function (arg) {\n  return this.request('sharing/get_shared_links', arg, 'user', 'api', 'rpc');\n};\n/**\n * Use to obtain the members who have been invited to a file, both inherited and\n * uninherited members.\n * @function Dropbox#sharingListFileMembers\n * @arg {SharingListFileMembersArg} arg - The request parameters.\n * @returns {Promise.<DropboxResponse<SharingSharedFileMembers>, Error.<SharingListFileMembersError>>}\n */\n\n\nroutes.sharingListFileMembers = function (arg) {\n  return this.request('sharing/list_file_members', arg, 'user', 'api', 'rpc');\n};\n/**\n * Get members of multiple files at once. The arguments to this route are more\n * limited, and the limit on query result size per file is more strict. To\n * customize the results more, use the individual file endpoint. Inherited users\n * and groups are not included in the result, and permissions are not returned\n * for this endpoint.\n * @function Dropbox#sharingListFileMembersBatch\n * @arg {SharingListFileMembersBatchArg} arg - The request parameters.\n * @returns {Promise.<DropboxResponse<Array.<SharingListFileMembersBatchResult>>, Error.<SharingSharingUserError>>}\n */\n\n\nroutes.sharingListFileMembersBatch = function (arg) {\n  return this.request('sharing/list_file_members/batch', arg, 'user', 'api', 'rpc');\n};\n/**\n * Once a cursor has been retrieved from list_file_members or\n * list_file_members/batch, use this to paginate through all shared file\n * members.\n * @function Dropbox#sharingListFileMembersContinue\n * @arg {SharingListFileMembersContinueArg} arg - The request parameters.\n * @returns {Promise.<DropboxResponse<SharingSharedFileMembers>, Error.<SharingListFileMembersContinueError>>}\n */\n\n\nroutes.sharingListFileMembersContinue = function (arg) {\n  return this.request('sharing/list_file_members/continue', arg, 'user', 'api', 'rpc');\n};\n/**\n * Returns shared folder membership by its folder ID.\n * @function Dropbox#sharingListFolderMembers\n * @arg {SharingListFolderMembersArgs} arg - The request parameters.\n * @returns {Promise.<DropboxResponse<SharingSharedFolderMembers>, Error.<SharingSharedFolderAccessError>>}\n */\n\n\nroutes.sharingListFolderMembers = function (arg) {\n  return this.request('sharing/list_folder_members', arg, 'user', 'api', 'rpc');\n};\n/**\n * Once a cursor has been retrieved from list_folder_members, use this to\n * paginate through all shared folder members.\n * @function Dropbox#sharingListFolderMembersContinue\n * @arg {SharingListFolderMembersContinueArg} arg - The request parameters.\n * @returns {Promise.<DropboxResponse<SharingSharedFolderMembers>, Error.<SharingListFolderMembersContinueError>>}\n */\n\n\nroutes.sharingListFolderMembersContinue = function (arg) {\n  return this.request('sharing/list_folder_members/continue', arg, 'user', 'api', 'rpc');\n};\n/**\n * Return the list of all shared folders the current user has access to.\n * @function Dropbox#sharingListFolders\n * @arg {SharingListFoldersArgs} arg - The request parameters.\n * @returns {Promise.<DropboxResponse<SharingListFoldersResult>, Error.<void>>}\n */\n\n\nroutes.sharingListFolders = function (arg) {\n  return this.request('sharing/list_folders', arg, 'user', 'api', 'rpc');\n};\n/**\n * Once a cursor has been retrieved from list_folders, use this to paginate\n * through all shared folders. The cursor must come from a previous call to\n * list_folders or list_folders/continue.\n * @function Dropbox#sharingListFoldersContinue\n * @arg {SharingListFoldersContinueArg} arg - The request parameters.\n * @returns {Promise.<DropboxResponse<SharingListFoldersResult>, Error.<SharingListFoldersContinueError>>}\n */\n\n\nroutes.sharingListFoldersContinue = function (arg) {\n  return this.request('sharing/list_folders/continue', arg, 'user', 'api', 'rpc');\n};\n/**\n * Return the list of all shared folders the current user can mount or unmount.\n * @function Dropbox#sharingListMountableFolders\n * @arg {SharingListFoldersArgs} arg - The request parameters.\n * @returns {Promise.<DropboxResponse<SharingListFoldersResult>, Error.<void>>}\n */\n\n\nroutes.sharingListMountableFolders = function (arg) {\n  return this.request('sharing/list_mountable_folders', arg, 'user', 'api', 'rpc');\n};\n/**\n * Once a cursor has been retrieved from list_mountable_folders, use this to\n * paginate through all mountable shared folders. The cursor must come from a\n * previous call to list_mountable_folders or list_mountable_folders/continue.\n * @function Dropbox#sharingListMountableFoldersContinue\n * @arg {SharingListFoldersContinueArg} arg - The request parameters.\n * @returns {Promise.<DropboxResponse<SharingListFoldersResult>, Error.<SharingListFoldersContinueError>>}\n */\n\n\nroutes.sharingListMountableFoldersContinue = function (arg) {\n  return this.request('sharing/list_mountable_folders/continue', arg, 'user', 'api', 'rpc');\n};\n/**\n * Returns a list of all files shared with current user.  Does not include files\n * the user has received via shared folders, and does  not include unclaimed\n * invitations.\n * @function Dropbox#sharingListReceivedFiles\n * @arg {SharingListFilesArg} arg - The request parameters.\n * @returns {Promise.<DropboxResponse<SharingListFilesResult>, Error.<SharingSharingUserError>>}\n */\n\n\nroutes.sharingListReceivedFiles = function (arg) {\n  return this.request('sharing/list_received_files', arg, 'user', 'api', 'rpc');\n};\n/**\n * Get more results with a cursor from list_received_files.\n * @function Dropbox#sharingListReceivedFilesContinue\n * @arg {SharingListFilesContinueArg} arg - The request parameters.\n * @returns {Promise.<DropboxResponse<SharingListFilesResult>, Error.<SharingListFilesContinueError>>}\n */\n\n\nroutes.sharingListReceivedFilesContinue = function (arg) {\n  return this.request('sharing/list_received_files/continue', arg, 'user', 'api', 'rpc');\n};\n/**\n * List shared links of this user. If no path is given, returns a list of all\n * shared links for the current user. For members of business teams using team\n * space and member folders, returns all shared links in the team member's home\n * folder unless the team space ID is specified in the request header. For more\n * information, refer to the Namespace Guide\n * https://www.dropbox.com/developers/reference/namespace-guide. If a non-empty\n * path is given, returns a list of all shared links that allow access to the\n * given path - direct links to the given path and links to parent folders of\n * the given path. Links to parent folders can be suppressed by setting\n * direct_only to true.\n * @function Dropbox#sharingListSharedLinks\n * @arg {SharingListSharedLinksArg} arg - The request parameters.\n * @returns {Promise.<DropboxResponse<SharingListSharedLinksResult>, Error.<SharingListSharedLinksError>>}\n */\n\n\nroutes.sharingListSharedLinks = function (arg) {\n  return this.request('sharing/list_shared_links', arg, 'user', 'api', 'rpc');\n};\n/**\n * Modify the shared link's settings. If the requested visibility conflict with\n * the shared links policy of the team or the shared folder (in case the linked\n * file is part of a shared folder) then the LinkPermissions.resolved_visibility\n * of the returned SharedLinkMetadata will reflect the actual visibility of the\n * shared link and the LinkPermissions.requested_visibility will reflect the\n * requested visibility.\n * @function Dropbox#sharingModifySharedLinkSettings\n * @arg {SharingModifySharedLinkSettingsArgs} arg - The request parameters.\n * @returns {Promise.<DropboxResponse<(SharingFileLinkMetadata|SharingFolderLinkMetadata|SharingSharedLinkMetadata)>, Error.<SharingModifySharedLinkSettingsError>>}\n */\n\n\nroutes.sharingModifySharedLinkSettings = function (arg) {\n  return this.request('sharing/modify_shared_link_settings', arg, 'user', 'api', 'rpc');\n};\n/**\n * The current user mounts the designated folder. Mount a shared folder for a\n * user after they have been added as a member. Once mounted, the shared folder\n * will appear in their Dropbox.\n * @function Dropbox#sharingMountFolder\n * @arg {SharingMountFolderArg} arg - The request parameters.\n * @returns {Promise.<DropboxResponse<SharingSharedFolderMetadata>, Error.<SharingMountFolderError>>}\n */\n\n\nroutes.sharingMountFolder = function (arg) {\n  return this.request('sharing/mount_folder', arg, 'user', 'api', 'rpc');\n};\n/**\n * The current user relinquishes their membership in the designated file. Note\n * that the current user may still have inherited access to this file through\n * the parent folder.\n * @function Dropbox#sharingRelinquishFileMembership\n * @arg {SharingRelinquishFileMembershipArg} arg - The request parameters.\n * @returns {Promise.<DropboxResponse<void>, Error.<SharingRelinquishFileMembershipError>>}\n */\n\n\nroutes.sharingRelinquishFileMembership = function (arg) {\n  return this.request('sharing/relinquish_file_membership', arg, 'user', 'api', 'rpc');\n};\n/**\n * The current user relinquishes their membership in the designated shared\n * folder and will no longer have access to the folder.  A folder owner cannot\n * relinquish membership in their own folder. This will run synchronously if\n * leave_a_copy is false, and asynchronously if leave_a_copy is true.\n * @function Dropbox#sharingRelinquishFolderMembership\n * @arg {SharingRelinquishFolderMembershipArg} arg - The request parameters.\n * @returns {Promise.<DropboxResponse<AsyncLaunchEmptyResult>, Error.<SharingRelinquishFolderMembershipError>>}\n */\n\n\nroutes.sharingRelinquishFolderMembership = function (arg) {\n  return this.request('sharing/relinquish_folder_membership', arg, 'user', 'api', 'rpc');\n};\n/**\n * Identical to remove_file_member_2 but with less information returned.\n * @function Dropbox#sharingRemoveFileMember\n * @deprecated\n * @arg {SharingRemoveFileMemberArg} arg - The request parameters.\n * @returns {Promise.<DropboxResponse<SharingFileMemberActionIndividualResult>, Error.<SharingRemoveFileMemberError>>}\n */\n\n\nroutes.sharingRemoveFileMember = function (arg) {\n  return this.request('sharing/remove_file_member', arg, 'user', 'api', 'rpc');\n};\n/**\n * Removes a specified member from the file.\n * @function Dropbox#sharingRemoveFileMember2\n * @arg {SharingRemoveFileMemberArg} arg - The request parameters.\n * @returns {Promise.<DropboxResponse<SharingFileMemberRemoveActionResult>, Error.<SharingRemoveFileMemberError>>}\n */\n\n\nroutes.sharingRemoveFileMember2 = function (arg) {\n  return this.request('sharing/remove_file_member_2', arg, 'user', 'api', 'rpc');\n};\n/**\n * Allows an owner or editor (if the ACL update policy allows) of a shared\n * folder to remove another member.\n * @function Dropbox#sharingRemoveFolderMember\n * @arg {SharingRemoveFolderMemberArg} arg - The request parameters.\n * @returns {Promise.<DropboxResponse<AsyncLaunchResultBase>, Error.<SharingRemoveFolderMemberError>>}\n */\n\n\nroutes.sharingRemoveFolderMember = function (arg) {\n  return this.request('sharing/remove_folder_member', arg, 'user', 'api', 'rpc');\n};\n/**\n * Revoke a shared link. Note that even after revoking a shared link to a file,\n * the file may be accessible if there are shared links leading to any of the\n * file parent folders. To list all shared links that enable access to a\n * specific file, you can use the list_shared_links with the file as the\n * ListSharedLinksArg.path argument.\n * @function Dropbox#sharingRevokeSharedLink\n * @arg {SharingRevokeSharedLinkArg} arg - The request parameters.\n * @returns {Promise.<DropboxResponse<void>, Error.<SharingRevokeSharedLinkError>>}\n */\n\n\nroutes.sharingRevokeSharedLink = function (arg) {\n  return this.request('sharing/revoke_shared_link', arg, 'user', 'api', 'rpc');\n};\n/**\n * Change the inheritance policy of an existing Shared Folder. Only permitted\n * for shared folders in a shared team root. If a ShareFolderLaunch.async_job_id\n * is returned, you'll need to call check_share_job_status until the action\n * completes to get the metadata for the folder.\n * @function Dropbox#sharingSetAccessInheritance\n * @arg {SharingSetAccessInheritanceArg} arg - The request parameters.\n * @returns {Promise.<DropboxResponse<SharingShareFolderLaunch>, Error.<SharingSetAccessInheritanceError>>}\n */\n\n\nroutes.sharingSetAccessInheritance = function (arg) {\n  return this.request('sharing/set_access_inheritance', arg, 'user', 'api', 'rpc');\n};\n/**\n * Share a folder with collaborators. Most sharing will be completed\n * synchronously. Large folders will be completed asynchronously. To make\n * testing the async case repeatable, set `ShareFolderArg.force_async`. If a\n * ShareFolderLaunch.async_job_id is returned, you'll need to call\n * check_share_job_status until the action completes to get the metadata for the\n * folder.\n * @function Dropbox#sharingShareFolder\n * @arg {SharingShareFolderArg} arg - The request parameters.\n * @returns {Promise.<DropboxResponse<SharingShareFolderLaunch>, Error.<SharingShareFolderError>>}\n */\n\n\nroutes.sharingShareFolder = function (arg) {\n  return this.request('sharing/share_folder', arg, 'user', 'api', 'rpc');\n};\n/**\n * Transfer ownership of a shared folder to a member of the shared folder. User\n * must have AccessLevel.owner access to the shared folder to perform a\n * transfer.\n * @function Dropbox#sharingTransferFolder\n * @arg {SharingTransferFolderArg} arg - The request parameters.\n * @returns {Promise.<DropboxResponse<void>, Error.<SharingTransferFolderError>>}\n */\n\n\nroutes.sharingTransferFolder = function (arg) {\n  return this.request('sharing/transfer_folder', arg, 'user', 'api', 'rpc');\n};\n/**\n * The current user unmounts the designated folder. They can re-mount the folder\n * at a later time using mount_folder.\n * @function Dropbox#sharingUnmountFolder\n * @arg {SharingUnmountFolderArg} arg - The request parameters.\n * @returns {Promise.<DropboxResponse<void>, Error.<SharingUnmountFolderError>>}\n */\n\n\nroutes.sharingUnmountFolder = function (arg) {\n  return this.request('sharing/unmount_folder', arg, 'user', 'api', 'rpc');\n};\n/**\n * Remove all members from this file. Does not remove inherited members.\n * @function Dropbox#sharingUnshareFile\n * @arg {SharingUnshareFileArg} arg - The request parameters.\n * @returns {Promise.<DropboxResponse<void>, Error.<SharingUnshareFileError>>}\n */\n\n\nroutes.sharingUnshareFile = function (arg) {\n  return this.request('sharing/unshare_file', arg, 'user', 'api', 'rpc');\n};\n/**\n * Allows a shared folder owner to unshare the folder. You'll need to call\n * check_job_status to determine if the action has completed successfully.\n * @function Dropbox#sharingUnshareFolder\n * @arg {SharingUnshareFolderArg} arg - The request parameters.\n * @returns {Promise.<DropboxResponse<AsyncLaunchEmptyResult>, Error.<SharingUnshareFolderError>>}\n */\n\n\nroutes.sharingUnshareFolder = function (arg) {\n  return this.request('sharing/unshare_folder', arg, 'user', 'api', 'rpc');\n};\n/**\n * Changes a member's access on a shared file.\n * @function Dropbox#sharingUpdateFileMember\n * @arg {SharingUpdateFileMemberArgs} arg - The request parameters.\n * @returns {Promise.<DropboxResponse<SharingMemberAccessLevelResult>, Error.<SharingFileMemberActionError>>}\n */\n\n\nroutes.sharingUpdateFileMember = function (arg) {\n  return this.request('sharing/update_file_member', arg, 'user', 'api', 'rpc');\n};\n/**\n * Allows an owner or editor of a shared folder to update another member's\n * permissions.\n * @function Dropbox#sharingUpdateFolderMember\n * @arg {SharingUpdateFolderMemberArg} arg - The request parameters.\n * @returns {Promise.<DropboxResponse<SharingMemberAccessLevelResult>, Error.<SharingUpdateFolderMemberError>>}\n */\n\n\nroutes.sharingUpdateFolderMember = function (arg) {\n  return this.request('sharing/update_folder_member', arg, 'user', 'api', 'rpc');\n};\n/**\n * Update the sharing policies for a shared folder. User must have\n * AccessLevel.owner access to the shared folder to update its policies.\n * @function Dropbox#sharingUpdateFolderPolicy\n * @arg {SharingUpdateFolderPolicyArg} arg - The request parameters.\n * @returns {Promise.<DropboxResponse<SharingSharedFolderMetadata>, Error.<SharingUpdateFolderPolicyError>>}\n */\n\n\nroutes.sharingUpdateFolderPolicy = function (arg) {\n  return this.request('sharing/update_folder_policy', arg, 'user', 'api', 'rpc');\n};\n/**\n * List all device sessions of a team's member.\n * @function Dropbox#teamDevicesListMemberDevices\n * @arg {TeamListMemberDevicesArg} arg - The request parameters.\n * @returns {Promise.<DropboxResponse<TeamListMemberDevicesResult>, Error.<TeamListMemberDevicesError>>}\n */\n\n\nroutes.teamDevicesListMemberDevices = function (arg) {\n  return this.request('team/devices/list_member_devices', arg, 'team', 'api', 'rpc');\n};\n/**\n * List all device sessions of a team. Permission : Team member file access.\n * @function Dropbox#teamDevicesListMembersDevices\n * @arg {TeamListMembersDevicesArg} arg - The request parameters.\n * @returns {Promise.<DropboxResponse<TeamListMembersDevicesResult>, Error.<TeamListMembersDevicesError>>}\n */\n\n\nroutes.teamDevicesListMembersDevices = function (arg) {\n  return this.request('team/devices/list_members_devices', arg, 'team', 'api', 'rpc');\n};\n/**\n * List all device sessions of a team. Permission : Team member file access.\n * @function Dropbox#teamDevicesListTeamDevices\n * @deprecated\n * @arg {TeamListTeamDevicesArg} arg - The request parameters.\n * @returns {Promise.<DropboxResponse<TeamListTeamDevicesResult>, Error.<TeamListTeamDevicesError>>}\n */\n\n\nroutes.teamDevicesListTeamDevices = function (arg) {\n  return this.request('team/devices/list_team_devices', arg, 'team', 'api', 'rpc');\n};\n/**\n * Revoke a device session of a team's member.\n * @function Dropbox#teamDevicesRevokeDeviceSession\n * @arg {TeamRevokeDeviceSessionArg} arg - The request parameters.\n * @returns {Promise.<DropboxResponse<void>, Error.<TeamRevokeDeviceSessionError>>}\n */\n\n\nroutes.teamDevicesRevokeDeviceSession = function (arg) {\n  return this.request('team/devices/revoke_device_session', arg, 'team', 'api', 'rpc');\n};\n/**\n * Revoke a list of device sessions of team members.\n * @function Dropbox#teamDevicesRevokeDeviceSessionBatch\n * @arg {TeamRevokeDeviceSessionBatchArg} arg - The request parameters.\n * @returns {Promise.<DropboxResponse<TeamRevokeDeviceSessionBatchResult>, Error.<TeamRevokeDeviceSessionBatchError>>}\n */\n\n\nroutes.teamDevicesRevokeDeviceSessionBatch = function (arg) {\n  return this.request('team/devices/revoke_device_session_batch', arg, 'team', 'api', 'rpc');\n};\n/**\n * Get the values for one or more featues. This route allows you to check your\n * account's capability for what feature you can access or what value you have\n * for certain features. Permission : Team information.\n * @function Dropbox#teamFeaturesGetValues\n * @arg {TeamFeaturesGetValuesBatchArg} arg - The request parameters.\n * @returns {Promise.<DropboxResponse<TeamFeaturesGetValuesBatchResult>, Error.<TeamFeaturesGetValuesBatchError>>}\n */\n\n\nroutes.teamFeaturesGetValues = function (arg) {\n  return this.request('team/features/get_values', arg, 'team', 'api', 'rpc');\n};\n/**\n * Retrieves information about a team.\n * @function Dropbox#teamGetInfo\n * @returns {Promise.<DropboxResponse<TeamTeamGetInfoResult>, Error.<void>>}\n */\n\n\nroutes.teamGetInfo = function () {\n  return this.request('team/get_info', null, 'team', 'api', 'rpc');\n};\n/**\n * Creates a new, empty group, with a requested name. Permission : Team member\n * management.\n * @function Dropbox#teamGroupsCreate\n * @arg {TeamGroupCreateArg} arg - The request parameters.\n * @returns {Promise.<DropboxResponse<TeamGroupFullInfo>, Error.<TeamGroupCreateError>>}\n */\n\n\nroutes.teamGroupsCreate = function (arg) {\n  return this.request('team/groups/create', arg, 'team', 'api', 'rpc');\n};\n/**\n * Deletes a group. The group is deleted immediately. However the revoking of\n * group-owned resources may take additional time. Use the groups/job_status/get\n * to determine whether this process has completed. Permission : Team member\n * management.\n * @function Dropbox#teamGroupsDelete\n * @arg {TeamGroupSelector} arg - The request parameters.\n * @returns {Promise.<DropboxResponse<AsyncLaunchEmptyResult>, Error.<TeamGroupDeleteError>>}\n */\n\n\nroutes.teamGroupsDelete = function (arg) {\n  return this.request('team/groups/delete', arg, 'team', 'api', 'rpc');\n};\n/**\n * Retrieves information about one or more groups. Note that the optional field\n * GroupFullInfo.members is not returned for system-managed groups. Permission :\n * Team Information.\n * @function Dropbox#teamGroupsGetInfo\n * @arg {TeamGroupsSelector} arg - The request parameters.\n * @returns {Promise.<DropboxResponse<Object>, Error.<TeamGroupsGetInfoError>>}\n */\n\n\nroutes.teamGroupsGetInfo = function (arg) {\n  return this.request('team/groups/get_info', arg, 'team', 'api', 'rpc');\n};\n/**\n * Once an async_job_id is returned from groups/delete, groups/members/add , or\n * groups/members/remove use this method to poll the status of granting/revoking\n * group members' access to group-owned resources. Permission : Team member\n * management.\n * @function Dropbox#teamGroupsJobStatusGet\n * @arg {AsyncPollArg} arg - The request parameters.\n * @returns {Promise.<DropboxResponse<AsyncPollEmptyResult>, Error.<TeamGroupsPollError>>}\n */\n\n\nroutes.teamGroupsJobStatusGet = function (arg) {\n  return this.request('team/groups/job_status/get', arg, 'team', 'api', 'rpc');\n};\n/**\n * Lists groups on a team. Permission : Team Information.\n * @function Dropbox#teamGroupsList\n * @arg {TeamGroupsListArg} arg - The request parameters.\n * @returns {Promise.<DropboxResponse<TeamGroupsListResult>, Error.<void>>}\n */\n\n\nroutes.teamGroupsList = function (arg) {\n  return this.request('team/groups/list', arg, 'team', 'api', 'rpc');\n};\n/**\n * Once a cursor has been retrieved from groups/list, use this to paginate\n * through all groups. Permission : Team Information.\n * @function Dropbox#teamGroupsListContinue\n * @arg {TeamGroupsListContinueArg} arg - The request parameters.\n * @returns {Promise.<DropboxResponse<TeamGroupsListResult>, Error.<TeamGroupsListContinueError>>}\n */\n\n\nroutes.teamGroupsListContinue = function (arg) {\n  return this.request('team/groups/list/continue', arg, 'team', 'api', 'rpc');\n};\n/**\n * Adds members to a group. The members are added immediately. However the\n * granting of group-owned resources may take additional time. Use the\n * groups/job_status/get to determine whether this process has completed.\n * Permission : Team member management.\n * @function Dropbox#teamGroupsMembersAdd\n * @arg {TeamGroupMembersAddArg} arg - The request parameters.\n * @returns {Promise.<DropboxResponse<TeamGroupMembersChangeResult>, Error.<TeamGroupMembersAddError>>}\n */\n\n\nroutes.teamGroupsMembersAdd = function (arg) {\n  return this.request('team/groups/members/add', arg, 'team', 'api', 'rpc');\n};\n/**\n * Lists members of a group. Permission : Team Information.\n * @function Dropbox#teamGroupsMembersList\n * @arg {TeamGroupsMembersListArg} arg - The request parameters.\n * @returns {Promise.<DropboxResponse<TeamGroupsMembersListResult>, Error.<TeamGroupSelectorError>>}\n */\n\n\nroutes.teamGroupsMembersList = function (arg) {\n  return this.request('team/groups/members/list', arg, 'team', 'api', 'rpc');\n};\n/**\n * Once a cursor has been retrieved from groups/members/list, use this to\n * paginate through all members of the group. Permission : Team information.\n * @function Dropbox#teamGroupsMembersListContinue\n * @arg {TeamGroupsMembersListContinueArg} arg - The request parameters.\n * @returns {Promise.<DropboxResponse<TeamGroupsMembersListResult>, Error.<TeamGroupsMembersListContinueError>>}\n */\n\n\nroutes.teamGroupsMembersListContinue = function (arg) {\n  return this.request('team/groups/members/list/continue', arg, 'team', 'api', 'rpc');\n};\n/**\n * Removes members from a group. The members are removed immediately. However\n * the revoking of group-owned resources may take additional time. Use the\n * groups/job_status/get to determine whether this process has completed. This\n * method permits removing the only owner of a group, even in cases where this\n * is not possible via the web client. Permission : Team member management.\n * @function Dropbox#teamGroupsMembersRemove\n * @arg {TeamGroupMembersRemoveArg} arg - The request parameters.\n * @returns {Promise.<DropboxResponse<TeamGroupMembersChangeResult>, Error.<TeamGroupMembersRemoveError>>}\n */\n\n\nroutes.teamGroupsMembersRemove = function (arg) {\n  return this.request('team/groups/members/remove', arg, 'team', 'api', 'rpc');\n};\n/**\n * Sets a member's access type in a group. Permission : Team member management.\n * @function Dropbox#teamGroupsMembersSetAccessType\n * @arg {TeamGroupMembersSetAccessTypeArg} arg - The request parameters.\n * @returns {Promise.<DropboxResponse<Object>, Error.<TeamGroupMemberSetAccessTypeError>>}\n */\n\n\nroutes.teamGroupsMembersSetAccessType = function (arg) {\n  return this.request('team/groups/members/set_access_type', arg, 'team', 'api', 'rpc');\n};\n/**\n * Updates a group's name and/or external ID. Permission : Team member\n * management.\n * @function Dropbox#teamGroupsUpdate\n * @arg {TeamGroupUpdateArgs} arg - The request parameters.\n * @returns {Promise.<DropboxResponse<TeamGroupFullInfo>, Error.<TeamGroupUpdateError>>}\n */\n\n\nroutes.teamGroupsUpdate = function (arg) {\n  return this.request('team/groups/update', arg, 'team', 'api', 'rpc');\n};\n/**\n * Creates new legal hold policy. Note: Legal Holds is a paid add-on. Not all\n * teams have the feature. Permission : Team member file access.\n * @function Dropbox#teamLegalHoldsCreatePolicy\n * @arg {TeamLegalHoldsPolicyCreateArg} arg - The request parameters.\n * @returns {Promise.<DropboxResponse<Object>, Error.<TeamLegalHoldsPolicyCreateError>>}\n */\n\n\nroutes.teamLegalHoldsCreatePolicy = function (arg) {\n  return this.request('team/legal_holds/create_policy', arg, 'team', 'api', 'rpc');\n};\n/**\n * Gets a legal hold by Id. Note: Legal Holds is a paid add-on. Not all teams\n * have the feature. Permission : Team member file access.\n * @function Dropbox#teamLegalHoldsGetPolicy\n * @arg {TeamLegalHoldsGetPolicyArg} arg - The request parameters.\n * @returns {Promise.<DropboxResponse<Object>, Error.<TeamLegalHoldsGetPolicyError>>}\n */\n\n\nroutes.teamLegalHoldsGetPolicy = function (arg) {\n  return this.request('team/legal_holds/get_policy', arg, 'team', 'api', 'rpc');\n};\n/**\n * List the file metadata that's under the hold. Note: Legal Holds is a paid\n * add-on. Not all teams have the feature. Permission : Team member file access.\n * @function Dropbox#teamLegalHoldsListHeldRevisions\n * @arg {TeamLegalHoldsListHeldRevisionsArg} arg - The request parameters.\n * @returns {Promise.<DropboxResponse<TeamLegalHoldsListHeldRevisionResult>, Error.<TeamLegalHoldsListHeldRevisionsError>>}\n */\n\n\nroutes.teamLegalHoldsListHeldRevisions = function (arg) {\n  return this.request('team/legal_holds/list_held_revisions', arg, 'team', 'api', 'rpc');\n};\n/**\n * Continue listing the file metadata that's under the hold. Note: Legal Holds\n * is a paid add-on. Not all teams have the feature. Permission : Team member\n * file access.\n * @function Dropbox#teamLegalHoldsListHeldRevisionsContinue\n * @arg {TeamLegalHoldsListHeldRevisionsContinueArg} arg - The request parameters.\n * @returns {Promise.<DropboxResponse<TeamLegalHoldsListHeldRevisionResult>, Error.<TeamLegalHoldsListHeldRevisionsError>>}\n */\n\n\nroutes.teamLegalHoldsListHeldRevisionsContinue = function (arg) {\n  return this.request('team/legal_holds/list_held_revisions_continue', arg, 'team', 'api', 'rpc');\n};\n/**\n * Lists legal holds on a team. Note: Legal Holds is a paid add-on. Not all\n * teams have the feature. Permission : Team member file access.\n * @function Dropbox#teamLegalHoldsListPolicies\n * @arg {TeamLegalHoldsListPoliciesArg} arg - The request parameters.\n * @returns {Promise.<DropboxResponse<TeamLegalHoldsListPoliciesResult>, Error.<TeamLegalHoldsListPoliciesError>>}\n */\n\n\nroutes.teamLegalHoldsListPolicies = function (arg) {\n  return this.request('team/legal_holds/list_policies', arg, 'team', 'api', 'rpc');\n};\n/**\n * Releases a legal hold by Id. Note: Legal Holds is a paid add-on. Not all\n * teams have the feature. Permission : Team member file access.\n * @function Dropbox#teamLegalHoldsReleasePolicy\n * @arg {TeamLegalHoldsPolicyReleaseArg} arg - The request parameters.\n * @returns {Promise.<DropboxResponse<void>, Error.<TeamLegalHoldsPolicyReleaseError>>}\n */\n\n\nroutes.teamLegalHoldsReleasePolicy = function (arg) {\n  return this.request('team/legal_holds/release_policy', arg, 'team', 'api', 'rpc');\n};\n/**\n * Updates a legal hold. Note: Legal Holds is a paid add-on. Not all teams have\n * the feature. Permission : Team member file access.\n * @function Dropbox#teamLegalHoldsUpdatePolicy\n * @arg {TeamLegalHoldsPolicyUpdateArg} arg - The request parameters.\n * @returns {Promise.<DropboxResponse<Object>, Error.<TeamLegalHoldsPolicyUpdateError>>}\n */\n\n\nroutes.teamLegalHoldsUpdatePolicy = function (arg) {\n  return this.request('team/legal_holds/update_policy', arg, 'team', 'api', 'rpc');\n};\n/**\n * List all linked applications of the team member. Note, this endpoint does not\n * list any team-linked applications.\n * @function Dropbox#teamLinkedAppsListMemberLinkedApps\n * @arg {TeamListMemberAppsArg} arg - The request parameters.\n * @returns {Promise.<DropboxResponse<TeamListMemberAppsResult>, Error.<TeamListMemberAppsError>>}\n */\n\n\nroutes.teamLinkedAppsListMemberLinkedApps = function (arg) {\n  return this.request('team/linked_apps/list_member_linked_apps', arg, 'team', 'api', 'rpc');\n};\n/**\n * List all applications linked to the team members' accounts. Note, this\n * endpoint does not list any team-linked applications.\n * @function Dropbox#teamLinkedAppsListMembersLinkedApps\n * @arg {TeamListMembersAppsArg} arg - The request parameters.\n * @returns {Promise.<DropboxResponse<TeamListMembersAppsResult>, Error.<TeamListMembersAppsError>>}\n */\n\n\nroutes.teamLinkedAppsListMembersLinkedApps = function (arg) {\n  return this.request('team/linked_apps/list_members_linked_apps', arg, 'team', 'api', 'rpc');\n};\n/**\n * List all applications linked to the team members' accounts. Note, this\n * endpoint doesn't list any team-linked applications.\n * @function Dropbox#teamLinkedAppsListTeamLinkedApps\n * @deprecated\n * @arg {TeamListTeamAppsArg} arg - The request parameters.\n * @returns {Promise.<DropboxResponse<TeamListTeamAppsResult>, Error.<TeamListTeamAppsError>>}\n */\n\n\nroutes.teamLinkedAppsListTeamLinkedApps = function (arg) {\n  return this.request('team/linked_apps/list_team_linked_apps', arg, 'team', 'api', 'rpc');\n};\n/**\n * Revoke a linked application of the team member.\n * @function Dropbox#teamLinkedAppsRevokeLinkedApp\n * @arg {TeamRevokeLinkedApiAppArg} arg - The request parameters.\n * @returns {Promise.<DropboxResponse<void>, Error.<TeamRevokeLinkedAppError>>}\n */\n\n\nroutes.teamLinkedAppsRevokeLinkedApp = function (arg) {\n  return this.request('team/linked_apps/revoke_linked_app', arg, 'team', 'api', 'rpc');\n};\n/**\n * Revoke a list of linked applications of the team members.\n * @function Dropbox#teamLinkedAppsRevokeLinkedAppBatch\n * @arg {TeamRevokeLinkedApiAppBatchArg} arg - The request parameters.\n * @returns {Promise.<DropboxResponse<TeamRevokeLinkedAppBatchResult>, Error.<TeamRevokeLinkedAppBatchError>>}\n */\n\n\nroutes.teamLinkedAppsRevokeLinkedAppBatch = function (arg) {\n  return this.request('team/linked_apps/revoke_linked_app_batch', arg, 'team', 'api', 'rpc');\n};\n/**\n * Add users to member space limits excluded users list.\n * @function Dropbox#teamMemberSpaceLimitsExcludedUsersAdd\n * @arg {TeamExcludedUsersUpdateArg} arg - The request parameters.\n * @returns {Promise.<DropboxResponse<TeamExcludedUsersUpdateResult>, Error.<TeamExcludedUsersUpdateError>>}\n */\n\n\nroutes.teamMemberSpaceLimitsExcludedUsersAdd = function (arg) {\n  return this.request('team/member_space_limits/excluded_users/add', arg, 'team', 'api', 'rpc');\n};\n/**\n * List member space limits excluded users.\n * @function Dropbox#teamMemberSpaceLimitsExcludedUsersList\n * @arg {TeamExcludedUsersListArg} arg - The request parameters.\n * @returns {Promise.<DropboxResponse<TeamExcludedUsersListResult>, Error.<TeamExcludedUsersListError>>}\n */\n\n\nroutes.teamMemberSpaceLimitsExcludedUsersList = function (arg) {\n  return this.request('team/member_space_limits/excluded_users/list', arg, 'team', 'api', 'rpc');\n};\n/**\n * Continue listing member space limits excluded users.\n * @function Dropbox#teamMemberSpaceLimitsExcludedUsersListContinue\n * @arg {TeamExcludedUsersListContinueArg} arg - The request parameters.\n * @returns {Promise.<DropboxResponse<TeamExcludedUsersListResult>, Error.<TeamExcludedUsersListContinueError>>}\n */\n\n\nroutes.teamMemberSpaceLimitsExcludedUsersListContinue = function (arg) {\n  return this.request('team/member_space_limits/excluded_users/list/continue', arg, 'team', 'api', 'rpc');\n};\n/**\n * Remove users from member space limits excluded users list.\n * @function Dropbox#teamMemberSpaceLimitsExcludedUsersRemove\n * @arg {TeamExcludedUsersUpdateArg} arg - The request parameters.\n * @returns {Promise.<DropboxResponse<TeamExcludedUsersUpdateResult>, Error.<TeamExcludedUsersUpdateError>>}\n */\n\n\nroutes.teamMemberSpaceLimitsExcludedUsersRemove = function (arg) {\n  return this.request('team/member_space_limits/excluded_users/remove', arg, 'team', 'api', 'rpc');\n};\n/**\n * Get users custom quota. Returns none as the custom quota if none was set. A\n * maximum of 1000 members can be specified in a single call.\n * @function Dropbox#teamMemberSpaceLimitsGetCustomQuota\n * @arg {TeamCustomQuotaUsersArg} arg - The request parameters.\n * @returns {Promise.<DropboxResponse<Array.<TeamCustomQuotaResult>>, Error.<TeamCustomQuotaError>>}\n */\n\n\nroutes.teamMemberSpaceLimitsGetCustomQuota = function (arg) {\n  return this.request('team/member_space_limits/get_custom_quota', arg, 'team', 'api', 'rpc');\n};\n/**\n * Remove users custom quota. A maximum of 1000 members can be specified in a\n * single call.\n * @function Dropbox#teamMemberSpaceLimitsRemoveCustomQuota\n * @arg {TeamCustomQuotaUsersArg} arg - The request parameters.\n * @returns {Promise.<DropboxResponse<Array.<TeamRemoveCustomQuotaResult>>, Error.<TeamCustomQuotaError>>}\n */\n\n\nroutes.teamMemberSpaceLimitsRemoveCustomQuota = function (arg) {\n  return this.request('team/member_space_limits/remove_custom_quota', arg, 'team', 'api', 'rpc');\n};\n/**\n * Set users custom quota. Custom quota has to be at least 15GB. A maximum of\n * 1000 members can be specified in a single call.\n * @function Dropbox#teamMemberSpaceLimitsSetCustomQuota\n * @arg {TeamSetCustomQuotaArg} arg - The request parameters.\n * @returns {Promise.<DropboxResponse<Array.<TeamCustomQuotaResult>>, Error.<TeamSetCustomQuotaError>>}\n */\n\n\nroutes.teamMemberSpaceLimitsSetCustomQuota = function (arg) {\n  return this.request('team/member_space_limits/set_custom_quota', arg, 'team', 'api', 'rpc');\n};\n/**\n * Adds members to a team. Permission : Team member management A maximum of 20\n * members can be specified in a single call. If no Dropbox account exists with\n * the email address specified, a new Dropbox account will be created with the\n * given email address, and that account will be invited to the team. If a\n * personal Dropbox account exists with the email address specified in the call,\n * this call will create a placeholder Dropbox account for the user on the team\n * and send an email inviting the user to migrate their existing personal\n * account onto the team. Team member management apps are required to set an\n * initial given_name and surname for a user to use in the team invitation and\n * for 'Perform as team member' actions taken on the user before they become\n * 'active'.\n * @function Dropbox#teamMembersAdd\n * @arg {TeamMembersAddArg} arg - The request parameters.\n * @returns {Promise.<DropboxResponse<TeamMembersAddLaunch>, Error.<void>>}\n */\n\n\nroutes.teamMembersAdd = function (arg) {\n  return this.request('team/members/add', arg, 'team', 'api', 'rpc');\n};\n/**\n * Once an async_job_id is returned from members/add , use this to poll the\n * status of the asynchronous request. Permission : Team member management.\n * @function Dropbox#teamMembersAddJobStatusGet\n * @arg {AsyncPollArg} arg - The request parameters.\n * @returns {Promise.<DropboxResponse<TeamMembersAddJobStatus>, Error.<AsyncPollError>>}\n */\n\n\nroutes.teamMembersAddJobStatusGet = function (arg) {\n  return this.request('team/members/add/job_status/get', arg, 'team', 'api', 'rpc');\n};\n/**\n * Deletes a team member's profile photo. Permission : Team member management.\n * @function Dropbox#teamMembersDeleteProfilePhoto\n * @arg {TeamMembersDeleteProfilePhotoArg} arg - The request parameters.\n * @returns {Promise.<DropboxResponse<TeamTeamMemberInfo>, Error.<TeamMembersDeleteProfilePhotoError>>}\n */\n\n\nroutes.teamMembersDeleteProfilePhoto = function (arg) {\n  return this.request('team/members/delete_profile_photo', arg, 'team', 'api', 'rpc');\n};\n/**\n * Returns information about multiple team members. Permission : Team\n * information This endpoint will return MembersGetInfoItem.id_not_found, for\n * IDs (or emails) that cannot be matched to a valid team member.\n * @function Dropbox#teamMembersGetInfo\n * @arg {TeamMembersGetInfoArgs} arg - The request parameters.\n * @returns {Promise.<DropboxResponse<Object>, Error.<TeamMembersGetInfoError>>}\n */\n\n\nroutes.teamMembersGetInfo = function (arg) {\n  return this.request('team/members/get_info', arg, 'team', 'api', 'rpc');\n};\n/**\n * Lists members of a team. Permission : Team information.\n * @function Dropbox#teamMembersList\n * @arg {TeamMembersListArg} arg - The request parameters.\n * @returns {Promise.<DropboxResponse<TeamMembersListResult>, Error.<TeamMembersListError>>}\n */\n\n\nroutes.teamMembersList = function (arg) {\n  return this.request('team/members/list', arg, 'team', 'api', 'rpc');\n};\n/**\n * Once a cursor has been retrieved from members/list, use this to paginate\n * through all team members. Permission : Team information.\n * @function Dropbox#teamMembersListContinue\n * @arg {TeamMembersListContinueArg} arg - The request parameters.\n * @returns {Promise.<DropboxResponse<TeamMembersListResult>, Error.<TeamMembersListContinueError>>}\n */\n\n\nroutes.teamMembersListContinue = function (arg) {\n  return this.request('team/members/list/continue', arg, 'team', 'api', 'rpc');\n};\n/**\n * Moves removed member's files to a different member. This endpoint initiates\n * an asynchronous job. To obtain the final result of the job, the client should\n * periodically poll members/move_former_member_files/job_status/check.\n * Permission : Team member management.\n * @function Dropbox#teamMembersMoveFormerMemberFiles\n * @arg {TeamMembersDataTransferArg} arg - The request parameters.\n * @returns {Promise.<DropboxResponse<AsyncLaunchEmptyResult>, Error.<TeamMembersTransferFormerMembersFilesError>>}\n */\n\n\nroutes.teamMembersMoveFormerMemberFiles = function (arg) {\n  return this.request('team/members/move_former_member_files', arg, 'team', 'api', 'rpc');\n};\n/**\n * Once an async_job_id is returned from members/move_former_member_files , use\n * this to poll the status of the asynchronous request. Permission : Team member\n * management.\n * @function Dropbox#teamMembersMoveFormerMemberFilesJobStatusCheck\n * @arg {AsyncPollArg} arg - The request parameters.\n * @returns {Promise.<DropboxResponse<AsyncPollEmptyResult>, Error.<AsyncPollError>>}\n */\n\n\nroutes.teamMembersMoveFormerMemberFilesJobStatusCheck = function (arg) {\n  return this.request('team/members/move_former_member_files/job_status/check', arg, 'team', 'api', 'rpc');\n};\n/**\n * Recover a deleted member. Permission : Team member management Exactly one of\n * team_member_id, email, or external_id must be provided to identify the user\n * account.\n * @function Dropbox#teamMembersRecover\n * @arg {TeamMembersRecoverArg} arg - The request parameters.\n * @returns {Promise.<DropboxResponse<void>, Error.<TeamMembersRecoverError>>}\n */\n\n\nroutes.teamMembersRecover = function (arg) {\n  return this.request('team/members/recover', arg, 'team', 'api', 'rpc');\n};\n/**\n * Removes a member from a team. Permission : Team member management Exactly one\n * of team_member_id, email, or external_id must be provided to identify the\n * user account. Accounts can be recovered via members/recover for a 7 day\n * period or until the account has been permanently deleted or transferred to\n * another account (whichever comes first). Calling members/add while a user is\n * still recoverable on your team will return with\n * MemberAddResult.user_already_on_team. Accounts can have their files\n * transferred via the admin console for a limited time, based on the version\n * history length associated with the team (180 days for most teams). This\n * endpoint may initiate an asynchronous job. To obtain the final result of the\n * job, the client should periodically poll members/remove/job_status/get.\n * @function Dropbox#teamMembersRemove\n * @arg {TeamMembersRemoveArg} arg - The request parameters.\n * @returns {Promise.<DropboxResponse<AsyncLaunchEmptyResult>, Error.<TeamMembersRemoveError>>}\n */\n\n\nroutes.teamMembersRemove = function (arg) {\n  return this.request('team/members/remove', arg, 'team', 'api', 'rpc');\n};\n/**\n * Once an async_job_id is returned from members/remove , use this to poll the\n * status of the asynchronous request. Permission : Team member management.\n * @function Dropbox#teamMembersRemoveJobStatusGet\n * @arg {AsyncPollArg} arg - The request parameters.\n * @returns {Promise.<DropboxResponse<AsyncPollEmptyResult>, Error.<AsyncPollError>>}\n */\n\n\nroutes.teamMembersRemoveJobStatusGet = function (arg) {\n  return this.request('team/members/remove/job_status/get', arg, 'team', 'api', 'rpc');\n};\n/**\n * Add secondary emails to users. Permission : Team member management. Emails\n * that are on verified domains will be verified automatically. For each email\n * address not on a verified domain a verification email will be sent.\n * @function Dropbox#teamMembersSecondaryEmailsAdd\n * @arg {TeamAddSecondaryEmailsArg} arg - The request parameters.\n * @returns {Promise.<DropboxResponse<TeamAddSecondaryEmailsResult>, Error.<TeamAddSecondaryEmailsError>>}\n */\n\n\nroutes.teamMembersSecondaryEmailsAdd = function (arg) {\n  return this.request('team/members/secondary_emails/add', arg, 'team', 'api', 'rpc');\n};\n/**\n * Delete secondary emails from users Permission : Team member management. Users\n * will be notified of deletions of verified secondary emails at both the\n * secondary email and their primary email.\n * @function Dropbox#teamMembersSecondaryEmailsDelete\n * @arg {TeamDeleteSecondaryEmailsArg} arg - The request parameters.\n * @returns {Promise.<DropboxResponse<TeamDeleteSecondaryEmailsResult>, Error.<void>>}\n */\n\n\nroutes.teamMembersSecondaryEmailsDelete = function (arg) {\n  return this.request('team/members/secondary_emails/delete', arg, 'team', 'api', 'rpc');\n};\n/**\n * Resend secondary email verification emails. Permission : Team member\n * management.\n * @function Dropbox#teamMembersSecondaryEmailsResendVerificationEmails\n * @arg {TeamResendVerificationEmailArg} arg - The request parameters.\n * @returns {Promise.<DropboxResponse<TeamResendVerificationEmailResult>, Error.<void>>}\n */\n\n\nroutes.teamMembersSecondaryEmailsResendVerificationEmails = function (arg) {\n  return this.request('team/members/secondary_emails/resend_verification_emails', arg, 'team', 'api', 'rpc');\n};\n/**\n * Sends welcome email to pending team member. Permission : Team member\n * management Exactly one of team_member_id, email, or external_id must be\n * provided to identify the user account. No-op if team member is not pending.\n * @function Dropbox#teamMembersSendWelcomeEmail\n * @arg {TeamUserSelectorArg} arg - The request parameters.\n * @returns {Promise.<DropboxResponse<void>, Error.<TeamMembersSendWelcomeError>>}\n */\n\n\nroutes.teamMembersSendWelcomeEmail = function (arg) {\n  return this.request('team/members/send_welcome_email', arg, 'team', 'api', 'rpc');\n};\n/**\n * Updates a team member's permissions. Permission : Team member management.\n * @function Dropbox#teamMembersSetAdminPermissions\n * @arg {TeamMembersSetPermissionsArg} arg - The request parameters.\n * @returns {Promise.<DropboxResponse<TeamMembersSetPermissionsResult>, Error.<TeamMembersSetPermissionsError>>}\n */\n\n\nroutes.teamMembersSetAdminPermissions = function (arg) {\n  return this.request('team/members/set_admin_permissions', arg, 'team', 'api', 'rpc');\n};\n/**\n * Updates a team member's profile. Permission : Team member management.\n * @function Dropbox#teamMembersSetProfile\n * @arg {TeamMembersSetProfileArg} arg - The request parameters.\n * @returns {Promise.<DropboxResponse<TeamTeamMemberInfo>, Error.<TeamMembersSetProfileError>>}\n */\n\n\nroutes.teamMembersSetProfile = function (arg) {\n  return this.request('team/members/set_profile', arg, 'team', 'api', 'rpc');\n};\n/**\n * Updates a team member's profile photo. Permission : Team member management.\n * @function Dropbox#teamMembersSetProfilePhoto\n * @arg {TeamMembersSetProfilePhotoArg} arg - The request parameters.\n * @returns {Promise.<DropboxResponse<TeamTeamMemberInfo>, Error.<TeamMembersSetProfilePhotoError>>}\n */\n\n\nroutes.teamMembersSetProfilePhoto = function (arg) {\n  return this.request('team/members/set_profile_photo', arg, 'team', 'api', 'rpc');\n};\n/**\n * Suspend a member from a team. Permission : Team member management Exactly one\n * of team_member_id, email, or external_id must be provided to identify the\n * user account.\n * @function Dropbox#teamMembersSuspend\n * @arg {TeamMembersDeactivateArg} arg - The request parameters.\n * @returns {Promise.<DropboxResponse<void>, Error.<TeamMembersSuspendError>>}\n */\n\n\nroutes.teamMembersSuspend = function (arg) {\n  return this.request('team/members/suspend', arg, 'team', 'api', 'rpc');\n};\n/**\n * Unsuspend a member from a team. Permission : Team member management Exactly\n * one of team_member_id, email, or external_id must be provided to identify the\n * user account.\n * @function Dropbox#teamMembersUnsuspend\n * @arg {TeamMembersUnsuspendArg} arg - The request parameters.\n * @returns {Promise.<DropboxResponse<void>, Error.<TeamMembersUnsuspendError>>}\n */\n\n\nroutes.teamMembersUnsuspend = function (arg) {\n  return this.request('team/members/unsuspend', arg, 'team', 'api', 'rpc');\n};\n/**\n * Returns a list of all team-accessible namespaces. This list includes team\n * folders, shared folders containing team members, team members' home\n * namespaces, and team members' app folders. Home namespaces and app folders\n * are always owned by this team or members of the team, but shared folders may\n * be owned by other users or other teams. Duplicates may occur in the list.\n * @function Dropbox#teamNamespacesList\n * @arg {TeamTeamNamespacesListArg} arg - The request parameters.\n * @returns {Promise.<DropboxResponse<TeamTeamNamespacesListResult>, Error.<TeamTeamNamespacesListError>>}\n */\n\n\nroutes.teamNamespacesList = function (arg) {\n  return this.request('team/namespaces/list', arg, 'team', 'api', 'rpc');\n};\n/**\n * Once a cursor has been retrieved from namespaces/list, use this to paginate\n * through all team-accessible namespaces. Duplicates may occur in the list.\n * @function Dropbox#teamNamespacesListContinue\n * @arg {TeamTeamNamespacesListContinueArg} arg - The request parameters.\n * @returns {Promise.<DropboxResponse<TeamTeamNamespacesListResult>, Error.<TeamTeamNamespacesListContinueError>>}\n */\n\n\nroutes.teamNamespacesListContinue = function (arg) {\n  return this.request('team/namespaces/list/continue', arg, 'team', 'api', 'rpc');\n};\n/**\n * Permission : Team member file access.\n * @function Dropbox#teamPropertiesTemplateAdd\n * @deprecated\n * @arg {FilePropertiesAddTemplateArg} arg - The request parameters.\n * @returns {Promise.<DropboxResponse<FilePropertiesAddTemplateResult>, Error.<FilePropertiesModifyTemplateError>>}\n */\n\n\nroutes.teamPropertiesTemplateAdd = function (arg) {\n  return this.request('team/properties/template/add', arg, 'team', 'api', 'rpc');\n};\n/**\n * Permission : Team member file access.\n * @function Dropbox#teamPropertiesTemplateGet\n * @deprecated\n * @arg {FilePropertiesGetTemplateArg} arg - The request parameters.\n * @returns {Promise.<DropboxResponse<FilePropertiesGetTemplateResult>, Error.<FilePropertiesTemplateError>>}\n */\n\n\nroutes.teamPropertiesTemplateGet = function (arg) {\n  return this.request('team/properties/template/get', arg, 'team', 'api', 'rpc');\n};\n/**\n * Permission : Team member file access.\n * @function Dropbox#teamPropertiesTemplateList\n * @deprecated\n * @returns {Promise.<DropboxResponse<FilePropertiesListTemplateResult>, Error.<FilePropertiesTemplateError>>}\n */\n\n\nroutes.teamPropertiesTemplateList = function () {\n  return this.request('team/properties/template/list', null, 'team', 'api', 'rpc');\n};\n/**\n * Permission : Team member file access.\n * @function Dropbox#teamPropertiesTemplateUpdate\n * @deprecated\n * @arg {FilePropertiesUpdateTemplateArg} arg - The request parameters.\n * @returns {Promise.<DropboxResponse<FilePropertiesUpdateTemplateResult>, Error.<FilePropertiesModifyTemplateError>>}\n */\n\n\nroutes.teamPropertiesTemplateUpdate = function (arg) {\n  return this.request('team/properties/template/update', arg, 'team', 'api', 'rpc');\n};\n/**\n * Retrieves reporting data about a team's user activity.\n * @function Dropbox#teamReportsGetActivity\n * @deprecated\n * @arg {TeamDateRange} arg - The request parameters.\n * @returns {Promise.<DropboxResponse<TeamGetActivityReport>, Error.<TeamDateRangeError>>}\n */\n\n\nroutes.teamReportsGetActivity = function (arg) {\n  return this.request('team/reports/get_activity', arg, 'team', 'api', 'rpc');\n};\n/**\n * Retrieves reporting data about a team's linked devices.\n * @function Dropbox#teamReportsGetDevices\n * @deprecated\n * @arg {TeamDateRange} arg - The request parameters.\n * @returns {Promise.<DropboxResponse<TeamGetDevicesReport>, Error.<TeamDateRangeError>>}\n */\n\n\nroutes.teamReportsGetDevices = function (arg) {\n  return this.request('team/reports/get_devices', arg, 'team', 'api', 'rpc');\n};\n/**\n * Retrieves reporting data about a team's membership.\n * @function Dropbox#teamReportsGetMembership\n * @deprecated\n * @arg {TeamDateRange} arg - The request parameters.\n * @returns {Promise.<DropboxResponse<TeamGetMembershipReport>, Error.<TeamDateRangeError>>}\n */\n\n\nroutes.teamReportsGetMembership = function (arg) {\n  return this.request('team/reports/get_membership', arg, 'team', 'api', 'rpc');\n};\n/**\n * Retrieves reporting data about a team's storage usage.\n * @function Dropbox#teamReportsGetStorage\n * @deprecated\n * @arg {TeamDateRange} arg - The request parameters.\n * @returns {Promise.<DropboxResponse<TeamGetStorageReport>, Error.<TeamDateRangeError>>}\n */\n\n\nroutes.teamReportsGetStorage = function (arg) {\n  return this.request('team/reports/get_storage', arg, 'team', 'api', 'rpc');\n};\n/**\n * Sets an archived team folder's status to active. Permission : Team member\n * file access.\n * @function Dropbox#teamTeamFolderActivate\n * @arg {TeamTeamFolderIdArg} arg - The request parameters.\n * @returns {Promise.<DropboxResponse<TeamTeamFolderMetadata>, Error.<TeamTeamFolderActivateError>>}\n */\n\n\nroutes.teamTeamFolderActivate = function (arg) {\n  return this.request('team/team_folder/activate', arg, 'team', 'api', 'rpc');\n};\n/**\n * Sets an active team folder's status to archived and removes all folder and\n * file members. Permission : Team member file access.\n * @function Dropbox#teamTeamFolderArchive\n * @arg {TeamTeamFolderArchiveArg} arg - The request parameters.\n * @returns {Promise.<DropboxResponse<TeamTeamFolderArchiveLaunch>, Error.<TeamTeamFolderArchiveError>>}\n */\n\n\nroutes.teamTeamFolderArchive = function (arg) {\n  return this.request('team/team_folder/archive', arg, 'team', 'api', 'rpc');\n};\n/**\n * Returns the status of an asynchronous job for archiving a team folder.\n * Permission : Team member file access.\n * @function Dropbox#teamTeamFolderArchiveCheck\n * @arg {AsyncPollArg} arg - The request parameters.\n * @returns {Promise.<DropboxResponse<TeamTeamFolderArchiveJobStatus>, Error.<AsyncPollError>>}\n */\n\n\nroutes.teamTeamFolderArchiveCheck = function (arg) {\n  return this.request('team/team_folder/archive/check', arg, 'team', 'api', 'rpc');\n};\n/**\n * Creates a new, active, team folder with no members. Permission : Team member\n * file access.\n * @function Dropbox#teamTeamFolderCreate\n * @arg {TeamTeamFolderCreateArg} arg - The request parameters.\n * @returns {Promise.<DropboxResponse<TeamTeamFolderMetadata>, Error.<TeamTeamFolderCreateError>>}\n */\n\n\nroutes.teamTeamFolderCreate = function (arg) {\n  return this.request('team/team_folder/create', arg, 'team', 'api', 'rpc');\n};\n/**\n * Retrieves metadata for team folders. Permission : Team member file access.\n * @function Dropbox#teamTeamFolderGetInfo\n * @arg {TeamTeamFolderIdListArg} arg - The request parameters.\n * @returns {Promise.<DropboxResponse<Array.<TeamTeamFolderGetInfoItem>>, Error.<void>>}\n */\n\n\nroutes.teamTeamFolderGetInfo = function (arg) {\n  return this.request('team/team_folder/get_info', arg, 'team', 'api', 'rpc');\n};\n/**\n * Lists all team folders. Permission : Team member file access.\n * @function Dropbox#teamTeamFolderList\n * @arg {TeamTeamFolderListArg} arg - The request parameters.\n * @returns {Promise.<DropboxResponse<TeamTeamFolderListResult>, Error.<TeamTeamFolderListError>>}\n */\n\n\nroutes.teamTeamFolderList = function (arg) {\n  return this.request('team/team_folder/list', arg, 'team', 'api', 'rpc');\n};\n/**\n * Once a cursor has been retrieved from team_folder/list, use this to paginate\n * through all team folders. Permission : Team member file access.\n * @function Dropbox#teamTeamFolderListContinue\n * @arg {TeamTeamFolderListContinueArg} arg - The request parameters.\n * @returns {Promise.<DropboxResponse<TeamTeamFolderListResult>, Error.<TeamTeamFolderListContinueError>>}\n */\n\n\nroutes.teamTeamFolderListContinue = function (arg) {\n  return this.request('team/team_folder/list/continue', arg, 'team', 'api', 'rpc');\n};\n/**\n * Permanently deletes an archived team folder. Permission : Team member file\n * access.\n * @function Dropbox#teamTeamFolderPermanentlyDelete\n * @arg {TeamTeamFolderIdArg} arg - The request parameters.\n * @returns {Promise.<DropboxResponse<void>, Error.<TeamTeamFolderPermanentlyDeleteError>>}\n */\n\n\nroutes.teamTeamFolderPermanentlyDelete = function (arg) {\n  return this.request('team/team_folder/permanently_delete', arg, 'team', 'api', 'rpc');\n};\n/**\n * Changes an active team folder's name. Permission : Team member file access.\n * @function Dropbox#teamTeamFolderRename\n * @arg {TeamTeamFolderRenameArg} arg - The request parameters.\n * @returns {Promise.<DropboxResponse<TeamTeamFolderMetadata>, Error.<TeamTeamFolderRenameError>>}\n */\n\n\nroutes.teamTeamFolderRename = function (arg) {\n  return this.request('team/team_folder/rename', arg, 'team', 'api', 'rpc');\n};\n/**\n * Updates the sync settings on a team folder or its contents.  Use of this\n * endpoint requires that the team has team selective sync enabled.\n * @function Dropbox#teamTeamFolderUpdateSyncSettings\n * @arg {TeamTeamFolderUpdateSyncSettingsArg} arg - The request parameters.\n * @returns {Promise.<DropboxResponse<TeamTeamFolderMetadata>, Error.<TeamTeamFolderUpdateSyncSettingsError>>}\n */\n\n\nroutes.teamTeamFolderUpdateSyncSettings = function (arg) {\n  return this.request('team/team_folder/update_sync_settings', arg, 'team', 'api', 'rpc');\n};\n/**\n * Returns the member profile of the admin who generated the team access token\n * used to make the call.\n * @function Dropbox#teamTokenGetAuthenticatedAdmin\n * @returns {Promise.<DropboxResponse<TeamTokenGetAuthenticatedAdminResult>, Error.<TeamTokenGetAuthenticatedAdminError>>}\n */\n\n\nroutes.teamTokenGetAuthenticatedAdmin = function () {\n  return this.request('team/token/get_authenticated_admin', null, 'team', 'api', 'rpc');\n};\n/**\n * Retrieves team events. If the result's GetTeamEventsResult.has_more field is\n * true, call get_events/continue with the returned cursor to retrieve more\n * entries. If end_time is not specified in your request, you may use the\n * returned cursor to poll get_events/continue for new events. Many attributes\n * note 'may be missing due to historical data gap'. Note that the\n * file_operations category and & analogous paper events are not available on\n * all Dropbox Business plans /business/plans-comparison. Use\n * features/get_values\n * /developers/documentation/http/teams#team-features-get_values to check for\n * this feature. Permission : Team Auditing.\n * @function Dropbox#teamLogGetEvents\n * @arg {TeamLogGetTeamEventsArg} arg - The request parameters.\n * @returns {Promise.<DropboxResponse<TeamLogGetTeamEventsResult>, Error.<TeamLogGetTeamEventsError>>}\n */\n\n\nroutes.teamLogGetEvents = function (arg) {\n  return this.request('team_log/get_events', arg, 'team', 'api', 'rpc');\n};\n/**\n * Once a cursor has been retrieved from get_events, use this to paginate\n * through all events. Permission : Team Auditing.\n * @function Dropbox#teamLogGetEventsContinue\n * @arg {TeamLogGetTeamEventsContinueArg} arg - The request parameters.\n * @returns {Promise.<DropboxResponse<TeamLogGetTeamEventsResult>, Error.<TeamLogGetTeamEventsContinueError>>}\n */\n\n\nroutes.teamLogGetEventsContinue = function (arg) {\n  return this.request('team_log/get_events/continue', arg, 'team', 'api', 'rpc');\n};\n/**\n * Get a list of feature values that may be configured for the current account.\n * @function Dropbox#usersFeaturesGetValues\n * @arg {UsersUserFeaturesGetValuesBatchArg} arg - The request parameters.\n * @returns {Promise.<DropboxResponse<UsersUserFeaturesGetValuesBatchResult>, Error.<UsersUserFeaturesGetValuesBatchError>>}\n */\n\n\nroutes.usersFeaturesGetValues = function (arg) {\n  return this.request('users/features/get_values', arg, 'user', 'api', 'rpc');\n};\n/**\n * Get information about a user's account.\n * @function Dropbox#usersGetAccount\n * @arg {UsersGetAccountArg} arg - The request parameters.\n * @returns {Promise.<DropboxResponse<UsersBasicAccount>, Error.<UsersGetAccountError>>}\n */\n\n\nroutes.usersGetAccount = function (arg) {\n  return this.request('users/get_account', arg, 'user', 'api', 'rpc');\n};\n/**\n * Get information about multiple user accounts.  At most 300 accounts may be\n * queried per request.\n * @function Dropbox#usersGetAccountBatch\n * @arg {UsersGetAccountBatchArg} arg - The request parameters.\n * @returns {Promise.<DropboxResponse<Object>, Error.<UsersGetAccountBatchError>>}\n */\n\n\nroutes.usersGetAccountBatch = function (arg) {\n  return this.request('users/get_account_batch', arg, 'user', 'api', 'rpc');\n};\n/**\n * Get information about the current user's account.\n * @function Dropbox#usersGetCurrentAccount\n * @returns {Promise.<DropboxResponse<UsersFullAccount>, Error.<void>>}\n */\n\n\nroutes.usersGetCurrentAccount = function () {\n  return this.request('users/get_current_account', null, 'user', 'api', 'rpc');\n};\n/**\n * Get the space usage information for the current user's account.\n * @function Dropbox#usersGetSpaceUsage\n * @returns {Promise.<DropboxResponse<UsersSpaceUsage>, Error.<void>>}\n */\n\n\nroutes.usersGetSpaceUsage = function () {\n  return this.request('users/get_space_usage', null, 'user', 'api', 'rpc');\n};\n\nexports.routes = routes;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = undefined;\n\nvar _utils = require(\"./utils.js\");\n\nvar _response = require(\"./response.js\");\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nvar fetch;\n\nif (typeof window !== 'undefined') {\n  fetch = window.fetch.bind(window);\n} else {\n  fetch = require('node-fetch'); // eslint-disable-line global-require\n}\n\nvar crypto;\n\nif (typeof window !== 'undefined') {\n  crypto = window.crypto || window.msCrypto; // for IE11\n} else {\n  crypto = require('crypto'); // eslint-disable-line global-require\n} // Expiration is 300 seconds but needs to be in milliseconds for Date object\n\n\nvar TokenExpirationBuffer = 300 * 1000;\nvar PKCELength = 128;\nvar TokenAccessTypes = ['legacy', 'offline', 'online'];\nvar GrantTypes = ['code', 'token'];\nvar IncludeGrantedScopes = ['none', 'user', 'team'];\nvar BaseAuthorizeUrl = 'https://www.dropbox.com/oauth2/authorize';\nvar BaseTokenUrl = 'https://api.dropboxapi.com/oauth2/token';\n/**\n * @class DropboxAuth\n * @classdesc The DropboxAuth class that provides methods to manage, acquire, and refresh tokens.\n * @arg {Object} options\n * @arg {Function} [options.fetch] - fetch library for making requests.\n * @arg {String} [options.accessToken] - An access token for making authenticated\n * requests.\n * @arg {Date} [options.AccessTokenExpiresAt] - Date of the current access token's\n * expiration (if available)\n * @arg {String} [options.refreshToken] - A refresh token for retrieving access tokens\n * @arg {String} [options.clientId] - The client id for your app. Used to create\n * authentication URL.\n * @arg {String} [options.clientSecret] - The client secret for your app. Used to create\n * authentication URL and refresh access tokens.\n */\n\nvar DropboxAuth = /*#__PURE__*/function () {\n  function DropboxAuth(options) {\n    _classCallCheck(this, DropboxAuth);\n\n    options = options || {};\n    this.fetch = options.fetch || fetch;\n    this.accessToken = options.accessToken;\n    this.accessTokenExpiresAt = options.accessTokenExpiresAt;\n    this.refreshToken = options.refreshToken;\n    this.clientId = options.clientId;\n    this.clientSecret = options.clientSecret;\n  }\n  /**\n   * Set the access token used to authenticate requests to the API.\n   * @arg {String} accessToken - An access token\n   * @returns {undefined}\n   */\n\n\n  _createClass(DropboxAuth, [{\n    key: \"setAccessToken\",\n    value: function setAccessToken(accessToken) {\n      this.accessToken = accessToken;\n    }\n    /**\n     * Get the access token\n     * @returns {String} Access token\n     */\n\n  }, {\n    key: \"getAccessToken\",\n    value: function getAccessToken() {\n      return this.accessToken;\n    }\n    /**\n     * Set the client id, which is used to help gain an access token.\n     * @arg {String} clientId - Your apps client id\n     * @returns {undefined}\n     */\n\n  }, {\n    key: \"setClientId\",\n    value: function setClientId(clientId) {\n      this.clientId = clientId;\n    }\n    /**\n     * Get the client id\n     * @returns {String} Client id\n     */\n\n  }, {\n    key: \"getClientId\",\n    value: function getClientId() {\n      return this.clientId;\n    }\n    /**\n     * Set the client secret\n     * @arg {String} clientSecret - Your app's client secret\n     * @returns {undefined}\n     */\n\n  }, {\n    key: \"setClientSecret\",\n    value: function setClientSecret(clientSecret) {\n      this.clientSecret = clientSecret;\n    }\n    /**\n     * Get the client secret\n     * @returns {String} Client secret\n     */\n\n  }, {\n    key: \"getClientSecret\",\n    value: function getClientSecret() {\n      return this.clientSecret;\n    }\n    /**\n     * Gets the refresh token\n     * @returns {String} Refresh token\n     */\n\n  }, {\n    key: \"getRefreshToken\",\n    value: function getRefreshToken() {\n      return this.refreshToken;\n    }\n    /**\n     * Sets the refresh token\n     * @param refreshToken - A refresh token\n     */\n\n  }, {\n    key: \"setRefreshToken\",\n    value: function setRefreshToken(refreshToken) {\n      this.refreshToken = refreshToken;\n    }\n    /**\n     * Gets the access token's expiration date\n     * @returns {Date} date of token expiration\n     */\n\n  }, {\n    key: \"getAccessTokenExpiresAt\",\n    value: function getAccessTokenExpiresAt() {\n      return this.accessTokenExpiresAt;\n    }\n    /**\n     * Sets the access token's expiration date\n     * @param accessTokenExpiresAt - new expiration date\n     */\n\n  }, {\n    key: \"setAccessTokenExpiresAt\",\n    value: function setAccessTokenExpiresAt(accessTokenExpiresAt) {\n      this.accessTokenExpiresAt = accessTokenExpiresAt;\n    }\n  }, {\n    key: \"generatePKCECodes\",\n    value: function generatePKCECodes() {\n      var codeVerifier = crypto.randomBytes(PKCELength);\n      codeVerifier = codeVerifier.toString('base64').replace(/\\+/g, '-').replace(/\\//g, '_').replace(/=/g, '').substr(0, 128);\n      this.codeVerifier = codeVerifier;\n      var encoder = new TextEncoder();\n      var codeData = encoder.encode(codeVerifier);\n      var codeChallenge = crypto.createHash('sha256').update(codeData).digest();\n      codeChallenge = codeChallenge.toString('base64').replace(/\\+/g, '-').replace(/\\//g, '_').replace(/=/g, '');\n      this.codeChallenge = codeChallenge;\n    }\n    /**\n     * Get a URL that can be used to authenticate users for the Dropbox API.\n     * @arg {String} redirectUri - A URL to redirect the user to after\n     * authenticating. This must be added to your app through the admin interface.\n     * @arg {String} [state] - State that will be returned in the redirect URL to help\n     * prevent cross site scripting attacks.\n     * @arg {String} [authType] - auth type, defaults to 'token', other option is 'code'\n     * @arg {String} [tokenAccessType] - type of token to request.  From the following:\n     * null - creates a token with the app default (either legacy or online)\n     * legacy - creates one long-lived token with no expiration\n     * online - create one short-lived token with an expiration\n     * offline - create one short-lived token with an expiration with a refresh token\n     * @arg {Array<String>} [scope] - scopes to request for the grant\n     * @arg {String} [includeGrantedScopes] - whether or not to include previously granted scopes.\n     * From the following:\n     * user - include user scopes in the grant\n     * team - include team scopes in the grant\n     * Note: if this user has never linked the app, include_granted_scopes must be None\n     * @arg {boolean} [usePKCE] - Whether or not to use Sha256 based PKCE. PKCE should be only use on\n     * client apps which doesn't call your server. It is less secure than non-PKCE flow but\n     * can be used if you are unable to safely retrieve your app secret\n     * @returns {String} Url to send user to for Dropbox API authentication\n     */\n\n  }, {\n    key: \"getAuthenticationUrl\",\n    value: function getAuthenticationUrl(redirectUri, state) {\n      var authType = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'token';\n      var tokenAccessType = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n      var scope = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;\n      var includeGrantedScopes = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 'none';\n      var usePKCE = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : false;\n      var clientId = this.getClientId();\n      var baseUrl = BaseAuthorizeUrl;\n\n      if (!clientId) {\n        throw new Error('A client id is required. You can set the client id using .setClientId().');\n      }\n\n      if (authType !== 'code' && !redirectUri) {\n        throw new Error('A redirect uri is required.');\n      }\n\n      if (!GrantTypes.includes(authType)) {\n        throw new Error('Authorization type must be code or token');\n      }\n\n      if (tokenAccessType && !TokenAccessTypes.includes(tokenAccessType)) {\n        throw new Error('Token Access Type must be legacy, offline, or online');\n      }\n\n      if (scope && !(scope instanceof Array)) {\n        throw new Error('Scope must be an array of strings');\n      }\n\n      if (!IncludeGrantedScopes.includes(includeGrantedScopes)) {\n        throw new Error('includeGrantedScopes must be none, user, or team');\n      }\n\n      var authUrl;\n\n      if (authType === 'code') {\n        authUrl = \"\".concat(baseUrl, \"?response_type=code&client_id=\").concat(clientId);\n      } else {\n        authUrl = \"\".concat(baseUrl, \"?response_type=token&client_id=\").concat(clientId);\n      }\n\n      if (redirectUri) {\n        authUrl += \"&redirect_uri=\".concat(redirectUri);\n      }\n\n      if (state) {\n        authUrl += \"&state=\".concat(state);\n      }\n\n      if (tokenAccessType) {\n        authUrl += \"&token_access_type=\".concat(tokenAccessType);\n      }\n\n      if (scope) {\n        authUrl += \"&scope=\".concat(scope.join(' '));\n      }\n\n      if (includeGrantedScopes !== 'none') {\n        authUrl += \"&include_granted_scopes=\".concat(includeGrantedScopes);\n      }\n\n      if (usePKCE) {\n        this.generatePKCECodes();\n        authUrl += '&code_challenge_method=S256';\n        authUrl += \"&code_challenge=\".concat(this.codeChallenge);\n      }\n\n      return authUrl;\n    }\n    /**\n     * Get an OAuth2 access token from an OAuth2 Code.\n     * @arg {String} redirectUri - A URL to redirect the user to after\n     * authenticating. This must be added to your app through the admin interface.\n     * @arg {String} code - An OAuth2 code.\n    */\n\n  }, {\n    key: \"getAccessTokenFromCode\",\n    value: function getAccessTokenFromCode(redirectUri, code) {\n      var clientId = this.getClientId();\n      var clientSecret = this.getClientSecret();\n\n      if (!clientId) {\n        throw new Error('A client id is required. You can set the client id using .setClientId().');\n      }\n\n      var path = BaseTokenUrl;\n      path += '?grant_type=authorization_code';\n      path += \"&code=\".concat(code);\n      path += \"&client_id=\".concat(clientId);\n\n      if (clientSecret) {\n        path += \"&client_secret=\".concat(clientSecret);\n      } else {\n        if (!this.codeChallenge) {\n          throw new Error('You must use PKCE when generating the authorization URL to not include a client secret');\n        }\n\n        path += \"&code_verifier=\".concat(this.codeVerifier);\n      }\n\n      if (redirectUri) {\n        path += \"&redirect_uri=\".concat(redirectUri);\n      }\n\n      var fetchOptions = {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/x-www-form-urlencoded'\n        }\n      };\n      return this.fetch(path, fetchOptions).then(function (res) {\n        return (0, _response.parseResponse)(res);\n      });\n    }\n    /**\n     * Checks if a token is needed, can be refreshed and if the token is expired.\n     * If so, attempts to refresh access token\n     * @returns {Promise<*>}\n     */\n\n  }, {\n    key: \"checkAndRefreshAccessToken\",\n    value: function checkAndRefreshAccessToken() {\n      var canRefresh = this.getRefreshToken() && this.getClientId();\n      var needsRefresh = this.getAccessTokenExpiresAt() && new Date(Date.now() + TokenExpirationBuffer) >= this.getAccessTokenExpiresAt();\n      var needsToken = !this.getAccessToken();\n\n      if ((needsRefresh || needsToken) && canRefresh) {\n        return this.refreshAccessToken();\n      }\n\n      return Promise.resolve();\n    }\n    /**\n     * Refreshes the access token using the refresh token, if available\n     * @arg {Array<String>} scope - a subset of scopes from the original\n     * refresh to acquire with an access token\n     * @returns {Promise<*>}\n     */\n\n  }, {\n    key: \"refreshAccessToken\",\n    value: function refreshAccessToken() {\n      var _this = this;\n\n      var scope = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n      var refreshUrl = BaseTokenUrl;\n      var clientId = this.getClientId();\n      var clientSecret = this.getClientSecret();\n\n      if (!clientId) {\n        throw new Error('A client id is required. You can set the client id using .setClientId().');\n      }\n\n      if (scope && !(scope instanceof Array)) {\n        throw new Error('Scope must be an array of strings');\n      }\n\n      var headers = {};\n      headers['Content-Type'] = 'application/json';\n      refreshUrl += \"?grant_type=refresh_token&refresh_token=\".concat(this.getRefreshToken());\n      refreshUrl += \"&client_id=\".concat(clientId);\n\n      if (clientSecret) {\n        refreshUrl += \"&client_secret=\".concat(clientSecret);\n      }\n\n      if (scope) {\n        refreshUrl += \"&scope=\".concat(scope.join(' '));\n      }\n\n      var fetchOptions = {\n        method: 'POST'\n      };\n      fetchOptions.headers = headers;\n      return this.fetch(refreshUrl, fetchOptions).then(function (res) {\n        return (0, _response.parseResponse)(res);\n      }).then(function (res) {\n        _this.setAccessToken(res.result.access_token);\n\n        _this.setAccessTokenExpiresAt((0, _utils.getTokenExpiresAtDate)(res.result.expires_in));\n      });\n    }\n    /**\n     * An authentication process that works with cordova applications.\n     * @param {successCallback} successCallback\n     * @param {errorCallback} errorCallback\n     */\n\n  }, {\n    key: \"authenticateWithCordova\",\n    value: function authenticateWithCordova(successCallback, errorCallback) {\n      var redirectUrl = 'https://www.dropbox.com/1/oauth2/redirect_receiver';\n      var url = this.getAuthenticationUrl(redirectUrl);\n      var removed = false;\n      var browser = window.open(url, '_blank');\n\n      function onLoadError(event) {\n        if (event.code !== -999) {\n          // Workaround to fix wrong behavior on cordova-plugin-inappbrowser\n          // Try to avoid a browser crash on browser.close().\n          window.setTimeout(function () {\n            browser.close();\n          }, 10);\n          errorCallback();\n        }\n      }\n\n      function onLoadStop(event) {\n        var errorLabel = '&error=';\n        var errorIndex = event.url.indexOf(errorLabel);\n\n        if (errorIndex > -1) {\n          // Try to avoid a browser crash on browser.close().\n          window.setTimeout(function () {\n            browser.close();\n          }, 10);\n          errorCallback();\n        } else {\n          var tokenLabel = '#access_token=';\n          var tokenIndex = event.url.indexOf(tokenLabel);\n          var tokenTypeIndex = event.url.indexOf('&token_type=');\n\n          if (tokenIndex > -1) {\n            tokenIndex += tokenLabel.length; // Try to avoid a browser crash on browser.close().\n\n            window.setTimeout(function () {\n              browser.close();\n            }, 10);\n            var accessToken = event.url.substring(tokenIndex, tokenTypeIndex);\n            successCallback(accessToken);\n          }\n        }\n      }\n\n      function onExit() {\n        if (removed) {\n          return;\n        }\n\n        browser.removeEventListener('loaderror', onLoadError);\n        browser.removeEventListener('loadstop', onLoadStop);\n        browser.removeEventListener('exit', onExit);\n        removed = true;\n      }\n\n      browser.addEventListener('loaderror', onLoadError);\n      browser.addEventListener('loadstop', onLoadStop);\n      browser.addEventListener('exit', onExit);\n    }\n  }]);\n\n  return DropboxAuth;\n}();\n\nexports[\"default\"] = DropboxAuth;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar RPC = exports.RPC = 'rpc';\nvar UPLOAD = exports.UPLOAD = 'upload';\nvar DOWNLOAD = exports.DOWNLOAD = 'download';\nvar APP_AUTH = exports.APP_AUTH = 'app';\nvar USER_AUTH = exports.USER_AUTH = 'user';\nvar TEAM_AUTH = exports.TEAM_AUTH = 'team';\nvar NO_AUTH = exports.NO_AUTH = 'noauth';","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = undefined;\n\nvar _constants = require(\"./constants.js\");\n\nvar _routes = require(\"../lib/routes.js\");\n\nvar _auth = require(\"./auth.js\");\n\nvar _utils = require(\"./utils.js\");\n\nvar _response = require(\"./response.js\");\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nvar fetch;\n\nif (typeof window !== 'undefined') {\n  fetch = window.fetch.bind(window);\n} else {\n  fetch = require('node-fetch'); // eslint-disable-line global-require\n}\n\nvar b64 = typeof btoa === 'undefined' ? function (str) {\n  return Buffer.from(str).toString('base64');\n} : btoa;\n/**\n * @class Dropbox\n * @classdesc The Dropbox SDK class that provides methods to read, write and\n * create files or folders in a user or team's Dropbox.\n * @arg {Object} options\n * @arg {Function} [options.fetch] - fetch library for making requests.\n * @arg {String} [options.selectUser] - Select user is only used for team functionality.\n * It specifies which user the team access token should be acting as.\n * @arg {String} [options.pathRoot] - root path to access other namespaces\n * Use to access team folders for example\n * @arg {String} [options.selectAdmin] - Select admin is only used by team functionality.\n * It specifies which team admin the team access token should be acting as.\n * @arg {DropboxAuth} [options.auth] - The DropboxAuth object used to authenticate requests.\n * If this is set, the remaining parameters will be ignored.\n * @arg {String} [options.accessToken] - An access token for making authenticated\n * requests.\n * @arg {Date} [options.AccessTokenExpiresAt] - Date of the current access token's\n * expiration (if available)\n * @arg {String} [options.refreshToken] - A refresh token for retrieving access tokens\n * @arg {String} [options.clientId] - The client id for your app. Used to create\n * authentication URL.\n * @arg {String} [options.clientSecret] - The client secret for your app. Used to create\n * authentication URL and refresh access tokens.\n */\n\nvar Dropbox = /*#__PURE__*/function () {\n  function Dropbox(options) {\n    _classCallCheck(this, Dropbox);\n\n    options = options || {};\n\n    if (options.auth) {\n      this.auth = options.auth;\n    } else {\n      this.auth = new _auth[\"default\"](options);\n    }\n\n    this.fetch = options.fetch || fetch;\n    this.selectUser = options.selectUser;\n    this.selectAdmin = options.selectAdmin;\n    this.pathRoot = options.pathRoot;\n    Object.assign(this, _routes.routes);\n  }\n\n  _createClass(Dropbox, [{\n    key: \"request\",\n    value: function request(path, args, auth, host, style) {\n      switch (style) {\n        case _constants.RPC:\n          return this.rpcRequest(path, args, auth, host);\n\n        case _constants.DOWNLOAD:\n          return this.downloadRequest(path, args, auth, host);\n\n        case _constants.UPLOAD:\n          return this.uploadRequest(path, args, auth, host);\n\n        default:\n          throw new Error(\"Invalid request style: \".concat(style));\n      }\n    }\n  }, {\n    key: \"rpcRequest\",\n    value: function rpcRequest(path, body, auth, host) {\n      var _this = this;\n\n      return this.auth.checkAndRefreshAccessToken().then(function () {\n        var fetchOptions = {\n          method: 'POST',\n          body: body ? JSON.stringify(body) : null,\n          headers: {}\n        };\n\n        if (body) {\n          fetchOptions.headers['Content-Type'] = 'application/json';\n        }\n\n        var authHeader;\n\n        switch (auth) {\n          case _constants.APP_AUTH:\n            if (!_this.auth.clientId || !_this.auth.clientSecret) {\n              throw new Error('A client id and secret is required for this function');\n            }\n\n            authHeader = b64(\"\".concat(_this.auth.clientId, \":\").concat(_this.auth.clientSecret));\n            fetchOptions.headers.Authorization = \"Basic \".concat(authHeader);\n            break;\n\n          case _constants.TEAM_AUTH:\n          case _constants.USER_AUTH:\n            fetchOptions.headers.Authorization = \"Bearer \".concat(_this.auth.getAccessToken());\n            break;\n\n          case _constants.NO_AUTH:\n            break;\n\n          default:\n            throw new Error(\"Unhandled auth type: \".concat(auth));\n        }\n\n        _this.setCommonHeaders(fetchOptions);\n\n        return fetchOptions;\n      }).then(function (fetchOptions) {\n        return _this.fetch((0, _utils.getBaseURL)(host) + path, fetchOptions);\n      }).then(function (res) {\n        return (0, _response.parseResponse)(res);\n      });\n    }\n  }, {\n    key: \"downloadRequest\",\n    value: function downloadRequest(path, args, auth, host) {\n      var _this2 = this;\n\n      return this.auth.checkAndRefreshAccessToken().then(function () {\n        if (auth !== _constants.USER_AUTH) {\n          throw new Error(\"Unexpected auth type: \".concat(auth));\n        }\n\n        var fetchOptions = {\n          method: 'POST',\n          headers: {\n            Authorization: \"Bearer \".concat(_this2.auth.getAccessToken()),\n            'Dropbox-API-Arg': (0, _utils.httpHeaderSafeJson)(args)\n          }\n        };\n\n        _this2.setCommonHeaders(fetchOptions);\n\n        return fetchOptions;\n      }).then(function (fetchOptions) {\n        return fetch((0, _utils.getBaseURL)(host) + path, fetchOptions);\n      }).then(function (res) {\n        return (0, _response.parseDownloadResponse)(res);\n      });\n    }\n  }, {\n    key: \"uploadRequest\",\n    value: function uploadRequest(path, args, auth, host) {\n      var _this3 = this;\n\n      return this.auth.checkAndRefreshAccessToken().then(function () {\n        if (auth !== _constants.USER_AUTH) {\n          throw new Error(\"Unexpected auth type: \".concat(auth));\n        }\n\n        var contents = args.contents;\n        delete args.contents;\n        var fetchOptions = {\n          body: contents,\n          method: 'POST',\n          headers: {\n            Authorization: \"Bearer \".concat(_this3.auth.getAccessToken()),\n            'Content-Type': 'application/octet-stream',\n            'Dropbox-API-Arg': (0, _utils.httpHeaderSafeJson)(args)\n          }\n        };\n\n        _this3.setCommonHeaders(fetchOptions);\n\n        return fetchOptions;\n      }).then(function (fetchOptions) {\n        return _this3.fetch((0, _utils.getBaseURL)(host) + path, fetchOptions);\n      }).then(function (res) {\n        return (0, _response.parseResponse)(res);\n      });\n    }\n  }, {\n    key: \"setCommonHeaders\",\n    value: function setCommonHeaders(options) {\n      if (this.selectUser) {\n        options.headers['Dropbox-API-Select-User'] = this.selectUser;\n      }\n\n      if (this.selectAdmin) {\n        options.headers['Dropbox-API-Select-Admin'] = this.selectAdmin;\n      }\n\n      if (this.pathRoot) {\n        options.headers['Dropbox-API-Path-Root'] = this.pathRoot;\n      }\n    }\n  }]);\n\n  return Dropbox;\n}();\n\nexports[\"default\"] = Dropbox;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _wrapNativeSuper(Class) { var _cache = typeof Map === \"function\" ? new Map() : undefined; _wrapNativeSuper = function _wrapNativeSuper(Class) { if (Class === null || !_isNativeFunction(Class)) return Class; if (typeof Class !== \"function\") { throw new TypeError(\"Super expression must either be null or a function\"); } if (typeof _cache !== \"undefined\") { if (_cache.has(Class)) return _cache.get(Class); _cache.set(Class, Wrapper); } function Wrapper() { return _construct(Class, arguments, _getPrototypeOf(this).constructor); } Wrapper.prototype = Object.create(Class.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } }); return _setPrototypeOf(Wrapper, Class); }; return _wrapNativeSuper(Class); }\n\nfunction _construct(Parent, args, Class) { if (_isNativeReflectConstruct()) { _construct = Reflect.construct; } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _isNativeFunction(fn) { return Function.toString.call(fn).indexOf(\"[native code]\") !== -1; }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\n/**\n * The response class of HTTP errors from API calls using the Dropbox SDK.\n */\nvar DropboxResponseError = /*#__PURE__*/exports.DropboxResponseError = function (_Error) {\n  _inherits(DropboxResponseError, _Error);\n\n  var _super = _createSuper(DropboxResponseError);\n\n  function DropboxResponseError(status, headers, error) {\n    var _this;\n\n    _classCallCheck(this, DropboxResponseError);\n\n    _this = _super.call(this, \"Response failed with a \".concat(status, \" code\"));\n    _this.name = 'DropboxResponseError';\n    _this.status = status;\n    _this.headers = headers;\n    _this.error = error;\n    return _this;\n  }\n\n  return DropboxResponseError;\n}( /*#__PURE__*/_wrapNativeSuper(Error));","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.DropboxResponse = undefined;\nexports.parseResponse = parseResponse;\nexports.parseDownloadResponse = parseDownloadResponse;\n\nvar _utils = require(\"./utils.js\");\n\nvar _error = require(\"./error.js\");\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar DropboxResponse = exports.DropboxResponse = function DropboxResponse(status, headers, result) {\n  _classCallCheck(this, DropboxResponse);\n\n  this.status = status;\n  this.headers = headers;\n  this.result = result;\n};\n\nfunction throwAsError(res) {\n  return res.text().then(function (data) {\n    var errorObject;\n\n    try {\n      errorObject = JSON.parse(data);\n    } catch (error) {\n      errorObject = data;\n    }\n\n    throw new _error.DropboxResponseError(res.status, res.headers, errorObject);\n  });\n}\n\nfunction parseResponse(res) {\n  if (!res.ok) {\n    return throwAsError(res);\n  }\n\n  return res.text().then(function (data) {\n    var responseObject;\n\n    try {\n      responseObject = JSON.parse(data);\n    } catch (error) {\n      responseObject = data;\n    }\n\n    return new DropboxResponse(res.status, res.headers, responseObject);\n  });\n}\n\nfunction parseDownloadResponse(res) {\n  if (!res.ok) {\n    return throwAsError(res);\n  }\n\n  return new Promise(function (resolve) {\n    if ((0, _utils.isWindowOrWorker)()) {\n      res.blob().then(function (data) {\n        return resolve(data);\n      });\n    } else {\n      res.buffer().then(function (data) {\n        return resolve(data);\n      });\n    }\n  }).then(function (data) {\n    var result = JSON.parse(res.headers.get('dropbox-api-result'));\n\n    if ((0, _utils.isWindowOrWorker)()) {\n      result.fileBlob = data;\n    } else {\n      result.fileBinary = data;\n    }\n\n    return new DropboxResponse(res.status, res.headers, result);\n  });\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getBaseURL = getBaseURL;\nexports.httpHeaderSafeJson = httpHeaderSafeJson;\nexports.getTokenExpiresAtDate = getTokenExpiresAtDate;\nexports.isWindowOrWorker = isWindowOrWorker;\n\nfunction getSafeUnicode(c) {\n  var unicode = \"000\".concat(c.charCodeAt(0).toString(16)).slice(-4);\n  return \"\\\\u\".concat(unicode);\n}\n\nfunction getBaseURL(host) {\n  return \"https://\".concat(host, \".dropboxapi.com/2/\");\n} // source https://www.dropboxforum.com/t5/API-support/HTTP-header-quot-Dropbox-API-Arg-quot-could-not-decode-input-as/m-p/173823/highlight/true#M6786\n\n\nfunction httpHeaderSafeJson(args) {\n  return JSON.stringify(args).replace(/[\\u007f-\\uffff]/g, getSafeUnicode);\n}\n\nfunction getTokenExpiresAtDate(expiresIn) {\n  return new Date(Date.now() + expiresIn * 1000);\n}\n/* global WorkerGlobalScope */\n\n\nfunction isWindowOrWorker() {\n  return typeof WorkerGlobalScope !== 'undefined' && self instanceof WorkerGlobalScope // eslint-disable-line no-restricted-globals\n  || typeof module === 'undefined' || typeof window !== 'undefined';\n}","\"use strict\";\r\nconst taskManager = require(\"./managers/tasks\");\r\nconst async_1 = require(\"./providers/async\");\r\nconst stream_1 = require(\"./providers/stream\");\r\nconst sync_1 = require(\"./providers/sync\");\r\nconst settings_1 = require(\"./settings\");\r\nconst utils = require(\"./utils\");\r\nasync function FastGlob(source, options) {\r\n    assertPatternsInput(source);\r\n    const works = getWorks(source, async_1.default, options);\r\n    const result = await Promise.all(works);\r\n    return utils.array.flatten(result);\r\n}\r\n// https://github.com/typescript-eslint/typescript-eslint/issues/60\r\n// eslint-disable-next-line no-redeclare\r\n(function (FastGlob) {\r\n    function sync(source, options) {\r\n        assertPatternsInput(source);\r\n        const works = getWorks(source, sync_1.default, options);\r\n        return utils.array.flatten(works);\r\n    }\r\n    FastGlob.sync = sync;\r\n    function stream(source, options) {\r\n        assertPatternsInput(source);\r\n        const works = getWorks(source, stream_1.default, options);\r\n        /**\r\n         * The stream returned by the provider cannot work with an asynchronous iterator.\r\n         * To support asynchronous iterators, regardless of the number of tasks, we always multiplex streams.\r\n         * This affects performance (+25%). I don't see best solution right now.\r\n         */\r\n        return utils.stream.merge(works);\r\n    }\r\n    FastGlob.stream = stream;\r\n    function generateTasks(source, options) {\r\n        assertPatternsInput(source);\r\n        const patterns = [].concat(source);\r\n        const settings = new settings_1.default(options);\r\n        return taskManager.generate(patterns, settings);\r\n    }\r\n    FastGlob.generateTasks = generateTasks;\r\n    function isDynamicPattern(source, options) {\r\n        assertPatternsInput(source);\r\n        const settings = new settings_1.default(options);\r\n        return utils.pattern.isDynamicPattern(source, settings);\r\n    }\r\n    FastGlob.isDynamicPattern = isDynamicPattern;\r\n    function escapePath(source) {\r\n        assertPatternsInput(source);\r\n        return utils.path.escape(source);\r\n    }\r\n    FastGlob.escapePath = escapePath;\r\n})(FastGlob || (FastGlob = {}));\r\nfunction getWorks(source, _Provider, options) {\r\n    const patterns = [].concat(source);\r\n    const settings = new settings_1.default(options);\r\n    const tasks = taskManager.generate(patterns, settings);\r\n    const provider = new _Provider(settings);\r\n    return tasks.map(provider.read, provider);\r\n}\r\nfunction assertPatternsInput(input) {\r\n    const source = [].concat(input);\r\n    const isValidSource = source.every((item) => utils.string.isString(item) && !utils.string.isEmpty(item));\r\n    if (!isValidSource) {\r\n        throw new TypeError('Patterns must be a string (non empty) or an array of strings');\r\n    }\r\n}\r\nmodule.exports = FastGlob;\r\n","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.convertPatternGroupToTask = exports.convertPatternGroupsToTasks = exports.groupPatternsByBaseDirectory = exports.getNegativePatternsAsPositive = exports.getPositivePatterns = exports.convertPatternsToTasks = exports.generate = void 0;\r\nconst utils = require(\"../utils\");\r\nfunction generate(patterns, settings) {\r\n    const positivePatterns = getPositivePatterns(patterns);\r\n    const negativePatterns = getNegativePatternsAsPositive(patterns, settings.ignore);\r\n    const staticPatterns = positivePatterns.filter((pattern) => utils.pattern.isStaticPattern(pattern, settings));\r\n    const dynamicPatterns = positivePatterns.filter((pattern) => utils.pattern.isDynamicPattern(pattern, settings));\r\n    const staticTasks = convertPatternsToTasks(staticPatterns, negativePatterns, /* dynamic */ false);\r\n    const dynamicTasks = convertPatternsToTasks(dynamicPatterns, negativePatterns, /* dynamic */ true);\r\n    return staticTasks.concat(dynamicTasks);\r\n}\r\nexports.generate = generate;\r\nfunction convertPatternsToTasks(positive, negative, dynamic) {\r\n    const positivePatternsGroup = groupPatternsByBaseDirectory(positive);\r\n    // When we have a global group  there is no reason to divide the patterns into independent tasks.\r\n    // In this case, the global task covers the rest.\r\n    if ('.' in positivePatternsGroup) {\r\n        const task = convertPatternGroupToTask('.', positive, negative, dynamic);\r\n        return [task];\r\n    }\r\n    return convertPatternGroupsToTasks(positivePatternsGroup, negative, dynamic);\r\n}\r\nexports.convertPatternsToTasks = convertPatternsToTasks;\r\nfunction getPositivePatterns(patterns) {\r\n    return utils.pattern.getPositivePatterns(patterns);\r\n}\r\nexports.getPositivePatterns = getPositivePatterns;\r\nfunction getNegativePatternsAsPositive(patterns, ignore) {\r\n    const negative = utils.pattern.getNegativePatterns(patterns).concat(ignore);\r\n    const positive = negative.map(utils.pattern.convertToPositivePattern);\r\n    return positive;\r\n}\r\nexports.getNegativePatternsAsPositive = getNegativePatternsAsPositive;\r\nfunction groupPatternsByBaseDirectory(patterns) {\r\n    const group = {};\r\n    return patterns.reduce((collection, pattern) => {\r\n        const base = utils.pattern.getBaseDirectory(pattern);\r\n        if (base in collection) {\r\n            collection[base].push(pattern);\r\n        }\r\n        else {\r\n            collection[base] = [pattern];\r\n        }\r\n        return collection;\r\n    }, group);\r\n}\r\nexports.groupPatternsByBaseDirectory = groupPatternsByBaseDirectory;\r\nfunction convertPatternGroupsToTasks(positive, negative, dynamic) {\r\n    return Object.keys(positive).map((base) => {\r\n        return convertPatternGroupToTask(base, positive[base], negative, dynamic);\r\n    });\r\n}\r\nexports.convertPatternGroupsToTasks = convertPatternGroupsToTasks;\r\nfunction convertPatternGroupToTask(base, positive, negative, dynamic) {\r\n    return {\r\n        dynamic,\r\n        positive,\r\n        negative,\r\n        base,\r\n        patterns: [].concat(positive, negative.map(utils.pattern.convertToNegativePattern))\r\n    };\r\n}\r\nexports.convertPatternGroupToTask = convertPatternGroupToTask;\r\n","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst stream_1 = require(\"../readers/stream\");\r\nconst provider_1 = require(\"./provider\");\r\nclass ProviderAsync extends provider_1.default {\r\n    constructor() {\r\n        super(...arguments);\r\n        this._reader = new stream_1.default(this._settings);\r\n    }\r\n    read(task) {\r\n        const root = this._getRootDirectory(task);\r\n        const options = this._getReaderOptions(task);\r\n        const entries = [];\r\n        return new Promise((resolve, reject) => {\r\n            const stream = this.api(root, task, options);\r\n            stream.once('error', reject);\r\n            stream.on('data', (entry) => entries.push(options.transform(entry)));\r\n            stream.once('end', () => resolve(entries));\r\n        });\r\n    }\r\n    api(root, task, options) {\r\n        if (task.dynamic) {\r\n            return this._reader.dynamic(root, options);\r\n        }\r\n        return this._reader.static(task.patterns, options);\r\n    }\r\n}\r\nexports.default = ProviderAsync;\r\n","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst utils = require(\"../../utils\");\r\nconst partial_1 = require(\"../matchers/partial\");\r\nclass DeepFilter {\r\n    constructor(_settings, _micromatchOptions) {\r\n        this._settings = _settings;\r\n        this._micromatchOptions = _micromatchOptions;\r\n    }\r\n    getFilter(basePath, positive, negative) {\r\n        const matcher = this._getMatcher(positive);\r\n        const negativeRe = this._getNegativePatternsRe(negative);\r\n        return (entry) => this._filter(basePath, entry, matcher, negativeRe);\r\n    }\r\n    _getMatcher(patterns) {\r\n        return new partial_1.default(patterns, this._settings, this._micromatchOptions);\r\n    }\r\n    _getNegativePatternsRe(patterns) {\r\n        const affectDepthOfReadingPatterns = patterns.filter(utils.pattern.isAffectDepthOfReadingPattern);\r\n        return utils.pattern.convertPatternsToRe(affectDepthOfReadingPatterns, this._micromatchOptions);\r\n    }\r\n    _filter(basePath, entry, matcher, negativeRe) {\r\n        if (this._isSkippedByDeep(basePath, entry.path)) {\r\n            return false;\r\n        }\r\n        if (this._isSkippedSymbolicLink(entry)) {\r\n            return false;\r\n        }\r\n        const filepath = utils.path.removeLeadingDotSegment(entry.path);\r\n        if (this._isSkippedByPositivePatterns(filepath, matcher)) {\r\n            return false;\r\n        }\r\n        return this._isSkippedByNegativePatterns(filepath, negativeRe);\r\n    }\r\n    _isSkippedByDeep(basePath, entryPath) {\r\n        /**\r\n         * Avoid unnecessary depth calculations when it doesn't matter.\r\n         */\r\n        if (this._settings.deep === Infinity) {\r\n            return false;\r\n        }\r\n        return this._getEntryLevel(basePath, entryPath) >= this._settings.deep;\r\n    }\r\n    _getEntryLevel(basePath, entryPath) {\r\n        const entryPathDepth = entryPath.split('/').length;\r\n        if (basePath === '') {\r\n            return entryPathDepth;\r\n        }\r\n        const basePathDepth = basePath.split('/').length;\r\n        return entryPathDepth - basePathDepth;\r\n    }\r\n    _isSkippedSymbolicLink(entry) {\r\n        return !this._settings.followSymbolicLinks && entry.dirent.isSymbolicLink();\r\n    }\r\n    _isSkippedByPositivePatterns(entryPath, matcher) {\r\n        return !this._settings.baseNameMatch && !matcher.match(entryPath);\r\n    }\r\n    _isSkippedByNegativePatterns(entryPath, patternsRe) {\r\n        return !utils.pattern.matchAny(entryPath, patternsRe);\r\n    }\r\n}\r\nexports.default = DeepFilter;\r\n","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst utils = require(\"../../utils\");\r\nclass EntryFilter {\r\n    constructor(_settings, _micromatchOptions) {\r\n        this._settings = _settings;\r\n        this._micromatchOptions = _micromatchOptions;\r\n        this.index = new Map();\r\n    }\r\n    getFilter(positive, negative) {\r\n        const positiveRe = utils.pattern.convertPatternsToRe(positive, this._micromatchOptions);\r\n        const negativeRe = utils.pattern.convertPatternsToRe(negative, this._micromatchOptions);\r\n        return (entry) => this._filter(entry, positiveRe, negativeRe);\r\n    }\r\n    _filter(entry, positiveRe, negativeRe) {\r\n        if (this._settings.unique && this._isDuplicateEntry(entry)) {\r\n            return false;\r\n        }\r\n        if (this._onlyFileFilter(entry) || this._onlyDirectoryFilter(entry)) {\r\n            return false;\r\n        }\r\n        if (this._isSkippedByAbsoluteNegativePatterns(entry.path, negativeRe)) {\r\n            return false;\r\n        }\r\n        const filepath = this._settings.baseNameMatch ? entry.name : entry.path;\r\n        const isMatched = this._isMatchToPatterns(filepath, positiveRe) && !this._isMatchToPatterns(entry.path, negativeRe);\r\n        if (this._settings.unique && isMatched) {\r\n            this._createIndexRecord(entry);\r\n        }\r\n        return isMatched;\r\n    }\r\n    _isDuplicateEntry(entry) {\r\n        return this.index.has(entry.path);\r\n    }\r\n    _createIndexRecord(entry) {\r\n        this.index.set(entry.path, undefined);\r\n    }\r\n    _onlyFileFilter(entry) {\r\n        return this._settings.onlyFiles && !entry.dirent.isFile();\r\n    }\r\n    _onlyDirectoryFilter(entry) {\r\n        return this._settings.onlyDirectories && !entry.dirent.isDirectory();\r\n    }\r\n    _isSkippedByAbsoluteNegativePatterns(entryPath, patternsRe) {\r\n        if (!this._settings.absolute) {\r\n            return false;\r\n        }\r\n        const fullpath = utils.path.makeAbsolute(this._settings.cwd, entryPath);\r\n        return utils.pattern.matchAny(fullpath, patternsRe);\r\n    }\r\n    _isMatchToPatterns(entryPath, patternsRe) {\r\n        const filepath = utils.path.removeLeadingDotSegment(entryPath);\r\n        return utils.pattern.matchAny(filepath, patternsRe);\r\n    }\r\n}\r\nexports.default = EntryFilter;\r\n","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst utils = require(\"../../utils\");\r\nclass ErrorFilter {\r\n    constructor(_settings) {\r\n        this._settings = _settings;\r\n    }\r\n    getFilter() {\r\n        return (error) => this._isNonFatalError(error);\r\n    }\r\n    _isNonFatalError(error) {\r\n        return utils.errno.isEnoentCodeError(error) || this._settings.suppressErrors;\r\n    }\r\n}\r\nexports.default = ErrorFilter;\r\n","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst utils = require(\"../../utils\");\r\nclass Matcher {\r\n    constructor(_patterns, _settings, _micromatchOptions) {\r\n        this._patterns = _patterns;\r\n        this._settings = _settings;\r\n        this._micromatchOptions = _micromatchOptions;\r\n        this._storage = [];\r\n        this._fillStorage();\r\n    }\r\n    _fillStorage() {\r\n        /**\r\n         * The original pattern may include `{,*,**,a/*}`, which will lead to problems with matching (unresolved level).\r\n         * So, before expand patterns with brace expansion into separated patterns.\r\n         */\r\n        const patterns = utils.pattern.expandPatternsWithBraceExpansion(this._patterns);\r\n        for (const pattern of patterns) {\r\n            const segments = this._getPatternSegments(pattern);\r\n            const sections = this._splitSegmentsIntoSections(segments);\r\n            this._storage.push({\r\n                complete: sections.length <= 1,\r\n                pattern,\r\n                segments,\r\n                sections\r\n            });\r\n        }\r\n    }\r\n    _getPatternSegments(pattern) {\r\n        const parts = utils.pattern.getPatternParts(pattern, this._micromatchOptions);\r\n        return parts.map((part) => {\r\n            const dynamic = utils.pattern.isDynamicPattern(part, this._settings);\r\n            if (!dynamic) {\r\n                return {\r\n                    dynamic: false,\r\n                    pattern: part\r\n                };\r\n            }\r\n            return {\r\n                dynamic: true,\r\n                pattern: part,\r\n                patternRe: utils.pattern.makeRe(part, this._micromatchOptions)\r\n            };\r\n        });\r\n    }\r\n    _splitSegmentsIntoSections(segments) {\r\n        return utils.array.splitWhen(segments, (segment) => segment.dynamic && utils.pattern.hasGlobStar(segment.pattern));\r\n    }\r\n}\r\nexports.default = Matcher;\r\n","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst matcher_1 = require(\"./matcher\");\r\nclass PartialMatcher extends matcher_1.default {\r\n    match(filepath) {\r\n        const parts = filepath.split('/');\r\n        const levels = parts.length;\r\n        const patterns = this._storage.filter((info) => !info.complete || info.segments.length > levels);\r\n        for (const pattern of patterns) {\r\n            const section = pattern.sections[0];\r\n            /**\r\n             * In this case, the pattern has a globstar and we must read all directories unconditionally,\r\n             * but only if the level has reached the end of the first group.\r\n             *\r\n             * fixtures/{a,b}/**\r\n             *  ^ true/false  ^ always true\r\n            */\r\n            if (!pattern.complete && levels > section.length) {\r\n                return true;\r\n            }\r\n            const match = parts.every((part, index) => {\r\n                const segment = pattern.segments[index];\r\n                if (segment.dynamic && segment.patternRe.test(part)) {\r\n                    return true;\r\n                }\r\n                if (!segment.dynamic && segment.pattern === part) {\r\n                    return true;\r\n                }\r\n                return false;\r\n            });\r\n            if (match) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n}\r\nexports.default = PartialMatcher;\r\n","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst path = require(\"path\");\r\nconst deep_1 = require(\"./filters/deep\");\r\nconst entry_1 = require(\"./filters/entry\");\r\nconst error_1 = require(\"./filters/error\");\r\nconst entry_2 = require(\"./transformers/entry\");\r\nclass Provider {\r\n    constructor(_settings) {\r\n        this._settings = _settings;\r\n        this.errorFilter = new error_1.default(this._settings);\r\n        this.entryFilter = new entry_1.default(this._settings, this._getMicromatchOptions());\r\n        this.deepFilter = new deep_1.default(this._settings, this._getMicromatchOptions());\r\n        this.entryTransformer = new entry_2.default(this._settings);\r\n    }\r\n    _getRootDirectory(task) {\r\n        return path.resolve(this._settings.cwd, task.base);\r\n    }\r\n    _getReaderOptions(task) {\r\n        const basePath = task.base === '.' ? '' : task.base;\r\n        return {\r\n            basePath,\r\n            pathSegmentSeparator: '/',\r\n            concurrency: this._settings.concurrency,\r\n            deepFilter: this.deepFilter.getFilter(basePath, task.positive, task.negative),\r\n            entryFilter: this.entryFilter.getFilter(task.positive, task.negative),\r\n            errorFilter: this.errorFilter.getFilter(),\r\n            followSymbolicLinks: this._settings.followSymbolicLinks,\r\n            fs: this._settings.fs,\r\n            stats: this._settings.stats,\r\n            throwErrorOnBrokenSymbolicLink: this._settings.throwErrorOnBrokenSymbolicLink,\r\n            transform: this.entryTransformer.getTransformer()\r\n        };\r\n    }\r\n    _getMicromatchOptions() {\r\n        return {\r\n            dot: this._settings.dot,\r\n            matchBase: this._settings.baseNameMatch,\r\n            nobrace: !this._settings.braceExpansion,\r\n            nocase: !this._settings.caseSensitiveMatch,\r\n            noext: !this._settings.extglob,\r\n            noglobstar: !this._settings.globstar,\r\n            posix: true,\r\n            strictSlashes: false\r\n        };\r\n    }\r\n}\r\nexports.default = Provider;\r\n","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst stream_1 = require(\"stream\");\r\nconst stream_2 = require(\"../readers/stream\");\r\nconst provider_1 = require(\"./provider\");\r\nclass ProviderStream extends provider_1.default {\r\n    constructor() {\r\n        super(...arguments);\r\n        this._reader = new stream_2.default(this._settings);\r\n    }\r\n    read(task) {\r\n        const root = this._getRootDirectory(task);\r\n        const options = this._getReaderOptions(task);\r\n        const source = this.api(root, task, options);\r\n        const destination = new stream_1.Readable({ objectMode: true, read: () => { } });\r\n        source\r\n            .once('error', (error) => destination.emit('error', error))\r\n            .on('data', (entry) => destination.emit('data', options.transform(entry)))\r\n            .once('end', () => destination.emit('end'));\r\n        destination\r\n            .once('close', () => source.destroy());\r\n        return destination;\r\n    }\r\n    api(root, task, options) {\r\n        if (task.dynamic) {\r\n            return this._reader.dynamic(root, options);\r\n        }\r\n        return this._reader.static(task.patterns, options);\r\n    }\r\n}\r\nexports.default = ProviderStream;\r\n","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst sync_1 = require(\"../readers/sync\");\r\nconst provider_1 = require(\"./provider\");\r\nclass ProviderSync extends provider_1.default {\r\n    constructor() {\r\n        super(...arguments);\r\n        this._reader = new sync_1.default(this._settings);\r\n    }\r\n    read(task) {\r\n        const root = this._getRootDirectory(task);\r\n        const options = this._getReaderOptions(task);\r\n        const entries = this.api(root, task, options);\r\n        return entries.map(options.transform);\r\n    }\r\n    api(root, task, options) {\r\n        if (task.dynamic) {\r\n            return this._reader.dynamic(root, options);\r\n        }\r\n        return this._reader.static(task.patterns, options);\r\n    }\r\n}\r\nexports.default = ProviderSync;\r\n","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst utils = require(\"../../utils\");\r\nclass EntryTransformer {\r\n    constructor(_settings) {\r\n        this._settings = _settings;\r\n    }\r\n    getTransformer() {\r\n        return (entry) => this._transform(entry);\r\n    }\r\n    _transform(entry) {\r\n        let filepath = entry.path;\r\n        if (this._settings.absolute) {\r\n            filepath = utils.path.makeAbsolute(this._settings.cwd, filepath);\r\n            filepath = utils.path.unixify(filepath);\r\n        }\r\n        if (this._settings.markDirectories && entry.dirent.isDirectory()) {\r\n            filepath += '/';\r\n        }\r\n        if (!this._settings.objectMode) {\r\n            return filepath;\r\n        }\r\n        return Object.assign(Object.assign({}, entry), { path: filepath });\r\n    }\r\n}\r\nexports.default = EntryTransformer;\r\n","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst path = require(\"path\");\r\nconst fsStat = require(\"@nodelib/fs.stat\");\r\nconst utils = require(\"../utils\");\r\nclass Reader {\r\n    constructor(_settings) {\r\n        this._settings = _settings;\r\n        this._fsStatSettings = new fsStat.Settings({\r\n            followSymbolicLink: this._settings.followSymbolicLinks,\r\n            fs: this._settings.fs,\r\n            throwErrorOnBrokenSymbolicLink: this._settings.followSymbolicLinks\r\n        });\r\n    }\r\n    _getFullEntryPath(filepath) {\r\n        return path.resolve(this._settings.cwd, filepath);\r\n    }\r\n    _makeEntry(stats, pattern) {\r\n        const entry = {\r\n            name: pattern,\r\n            path: pattern,\r\n            dirent: utils.fs.createDirentFromStats(pattern, stats)\r\n        };\r\n        if (this._settings.stats) {\r\n            entry.stats = stats;\r\n        }\r\n        return entry;\r\n    }\r\n    _isFatalError(error) {\r\n        return !utils.errno.isEnoentCodeError(error) && !this._settings.suppressErrors;\r\n    }\r\n}\r\nexports.default = Reader;\r\n","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst stream_1 = require(\"stream\");\r\nconst fsStat = require(\"@nodelib/fs.stat\");\r\nconst fsWalk = require(\"@nodelib/fs.walk\");\r\nconst reader_1 = require(\"./reader\");\r\nclass ReaderStream extends reader_1.default {\r\n    constructor() {\r\n        super(...arguments);\r\n        this._walkStream = fsWalk.walkStream;\r\n        this._stat = fsStat.stat;\r\n    }\r\n    dynamic(root, options) {\r\n        return this._walkStream(root, options);\r\n    }\r\n    static(patterns, options) {\r\n        const filepaths = patterns.map(this._getFullEntryPath, this);\r\n        const stream = new stream_1.PassThrough({ objectMode: true });\r\n        stream._write = (index, _enc, done) => {\r\n            return this._getEntry(filepaths[index], patterns[index], options)\r\n                .then((entry) => {\r\n                if (entry !== null && options.entryFilter(entry)) {\r\n                    stream.push(entry);\r\n                }\r\n                if (index === filepaths.length - 1) {\r\n                    stream.end();\r\n                }\r\n                done();\r\n            })\r\n                .catch(done);\r\n        };\r\n        for (let i = 0; i < filepaths.length; i++) {\r\n            stream.write(i);\r\n        }\r\n        return stream;\r\n    }\r\n    _getEntry(filepath, pattern, options) {\r\n        return this._getStat(filepath)\r\n            .then((stats) => this._makeEntry(stats, pattern))\r\n            .catch((error) => {\r\n            if (options.errorFilter(error)) {\r\n                return null;\r\n            }\r\n            throw error;\r\n        });\r\n    }\r\n    _getStat(filepath) {\r\n        return new Promise((resolve, reject) => {\r\n            this._stat(filepath, this._fsStatSettings, (error, stats) => {\r\n                return error === null ? resolve(stats) : reject(error);\r\n            });\r\n        });\r\n    }\r\n}\r\nexports.default = ReaderStream;\r\n","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst fsStat = require(\"@nodelib/fs.stat\");\r\nconst fsWalk = require(\"@nodelib/fs.walk\");\r\nconst reader_1 = require(\"./reader\");\r\nclass ReaderSync extends reader_1.default {\r\n    constructor() {\r\n        super(...arguments);\r\n        this._walkSync = fsWalk.walkSync;\r\n        this._statSync = fsStat.statSync;\r\n    }\r\n    dynamic(root, options) {\r\n        return this._walkSync(root, options);\r\n    }\r\n    static(patterns, options) {\r\n        const entries = [];\r\n        for (const pattern of patterns) {\r\n            const filepath = this._getFullEntryPath(pattern);\r\n            const entry = this._getEntry(filepath, pattern, options);\r\n            if (entry === null || !options.entryFilter(entry)) {\r\n                continue;\r\n            }\r\n            entries.push(entry);\r\n        }\r\n        return entries;\r\n    }\r\n    _getEntry(filepath, pattern, options) {\r\n        try {\r\n            const stats = this._getStat(filepath);\r\n            return this._makeEntry(stats, pattern);\r\n        }\r\n        catch (error) {\r\n            if (options.errorFilter(error)) {\r\n                return null;\r\n            }\r\n            throw error;\r\n        }\r\n    }\r\n    _getStat(filepath) {\r\n        return this._statSync(filepath, this._fsStatSettings);\r\n    }\r\n}\r\nexports.default = ReaderSync;\r\n","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.DEFAULT_FILE_SYSTEM_ADAPTER = void 0;\r\nconst fs = require(\"fs\");\r\nconst os = require(\"os\");\r\nconst CPU_COUNT = os.cpus().length;\r\nexports.DEFAULT_FILE_SYSTEM_ADAPTER = {\r\n    lstat: fs.lstat,\r\n    lstatSync: fs.lstatSync,\r\n    stat: fs.stat,\r\n    statSync: fs.statSync,\r\n    readdir: fs.readdir,\r\n    readdirSync: fs.readdirSync\r\n};\r\nclass Settings {\r\n    constructor(_options = {}) {\r\n        this._options = _options;\r\n        this.absolute = this._getValue(this._options.absolute, false);\r\n        this.baseNameMatch = this._getValue(this._options.baseNameMatch, false);\r\n        this.braceExpansion = this._getValue(this._options.braceExpansion, true);\r\n        this.caseSensitiveMatch = this._getValue(this._options.caseSensitiveMatch, true);\r\n        this.concurrency = this._getValue(this._options.concurrency, CPU_COUNT);\r\n        this.cwd = this._getValue(this._options.cwd, process.cwd());\r\n        this.deep = this._getValue(this._options.deep, Infinity);\r\n        this.dot = this._getValue(this._options.dot, false);\r\n        this.extglob = this._getValue(this._options.extglob, true);\r\n        this.followSymbolicLinks = this._getValue(this._options.followSymbolicLinks, true);\r\n        this.fs = this._getFileSystemMethods(this._options.fs);\r\n        this.globstar = this._getValue(this._options.globstar, true);\r\n        this.ignore = this._getValue(this._options.ignore, []);\r\n        this.markDirectories = this._getValue(this._options.markDirectories, false);\r\n        this.objectMode = this._getValue(this._options.objectMode, false);\r\n        this.onlyDirectories = this._getValue(this._options.onlyDirectories, false);\r\n        this.onlyFiles = this._getValue(this._options.onlyFiles, true);\r\n        this.stats = this._getValue(this._options.stats, false);\r\n        this.suppressErrors = this._getValue(this._options.suppressErrors, false);\r\n        this.throwErrorOnBrokenSymbolicLink = this._getValue(this._options.throwErrorOnBrokenSymbolicLink, false);\r\n        this.unique = this._getValue(this._options.unique, true);\r\n        if (this.onlyDirectories) {\r\n            this.onlyFiles = false;\r\n        }\r\n        if (this.stats) {\r\n            this.objectMode = true;\r\n        }\r\n    }\r\n    _getValue(option, value) {\r\n        return option === undefined ? value : option;\r\n    }\r\n    _getFileSystemMethods(methods = {}) {\r\n        return Object.assign(Object.assign({}, exports.DEFAULT_FILE_SYSTEM_ADAPTER), methods);\r\n    }\r\n}\r\nexports.default = Settings;\r\n","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.splitWhen = exports.flatten = void 0;\r\nfunction flatten(items) {\r\n    return items.reduce((collection, item) => [].concat(collection, item), []);\r\n}\r\nexports.flatten = flatten;\r\nfunction splitWhen(items, predicate) {\r\n    const result = [[]];\r\n    let groupIndex = 0;\r\n    for (const item of items) {\r\n        if (predicate(item)) {\r\n            groupIndex++;\r\n            result[groupIndex] = [];\r\n        }\r\n        else {\r\n            result[groupIndex].push(item);\r\n        }\r\n    }\r\n    return result;\r\n}\r\nexports.splitWhen = splitWhen;\r\n","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.isEnoentCodeError = void 0;\r\nfunction isEnoentCodeError(error) {\r\n    return error.code === 'ENOENT';\r\n}\r\nexports.isEnoentCodeError = isEnoentCodeError;\r\n","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.createDirentFromStats = void 0;\r\nclass DirentFromStats {\r\n    constructor(name, stats) {\r\n        this.name = name;\r\n        this.isBlockDevice = stats.isBlockDevice.bind(stats);\r\n        this.isCharacterDevice = stats.isCharacterDevice.bind(stats);\r\n        this.isDirectory = stats.isDirectory.bind(stats);\r\n        this.isFIFO = stats.isFIFO.bind(stats);\r\n        this.isFile = stats.isFile.bind(stats);\r\n        this.isSocket = stats.isSocket.bind(stats);\r\n        this.isSymbolicLink = stats.isSymbolicLink.bind(stats);\r\n    }\r\n}\r\nfunction createDirentFromStats(name, stats) {\r\n    return new DirentFromStats(name, stats);\r\n}\r\nexports.createDirentFromStats = createDirentFromStats;\r\n","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.string = exports.stream = exports.pattern = exports.path = exports.fs = exports.errno = exports.array = void 0;\r\nconst array = require(\"./array\");\r\nexports.array = array;\r\nconst errno = require(\"./errno\");\r\nexports.errno = errno;\r\nconst fs = require(\"./fs\");\r\nexports.fs = fs;\r\nconst path = require(\"./path\");\r\nexports.path = path;\r\nconst pattern = require(\"./pattern\");\r\nexports.pattern = pattern;\r\nconst stream = require(\"./stream\");\r\nexports.stream = stream;\r\nconst string = require(\"./string\");\r\nexports.string = string;\r\n","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.removeLeadingDotSegment = exports.escape = exports.makeAbsolute = exports.unixify = void 0;\r\nconst path = require(\"path\");\r\nconst LEADING_DOT_SEGMENT_CHARACTERS_COUNT = 2; // ./ or .\\\\\r\nconst UNESCAPED_GLOB_SYMBOLS_RE = /(\\\\?)([()*?[\\]{|}]|^!|[!+@](?=\\())/g;\r\n/**\r\n * Designed to work only with simple paths: `dir\\\\file`.\r\n */\r\nfunction unixify(filepath) {\r\n    return filepath.replace(/\\\\/g, '/');\r\n}\r\nexports.unixify = unixify;\r\nfunction makeAbsolute(cwd, filepath) {\r\n    return path.resolve(cwd, filepath);\r\n}\r\nexports.makeAbsolute = makeAbsolute;\r\nfunction escape(pattern) {\r\n    return pattern.replace(UNESCAPED_GLOB_SYMBOLS_RE, '\\\\$2');\r\n}\r\nexports.escape = escape;\r\nfunction removeLeadingDotSegment(entry) {\r\n    // We do not use `startsWith` because this is 10x slower than current implementation for some cases.\r\n    // eslint-disable-next-line @typescript-eslint/prefer-string-starts-ends-with\r\n    if (entry.charAt(0) === '.') {\r\n        const secondCharactery = entry.charAt(1);\r\n        if (secondCharactery === '/' || secondCharactery === '\\\\') {\r\n            return entry.slice(LEADING_DOT_SEGMENT_CHARACTERS_COUNT);\r\n        }\r\n    }\r\n    return entry;\r\n}\r\nexports.removeLeadingDotSegment = removeLeadingDotSegment;\r\n","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.matchAny = exports.convertPatternsToRe = exports.makeRe = exports.getPatternParts = exports.expandBraceExpansion = exports.expandPatternsWithBraceExpansion = exports.isAffectDepthOfReadingPattern = exports.endsWithSlashGlobStar = exports.hasGlobStar = exports.getBaseDirectory = exports.getPositivePatterns = exports.getNegativePatterns = exports.isPositivePattern = exports.isNegativePattern = exports.convertToNegativePattern = exports.convertToPositivePattern = exports.isDynamicPattern = exports.isStaticPattern = void 0;\r\nconst path = require(\"path\");\r\nconst globParent = require(\"glob-parent\");\r\nconst micromatch = require(\"micromatch\");\r\nconst picomatch = require(\"picomatch\");\r\nconst GLOBSTAR = '**';\r\nconst ESCAPE_SYMBOL = '\\\\';\r\nconst COMMON_GLOB_SYMBOLS_RE = /[*?]|^!/;\r\nconst REGEX_CHARACTER_CLASS_SYMBOLS_RE = /\\[.*]/;\r\nconst REGEX_GROUP_SYMBOLS_RE = /(?:^|[^!*+?@])\\(.*\\|.*\\)/;\r\nconst GLOB_EXTENSION_SYMBOLS_RE = /[!*+?@]\\(.*\\)/;\r\nconst BRACE_EXPANSIONS_SYMBOLS_RE = /{.*(?:,|\\.\\.).*}/;\r\nfunction isStaticPattern(pattern, options = {}) {\r\n    return !isDynamicPattern(pattern, options);\r\n}\r\nexports.isStaticPattern = isStaticPattern;\r\nfunction isDynamicPattern(pattern, options = {}) {\r\n    /**\r\n     * A special case with an empty string is necessary for matching patterns that start with a forward slash.\r\n     * An empty string cannot be a dynamic pattern.\r\n     * For example, the pattern `/lib/*` will be spread into parts: '', 'lib', '*'.\r\n     */\r\n    if (pattern === '') {\r\n        return false;\r\n    }\r\n    /**\r\n     * When the `caseSensitiveMatch` option is disabled, all patterns must be marked as dynamic, because we cannot check\r\n     * filepath directly (without read directory).\r\n     */\r\n    if (options.caseSensitiveMatch === false || pattern.includes(ESCAPE_SYMBOL)) {\r\n        return true;\r\n    }\r\n    if (COMMON_GLOB_SYMBOLS_RE.test(pattern) || REGEX_CHARACTER_CLASS_SYMBOLS_RE.test(pattern) || REGEX_GROUP_SYMBOLS_RE.test(pattern)) {\r\n        return true;\r\n    }\r\n    if (options.extglob !== false && GLOB_EXTENSION_SYMBOLS_RE.test(pattern)) {\r\n        return true;\r\n    }\r\n    if (options.braceExpansion !== false && BRACE_EXPANSIONS_SYMBOLS_RE.test(pattern)) {\r\n        return true;\r\n    }\r\n    return false;\r\n}\r\nexports.isDynamicPattern = isDynamicPattern;\r\nfunction convertToPositivePattern(pattern) {\r\n    return isNegativePattern(pattern) ? pattern.slice(1) : pattern;\r\n}\r\nexports.convertToPositivePattern = convertToPositivePattern;\r\nfunction convertToNegativePattern(pattern) {\r\n    return '!' + pattern;\r\n}\r\nexports.convertToNegativePattern = convertToNegativePattern;\r\nfunction isNegativePattern(pattern) {\r\n    return pattern.startsWith('!') && pattern[1] !== '(';\r\n}\r\nexports.isNegativePattern = isNegativePattern;\r\nfunction isPositivePattern(pattern) {\r\n    return !isNegativePattern(pattern);\r\n}\r\nexports.isPositivePattern = isPositivePattern;\r\nfunction getNegativePatterns(patterns) {\r\n    return patterns.filter(isNegativePattern);\r\n}\r\nexports.getNegativePatterns = getNegativePatterns;\r\nfunction getPositivePatterns(patterns) {\r\n    return patterns.filter(isPositivePattern);\r\n}\r\nexports.getPositivePatterns = getPositivePatterns;\r\nfunction getBaseDirectory(pattern) {\r\n    return globParent(pattern, { flipBackslashes: false });\r\n}\r\nexports.getBaseDirectory = getBaseDirectory;\r\nfunction hasGlobStar(pattern) {\r\n    return pattern.includes(GLOBSTAR);\r\n}\r\nexports.hasGlobStar = hasGlobStar;\r\nfunction endsWithSlashGlobStar(pattern) {\r\n    return pattern.endsWith('/' + GLOBSTAR);\r\n}\r\nexports.endsWithSlashGlobStar = endsWithSlashGlobStar;\r\nfunction isAffectDepthOfReadingPattern(pattern) {\r\n    const basename = path.basename(pattern);\r\n    return endsWithSlashGlobStar(pattern) || isStaticPattern(basename);\r\n}\r\nexports.isAffectDepthOfReadingPattern = isAffectDepthOfReadingPattern;\r\nfunction expandPatternsWithBraceExpansion(patterns) {\r\n    return patterns.reduce((collection, pattern) => {\r\n        return collection.concat(expandBraceExpansion(pattern));\r\n    }, []);\r\n}\r\nexports.expandPatternsWithBraceExpansion = expandPatternsWithBraceExpansion;\r\nfunction expandBraceExpansion(pattern) {\r\n    return micromatch.braces(pattern, {\r\n        expand: true,\r\n        nodupes: true\r\n    });\r\n}\r\nexports.expandBraceExpansion = expandBraceExpansion;\r\nfunction getPatternParts(pattern, options) {\r\n    let { parts } = picomatch.scan(pattern, Object.assign(Object.assign({}, options), { parts: true }));\r\n    /**\r\n     * The scan method returns an empty array in some cases.\r\n     * See micromatch/picomatch#58 for more details.\r\n     */\r\n    if (parts.length === 0) {\r\n        parts = [pattern];\r\n    }\r\n    /**\r\n     * The scan method does not return an empty part for the pattern with a forward slash.\r\n     * This is another part of micromatch/picomatch#58.\r\n     */\r\n    if (parts[0].startsWith('/')) {\r\n        parts[0] = parts[0].slice(1);\r\n        parts.unshift('');\r\n    }\r\n    return parts;\r\n}\r\nexports.getPatternParts = getPatternParts;\r\nfunction makeRe(pattern, options) {\r\n    return micromatch.makeRe(pattern, options);\r\n}\r\nexports.makeRe = makeRe;\r\nfunction convertPatternsToRe(patterns, options) {\r\n    return patterns.map((pattern) => makeRe(pattern, options));\r\n}\r\nexports.convertPatternsToRe = convertPatternsToRe;\r\nfunction matchAny(entry, patternsRe) {\r\n    return patternsRe.some((patternRe) => patternRe.test(entry));\r\n}\r\nexports.matchAny = matchAny;\r\n","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.merge = void 0;\r\nconst merge2 = require(\"merge2\");\r\nfunction merge(streams) {\r\n    const mergedStream = merge2(streams);\r\n    streams.forEach((stream) => {\r\n        stream.once('error', (error) => mergedStream.emit('error', error));\r\n    });\r\n    mergedStream.once('close', () => propagateCloseEventToSources(streams));\r\n    mergedStream.once('end', () => propagateCloseEventToSources(streams));\r\n    return mergedStream;\r\n}\r\nexports.merge = merge;\r\nfunction propagateCloseEventToSources(streams) {\r\n    streams.forEach((stream) => stream.emit('close'));\r\n}\r\n","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.isEmpty = exports.isString = void 0;\r\nfunction isString(input) {\r\n    return typeof input === 'string';\r\n}\r\nexports.isString = isString;\r\nfunction isEmpty(input) {\r\n    return input === '';\r\n}\r\nexports.isEmpty = isEmpty;\r\n","'use strict'\n\nvar reusify = require('reusify')\n\nfunction fastqueue (context, worker, concurrency) {\n  if (typeof context === 'function') {\n    concurrency = worker\n    worker = context\n    context = null\n  }\n\n  var cache = reusify(Task)\n  var queueHead = null\n  var queueTail = null\n  var _running = 0\n  var errorHandler = null\n\n  var self = {\n    push: push,\n    drain: noop,\n    saturated: noop,\n    pause: pause,\n    paused: false,\n    concurrency: concurrency,\n    running: running,\n    resume: resume,\n    idle: idle,\n    length: length,\n    getQueue: getQueue,\n    unshift: unshift,\n    empty: noop,\n    kill: kill,\n    killAndDrain: killAndDrain,\n    error: error\n  }\n\n  return self\n\n  function running () {\n    return _running\n  }\n\n  function pause () {\n    self.paused = true\n  }\n\n  function length () {\n    var current = queueHead\n    var counter = 0\n\n    while (current) {\n      current = current.next\n      counter++\n    }\n\n    return counter\n  }\n\n  function getQueue () {\n    var current = queueHead\n    var tasks = []\n\n    while (current) {\n      tasks.push(current.value)\n      current = current.next\n    }\n\n    return tasks\n  }\n\n  function resume () {\n    if (!self.paused) return\n    self.paused = false\n    for (var i = 0; i < self.concurrency; i++) {\n      _running++\n      release()\n    }\n  }\n\n  function idle () {\n    return _running === 0 && self.length() === 0\n  }\n\n  function push (value, done) {\n    var current = cache.get()\n\n    current.context = context\n    current.release = release\n    current.value = value\n    current.callback = done || noop\n    current.errorHandler = errorHandler\n\n    if (_running === self.concurrency || self.paused) {\n      if (queueTail) {\n        queueTail.next = current\n        queueTail = current\n      } else {\n        queueHead = current\n        queueTail = current\n        self.saturated()\n      }\n    } else {\n      _running++\n      worker.call(context, current.value, current.worked)\n    }\n  }\n\n  function unshift (value, done) {\n    var current = cache.get()\n\n    current.context = context\n    current.release = release\n    current.value = value\n    current.callback = done || noop\n\n    if (_running === self.concurrency || self.paused) {\n      if (queueHead) {\n        current.next = queueHead\n        queueHead = current\n      } else {\n        queueHead = current\n        queueTail = current\n        self.saturated()\n      }\n    } else {\n      _running++\n      worker.call(context, current.value, current.worked)\n    }\n  }\n\n  function release (holder) {\n    if (holder) {\n      cache.release(holder)\n    }\n    var next = queueHead\n    if (next) {\n      if (!self.paused) {\n        if (queueTail === queueHead) {\n          queueTail = null\n        }\n        queueHead = next.next\n        next.next = null\n        worker.call(context, next.value, next.worked)\n        if (queueTail === null) {\n          self.empty()\n        }\n      } else {\n        _running--\n      }\n    } else if (--_running === 0) {\n      self.drain()\n    }\n  }\n\n  function kill () {\n    queueHead = null\n    queueTail = null\n    self.drain = noop\n  }\n\n  function killAndDrain () {\n    queueHead = null\n    queueTail = null\n    self.drain()\n    self.drain = noop\n  }\n\n  function error (handler) {\n    errorHandler = handler\n  }\n}\n\nfunction noop () {}\n\nfunction Task () {\n  this.value = null\n  this.callback = noop\n  this.next = null\n  this.release = noop\n  this.context = null\n  this.errorHandler = null\n\n  var self = this\n\n  this.worked = function worked (err, result) {\n    var callback = self.callback\n    var errorHandler = self.errorHandler\n    var val = self.value\n    self.value = null\n    self.callback = noop\n    if (self.errorHandler) {\n      errorHandler(err, val)\n    }\n    callback.call(self.context, err, result)\n    self.release(self)\n  }\n}\n\nmodule.exports = fastqueue\n","/*!\n * fill-range <https://github.com/jonschlinkert/fill-range>\n *\n * Copyright (c) 2014-present, Jon Schlinkert.\n * Licensed under the MIT License.\n */\n\n'use strict';\n\nconst util = require('util');\nconst toRegexRange = require('to-regex-range');\n\nconst isObject = val => val !== null && typeof val === 'object' && !Array.isArray(val);\n\nconst transform = toNumber => {\n  return value => toNumber === true ? Number(value) : String(value);\n};\n\nconst isValidValue = value => {\n  return typeof value === 'number' || (typeof value === 'string' && value !== '');\n};\n\nconst isNumber = num => Number.isInteger(+num);\n\nconst zeros = input => {\n  let value = `${input}`;\n  let index = -1;\n  if (value[0] === '-') value = value.slice(1);\n  if (value === '0') return false;\n  while (value[++index] === '0');\n  return index > 0;\n};\n\nconst stringify = (start, end, options) => {\n  if (typeof start === 'string' || typeof end === 'string') {\n    return true;\n  }\n  return options.stringify === true;\n};\n\nconst pad = (input, maxLength, toNumber) => {\n  if (maxLength > 0) {\n    let dash = input[0] === '-' ? '-' : '';\n    if (dash) input = input.slice(1);\n    input = (dash + input.padStart(dash ? maxLength - 1 : maxLength, '0'));\n  }\n  if (toNumber === false) {\n    return String(input);\n  }\n  return input;\n};\n\nconst toMaxLen = (input, maxLength) => {\n  let negative = input[0] === '-' ? '-' : '';\n  if (negative) {\n    input = input.slice(1);\n    maxLength--;\n  }\n  while (input.length < maxLength) input = '0' + input;\n  return negative ? ('-' + input) : input;\n};\n\nconst toSequence = (parts, options) => {\n  parts.negatives.sort((a, b) => a < b ? -1 : a > b ? 1 : 0);\n  parts.positives.sort((a, b) => a < b ? -1 : a > b ? 1 : 0);\n\n  let prefix = options.capture ? '' : '?:';\n  let positives = '';\n  let negatives = '';\n  let result;\n\n  if (parts.positives.length) {\n    positives = parts.positives.join('|');\n  }\n\n  if (parts.negatives.length) {\n    negatives = `-(${prefix}${parts.negatives.join('|')})`;\n  }\n\n  if (positives && negatives) {\n    result = `${positives}|${negatives}`;\n  } else {\n    result = positives || negatives;\n  }\n\n  if (options.wrap) {\n    return `(${prefix}${result})`;\n  }\n\n  return result;\n};\n\nconst toRange = (a, b, isNumbers, options) => {\n  if (isNumbers) {\n    return toRegexRange(a, b, { wrap: false, ...options });\n  }\n\n  let start = String.fromCharCode(a);\n  if (a === b) return start;\n\n  let stop = String.fromCharCode(b);\n  return `[${start}-${stop}]`;\n};\n\nconst toRegex = (start, end, options) => {\n  if (Array.isArray(start)) {\n    let wrap = options.wrap === true;\n    let prefix = options.capture ? '' : '?:';\n    return wrap ? `(${prefix}${start.join('|')})` : start.join('|');\n  }\n  return toRegexRange(start, end, options);\n};\n\nconst rangeError = (...args) => {\n  return new RangeError('Invalid range arguments: ' + util.inspect(...args));\n};\n\nconst invalidRange = (start, end, options) => {\n  if (options.strictRanges === true) throw rangeError([start, end]);\n  return [];\n};\n\nconst invalidStep = (step, options) => {\n  if (options.strictRanges === true) {\n    throw new TypeError(`Expected step \"${step}\" to be a number`);\n  }\n  return [];\n};\n\nconst fillNumbers = (start, end, step = 1, options = {}) => {\n  let a = Number(start);\n  let b = Number(end);\n\n  if (!Number.isInteger(a) || !Number.isInteger(b)) {\n    if (options.strictRanges === true) throw rangeError([start, end]);\n    return [];\n  }\n\n  // fix negative zero\n  if (a === 0) a = 0;\n  if (b === 0) b = 0;\n\n  let descending = a > b;\n  let startString = String(start);\n  let endString = String(end);\n  let stepString = String(step);\n  step = Math.max(Math.abs(step), 1);\n\n  let padded = zeros(startString) || zeros(endString) || zeros(stepString);\n  let maxLen = padded ? Math.max(startString.length, endString.length, stepString.length) : 0;\n  let toNumber = padded === false && stringify(start, end, options) === false;\n  let format = options.transform || transform(toNumber);\n\n  if (options.toRegex && step === 1) {\n    return toRange(toMaxLen(start, maxLen), toMaxLen(end, maxLen), true, options);\n  }\n\n  let parts = { negatives: [], positives: [] };\n  let push = num => parts[num < 0 ? 'negatives' : 'positives'].push(Math.abs(num));\n  let range = [];\n  let index = 0;\n\n  while (descending ? a >= b : a <= b) {\n    if (options.toRegex === true && step > 1) {\n      push(a);\n    } else {\n      range.push(pad(format(a, index), maxLen, toNumber));\n    }\n    a = descending ? a - step : a + step;\n    index++;\n  }\n\n  if (options.toRegex === true) {\n    return step > 1\n      ? toSequence(parts, options)\n      : toRegex(range, null, { wrap: false, ...options });\n  }\n\n  return range;\n};\n\nconst fillLetters = (start, end, step = 1, options = {}) => {\n  if ((!isNumber(start) && start.length > 1) || (!isNumber(end) && end.length > 1)) {\n    return invalidRange(start, end, options);\n  }\n\n\n  let format = options.transform || (val => String.fromCharCode(val));\n  let a = `${start}`.charCodeAt(0);\n  let b = `${end}`.charCodeAt(0);\n\n  let descending = a > b;\n  let min = Math.min(a, b);\n  let max = Math.max(a, b);\n\n  if (options.toRegex && step === 1) {\n    return toRange(min, max, false, options);\n  }\n\n  let range = [];\n  let index = 0;\n\n  while (descending ? a >= b : a <= b) {\n    range.push(format(a, index));\n    a = descending ? a - step : a + step;\n    index++;\n  }\n\n  if (options.toRegex === true) {\n    return toRegex(range, null, { wrap: false, options });\n  }\n\n  return range;\n};\n\nconst fill = (start, end, step, options = {}) => {\n  if (end == null && isValidValue(start)) {\n    return [start];\n  }\n\n  if (!isValidValue(start) || !isValidValue(end)) {\n    return invalidRange(start, end, options);\n  }\n\n  if (typeof step === 'function') {\n    return fill(start, end, 1, { transform: step });\n  }\n\n  if (isObject(step)) {\n    return fill(start, end, 0, step);\n  }\n\n  let opts = { ...options };\n  if (opts.capture === true) opts.wrap = true;\n  step = step || opts.step || 1;\n\n  if (!isNumber(step)) {\n    if (step != null && !isObject(step)) return invalidStep(step, opts);\n    return fill(start, end, 1, step);\n  }\n\n  if (isNumber(start) && isNumber(end)) {\n    return fillNumbers(start, end, step, opts);\n  }\n\n  return fillLetters(start, end, Math.max(Math.abs(step), 1), opts);\n};\n\nmodule.exports = fill;\n","'use strict';\n\nvar isGlob = require('is-glob');\nvar pathPosixDirname = require('path').posix.dirname;\nvar isWin32 = require('os').platform() === 'win32';\n\nvar slash = '/';\nvar backslash = /\\\\/g;\nvar enclosure = /[\\{\\[].*[\\/]*.*[\\}\\]]$/;\nvar globby = /(^|[^\\\\])([\\{\\[]|\\([^\\)]+$)/;\nvar escaped = /\\\\([\\!\\*\\?\\|\\[\\]\\(\\)\\{\\}])/g;\n\n/**\n * @param {string} str\n * @param {Object} opts\n * @param {boolean} [opts.flipBackslashes=true]\n */\nmodule.exports = function globParent(str, opts) {\n  var options = Object.assign({ flipBackslashes: true }, opts);\n\n  // flip windows path separators\n  if (options.flipBackslashes && isWin32 && str.indexOf(slash) < 0) {\n    str = str.replace(backslash, slash);\n  }\n\n  // special case for strings ending in enclosure containing path separator\n  if (enclosure.test(str)) {\n    str += slash;\n  }\n\n  // preserves full path in case of trailing path separator\n  str += 'a';\n\n  // remove path parts that are globby\n  do {\n    str = pathPosixDirname(str);\n  } while (isGlob(str) || globby.test(str));\n\n  // remove escape chars and return result\n  return str.replace(escaped, '$1');\n};\n","'use strict';\nconst {promisify} = require('util');\nconst fs = require('fs');\nconst path = require('path');\nconst fastGlob = require('fast-glob');\nconst gitIgnore = require('ignore');\nconst slash = require('slash');\n\nconst DEFAULT_IGNORE = [\n\t'**/node_modules/**',\n\t'**/flow-typed/**',\n\t'**/coverage/**',\n\t'**/.git'\n];\n\nconst readFileP = promisify(fs.readFile);\n\nconst mapGitIgnorePatternTo = base => ignore => {\n\tif (ignore.startsWith('!')) {\n\t\treturn '!' + path.posix.join(base, ignore.slice(1));\n\t}\n\n\treturn path.posix.join(base, ignore);\n};\n\nconst parseGitIgnore = (content, options) => {\n\tconst base = slash(path.relative(options.cwd, path.dirname(options.fileName)));\n\n\treturn content\n\t\t.split(/\\r?\\n/)\n\t\t.filter(Boolean)\n\t\t.filter(line => !line.startsWith('#'))\n\t\t.map(mapGitIgnorePatternTo(base));\n};\n\nconst reduceIgnore = files => {\n\treturn files.reduce((ignores, file) => {\n\t\tignores.add(parseGitIgnore(file.content, {\n\t\t\tcwd: file.cwd,\n\t\t\tfileName: file.filePath\n\t\t}));\n\t\treturn ignores;\n\t}, gitIgnore());\n};\n\nconst ensureAbsolutePathForCwd = (cwd, p) => {\n\tcwd = slash(cwd);\n\tif (path.isAbsolute(p)) {\n\t\tif (p.startsWith(cwd)) {\n\t\t\treturn p;\n\t\t}\n\n\t\tthrow new Error(`Path ${p} is not in cwd ${cwd}`);\n\t}\n\n\treturn path.join(cwd, p);\n};\n\nconst getIsIgnoredPredecate = (ignores, cwd) => {\n\treturn p => ignores.ignores(slash(path.relative(cwd, ensureAbsolutePathForCwd(cwd, p))));\n};\n\nconst getFile = async (file, cwd) => {\n\tconst filePath = path.join(cwd, file);\n\tconst content = await readFileP(filePath, 'utf8');\n\n\treturn {\n\t\tcwd,\n\t\tfilePath,\n\t\tcontent\n\t};\n};\n\nconst getFileSync = (file, cwd) => {\n\tconst filePath = path.join(cwd, file);\n\tconst content = fs.readFileSync(filePath, 'utf8');\n\n\treturn {\n\t\tcwd,\n\t\tfilePath,\n\t\tcontent\n\t};\n};\n\nconst normalizeOptions = ({\n\tignore = [],\n\tcwd = slash(process.cwd())\n} = {}) => {\n\treturn {ignore, cwd};\n};\n\nmodule.exports = async options => {\n\toptions = normalizeOptions(options);\n\n\tconst paths = await fastGlob('**/.gitignore', {\n\t\tignore: DEFAULT_IGNORE.concat(options.ignore),\n\t\tcwd: options.cwd\n\t});\n\n\tconst files = await Promise.all(paths.map(file => getFile(file, options.cwd)));\n\tconst ignores = reduceIgnore(files);\n\n\treturn getIsIgnoredPredecate(ignores, options.cwd);\n};\n\nmodule.exports.sync = options => {\n\toptions = normalizeOptions(options);\n\n\tconst paths = fastGlob.sync('**/.gitignore', {\n\t\tignore: DEFAULT_IGNORE.concat(options.ignore),\n\t\tcwd: options.cwd\n\t});\n\n\tconst files = paths.map(file => getFileSync(file, options.cwd));\n\tconst ignores = reduceIgnore(files);\n\n\treturn getIsIgnoredPredecate(ignores, options.cwd);\n};\n","'use strict';\nconst fs = require('fs');\nconst arrayUnion = require('array-union');\nconst merge2 = require('merge2');\nconst fastGlob = require('fast-glob');\nconst dirGlob = require('dir-glob');\nconst gitignore = require('./gitignore');\nconst {FilterStream, UniqueStream} = require('./stream-utils');\n\nconst DEFAULT_FILTER = () => false;\n\nconst isNegative = pattern => pattern[0] === '!';\n\nconst assertPatternsInput = patterns => {\n\tif (!patterns.every(pattern => typeof pattern === 'string')) {\n\t\tthrow new TypeError('Patterns must be a string or an array of strings');\n\t}\n};\n\nconst checkCwdOption = (options = {}) => {\n\tif (!options.cwd) {\n\t\treturn;\n\t}\n\n\tlet stat;\n\ttry {\n\t\tstat = fs.statSync(options.cwd);\n\t} catch (_) {\n\t\treturn;\n\t}\n\n\tif (!stat.isDirectory()) {\n\t\tthrow new Error('The `cwd` option must be a path to a directory');\n\t}\n};\n\nconst getPathString = p => p.stats instanceof fs.Stats ? p.path : p;\n\nconst generateGlobTasks = (patterns, taskOptions) => {\n\tpatterns = arrayUnion([].concat(patterns));\n\tassertPatternsInput(patterns);\n\tcheckCwdOption(taskOptions);\n\n\tconst globTasks = [];\n\n\ttaskOptions = {\n\t\tignore: [],\n\t\texpandDirectories: true,\n\t\t...taskOptions\n\t};\n\n\tfor (const [index, pattern] of patterns.entries()) {\n\t\tif (isNegative(pattern)) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tconst ignore = patterns\n\t\t\t.slice(index)\n\t\t\t.filter(isNegative)\n\t\t\t.map(pattern => pattern.slice(1));\n\n\t\tconst options = {\n\t\t\t...taskOptions,\n\t\t\tignore: taskOptions.ignore.concat(ignore)\n\t\t};\n\n\t\tglobTasks.push({pattern, options});\n\t}\n\n\treturn globTasks;\n};\n\nconst globDirs = (task, fn) => {\n\tlet options = {};\n\tif (task.options.cwd) {\n\t\toptions.cwd = task.options.cwd;\n\t}\n\n\tif (Array.isArray(task.options.expandDirectories)) {\n\t\toptions = {\n\t\t\t...options,\n\t\t\tfiles: task.options.expandDirectories\n\t\t};\n\t} else if (typeof task.options.expandDirectories === 'object') {\n\t\toptions = {\n\t\t\t...options,\n\t\t\t...task.options.expandDirectories\n\t\t};\n\t}\n\n\treturn fn(task.pattern, options);\n};\n\nconst getPattern = (task, fn) => task.options.expandDirectories ? globDirs(task, fn) : [task.pattern];\n\nconst getFilterSync = options => {\n\treturn options && options.gitignore ?\n\t\tgitignore.sync({cwd: options.cwd, ignore: options.ignore}) :\n\t\tDEFAULT_FILTER;\n};\n\nconst globToTask = task => glob => {\n\tconst {options} = task;\n\tif (options.ignore && Array.isArray(options.ignore) && options.expandDirectories) {\n\t\toptions.ignore = dirGlob.sync(options.ignore);\n\t}\n\n\treturn {\n\t\tpattern: glob,\n\t\toptions\n\t};\n};\n\nmodule.exports = async (patterns, options) => {\n\tconst globTasks = generateGlobTasks(patterns, options);\n\n\tconst getFilter = async () => {\n\t\treturn options && options.gitignore ?\n\t\t\tgitignore({cwd: options.cwd, ignore: options.ignore}) :\n\t\t\tDEFAULT_FILTER;\n\t};\n\n\tconst getTasks = async () => {\n\t\tconst tasks = await Promise.all(globTasks.map(async task => {\n\t\t\tconst globs = await getPattern(task, dirGlob);\n\t\t\treturn Promise.all(globs.map(globToTask(task)));\n\t\t}));\n\n\t\treturn arrayUnion(...tasks);\n\t};\n\n\tconst [filter, tasks] = await Promise.all([getFilter(), getTasks()]);\n\tconst paths = await Promise.all(tasks.map(task => fastGlob(task.pattern, task.options)));\n\n\treturn arrayUnion(...paths).filter(path_ => !filter(getPathString(path_)));\n};\n\nmodule.exports.sync = (patterns, options) => {\n\tconst globTasks = generateGlobTasks(patterns, options);\n\n\tconst tasks = globTasks.reduce((tasks, task) => {\n\t\tconst newTask = getPattern(task, dirGlob.sync).map(globToTask(task));\n\t\treturn tasks.concat(newTask);\n\t}, []);\n\n\tconst filter = getFilterSync(options);\n\n\treturn tasks.reduce(\n\t\t(matches, task) => arrayUnion(matches, fastGlob.sync(task.pattern, task.options)),\n\t\t[]\n\t).filter(path_ => !filter(path_));\n};\n\nmodule.exports.stream = (patterns, options) => {\n\tconst globTasks = generateGlobTasks(patterns, options);\n\n\tconst tasks = globTasks.reduce((tasks, task) => {\n\t\tconst newTask = getPattern(task, dirGlob.sync).map(globToTask(task));\n\t\treturn tasks.concat(newTask);\n\t}, []);\n\n\tconst filter = getFilterSync(options);\n\tconst filterStream = new FilterStream(p => !filter(p));\n\tconst uniqueStream = new UniqueStream();\n\n\treturn merge2(tasks.map(task => fastGlob.stream(task.pattern, task.options)))\n\t\t.pipe(filterStream)\n\t\t.pipe(uniqueStream);\n};\n\nmodule.exports.generateGlobTasks = generateGlobTasks;\n\nmodule.exports.hasMagic = (patterns, options) => []\n\t.concat(patterns)\n\t.some(pattern => fastGlob.isDynamicPattern(pattern, options));\n\nmodule.exports.gitignore = gitignore;\n","'use strict';\nconst {Transform} = require('stream');\n\nclass ObjectTransform extends Transform {\n\tconstructor() {\n\t\tsuper({\n\t\t\tobjectMode: true\n\t\t});\n\t}\n}\n\nclass FilterStream extends ObjectTransform {\n\tconstructor(filter) {\n\t\tsuper();\n\t\tthis._filter = filter;\n\t}\n\n\t_transform(data, encoding, callback) {\n\t\tif (this._filter(data)) {\n\t\t\tthis.push(data);\n\t\t}\n\n\t\tcallback();\n\t}\n}\n\nclass UniqueStream extends ObjectTransform {\n\tconstructor() {\n\t\tsuper();\n\t\tthis._pushed = new Set();\n\t}\n\n\t_transform(data, encoding, callback) {\n\t\tif (!this._pushed.has(data)) {\n\t\t\tthis.push(data);\n\t\t\tthis._pushed.add(data);\n\t\t}\n\n\t\tcallback();\n\t}\n}\n\nmodule.exports = {\n\tFilterStream,\n\tUniqueStream\n};\n","// A simple implementation of make-array\nfunction makeArray (subject) {\n  return Array.isArray(subject)\n    ? subject\n    : [subject]\n}\n\nconst EMPTY = ''\nconst SPACE = ' '\nconst ESCAPE = '\\\\'\nconst REGEX_TEST_BLANK_LINE = /^\\s+$/\nconst REGEX_REPLACE_LEADING_EXCAPED_EXCLAMATION = /^\\\\!/\nconst REGEX_REPLACE_LEADING_EXCAPED_HASH = /^\\\\#/\nconst REGEX_SPLITALL_CRLF = /\\r?\\n/g\n// /foo,\n// ./foo,\n// ../foo,\n// .\n// ..\nconst REGEX_TEST_INVALID_PATH = /^\\.*\\/|^\\.+$/\n\nconst SLASH = '/'\nconst KEY_IGNORE = typeof Symbol !== 'undefined'\n  ? Symbol.for('node-ignore')\n  /* istanbul ignore next */\n  : 'node-ignore'\n\nconst define = (object, key, value) =>\n  Object.defineProperty(object, key, {value})\n\nconst REGEX_REGEXP_RANGE = /([0-z])-([0-z])/g\n\n// Sanitize the range of a regular expression\n// The cases are complicated, see test cases for details\nconst sanitizeRange = range => range.replace(\n  REGEX_REGEXP_RANGE,\n  (match, from, to) => from.charCodeAt(0) <= to.charCodeAt(0)\n    ? match\n    // Invalid range (out of order) which is ok for gitignore rules but\n    //   fatal for JavaScript regular expression, so eliminate it.\n    : EMPTY\n)\n\n// See fixtures #59\nconst cleanRangeBackSlash = slashes => {\n  const {length} = slashes\n  return slashes.slice(0, length - length % 2)\n}\n\n// > If the pattern ends with a slash,\n// > it is removed for the purpose of the following description,\n// > but it would only find a match with a directory.\n// > In other words, foo/ will match a directory foo and paths underneath it,\n// > but will not match a regular file or a symbolic link foo\n// >  (this is consistent with the way how pathspec works in general in Git).\n// '`foo/`' will not match regular file '`foo`' or symbolic link '`foo`'\n// -> ignore-rules will not deal with it, because it costs extra `fs.stat` call\n//      you could use option `mark: true` with `glob`\n\n// '`foo/`' should not continue with the '`..`'\nconst REPLACERS = [\n\n  // > Trailing spaces are ignored unless they are quoted with backslash (\"\\\")\n  [\n    // (a\\ ) -> (a )\n    // (a  ) -> (a)\n    // (a \\ ) -> (a  )\n    /\\\\?\\s+$/,\n    match => match.indexOf('\\\\') === 0\n      ? SPACE\n      : EMPTY\n  ],\n\n  // replace (\\ ) with ' '\n  [\n    /\\\\\\s/g,\n    () => SPACE\n  ],\n\n  // Escape metacharacters\n  // which is written down by users but means special for regular expressions.\n\n  // > There are 12 characters with special meanings:\n  // > - the backslash \\,\n  // > - the caret ^,\n  // > - the dollar sign $,\n  // > - the period or dot .,\n  // > - the vertical bar or pipe symbol |,\n  // > - the question mark ?,\n  // > - the asterisk or star *,\n  // > - the plus sign +,\n  // > - the opening parenthesis (,\n  // > - the closing parenthesis ),\n  // > - and the opening square bracket [,\n  // > - the opening curly brace {,\n  // > These special characters are often called \"metacharacters\".\n  [\n    /[\\\\$.|*+(){^]/g,\n    match => `\\\\${match}`\n  ],\n\n  [\n    // > a question mark (?) matches a single character\n    /(?!\\\\)\\?/g,\n    () => '[^/]'\n  ],\n\n  // leading slash\n  [\n\n    // > A leading slash matches the beginning of the pathname.\n    // > For example, \"/*.c\" matches \"cat-file.c\" but not \"mozilla-sha1/sha1.c\".\n    // A leading slash matches the beginning of the pathname\n    /^\\//,\n    () => '^'\n  ],\n\n  // replace special metacharacter slash after the leading slash\n  [\n    /\\//g,\n    () => '\\\\/'\n  ],\n\n  [\n    // > A leading \"**\" followed by a slash means match in all directories.\n    // > For example, \"**/foo\" matches file or directory \"foo\" anywhere,\n    // > the same as pattern \"foo\".\n    // > \"**/foo/bar\" matches file or directory \"bar\" anywhere that is directly\n    // >   under directory \"foo\".\n    // Notice that the '*'s have been replaced as '\\\\*'\n    /^\\^*\\\\\\*\\\\\\*\\\\\\//,\n\n    // '**/foo' <-> 'foo'\n    () => '^(?:.*\\\\/)?'\n  ],\n\n  // starting\n  [\n    // there will be no leading '/'\n    //   (which has been replaced by section \"leading slash\")\n    // If starts with '**', adding a '^' to the regular expression also works\n    /^(?=[^^])/,\n    function startingReplacer () {\n      // If has a slash `/` at the beginning or middle\n      return !/\\/(?!$)/.test(this)\n        // > Prior to 2.22.1\n        // > If the pattern does not contain a slash /,\n        // >   Git treats it as a shell glob pattern\n        // Actually, if there is only a trailing slash,\n        //   git also treats it as a shell glob pattern\n\n        // After 2.22.1 (compatible but clearer)\n        // > If there is a separator at the beginning or middle (or both)\n        // > of the pattern, then the pattern is relative to the directory\n        // > level of the particular .gitignore file itself.\n        // > Otherwise the pattern may also match at any level below\n        // > the .gitignore level.\n        ? '(?:^|\\\\/)'\n\n        // > Otherwise, Git treats the pattern as a shell glob suitable for\n        // >   consumption by fnmatch(3)\n        : '^'\n    }\n  ],\n\n  // two globstars\n  [\n    // Use lookahead assertions so that we could match more than one `'/**'`\n    /\\\\\\/\\\\\\*\\\\\\*(?=\\\\\\/|$)/g,\n\n    // Zero, one or several directories\n    // should not use '*', or it will be replaced by the next replacer\n\n    // Check if it is not the last `'/**'`\n    (_, index, str) => index + 6 < str.length\n\n      // case: /**/\n      // > A slash followed by two consecutive asterisks then a slash matches\n      // >   zero or more directories.\n      // > For example, \"a/**/b\" matches \"a/b\", \"a/x/b\", \"a/x/y/b\" and so on.\n      // '/**/'\n      ? '(?:\\\\/[^\\\\/]+)*'\n\n      // case: /**\n      // > A trailing `\"/**\"` matches everything inside.\n\n      // #21: everything inside but it should not include the current folder\n      : '\\\\/.+'\n  ],\n\n  // intermediate wildcards\n  [\n    // Never replace escaped '*'\n    // ignore rule '\\*' will match the path '*'\n\n    // 'abc.*/' -> go\n    // 'abc.*'  -> skip this rule\n    /(^|[^\\\\]+)\\\\\\*(?=.+)/g,\n\n    // '*.js' matches '.js'\n    // '*.js' doesn't match 'abc'\n    (_, p1) => `${p1}[^\\\\/]*`\n  ],\n\n  [\n    // unescape, revert step 3 except for back slash\n    // For example, if a user escape a '\\\\*',\n    // after step 3, the result will be '\\\\\\\\\\\\*'\n    /\\\\\\\\\\\\(?=[$.|*+(){^])/g,\n    () => ESCAPE\n  ],\n\n  [\n    // '\\\\\\\\' -> '\\\\'\n    /\\\\\\\\/g,\n    () => ESCAPE\n  ],\n\n  [\n    // > The range notation, e.g. [a-zA-Z],\n    // > can be used to match one of the characters in a range.\n\n    // `\\` is escaped by step 3\n    /(\\\\)?\\[([^\\]/]*?)(\\\\*)($|\\])/g,\n    (match, leadEscape, range, endEscape, close) => leadEscape === ESCAPE\n      // '\\\\[bar]' -> '\\\\\\\\[bar\\\\]'\n      ? `\\\\[${range}${cleanRangeBackSlash(endEscape)}${close}`\n      : close === ']'\n        ? endEscape.length % 2 === 0\n          // A normal case, and it is a range notation\n          // '[bar]'\n          // '[bar\\\\\\\\]'\n          ? `[${sanitizeRange(range)}${endEscape}]`\n          // Invalid range notaton\n          // '[bar\\\\]' -> '[bar\\\\\\\\]'\n          : '[]'\n        : '[]'\n  ],\n\n  // ending\n  [\n    // 'js' will not match 'js.'\n    // 'ab' will not match 'abc'\n    /(?:[^*])$/,\n\n    // WTF!\n    // https://git-scm.com/docs/gitignore\n    // changes in [2.22.1](https://git-scm.com/docs/gitignore/2.22.1)\n    // which re-fixes #24, #38\n\n    // > If there is a separator at the end of the pattern then the pattern\n    // > will only match directories, otherwise the pattern can match both\n    // > files and directories.\n\n    // 'js*' will not match 'a.js'\n    // 'js/' will not match 'a.js'\n    // 'js' will match 'a.js' and 'a.js/'\n    match => /\\/$/.test(match)\n      // foo/ will not match 'foo'\n      ? `${match}$`\n      // foo matches 'foo' and 'foo/'\n      : `${match}(?=$|\\\\/$)`\n  ],\n\n  // trailing wildcard\n  [\n    /(\\^|\\\\\\/)?\\\\\\*$/,\n    (_, p1) => {\n      const prefix = p1\n        // '\\^':\n        // '/*' does not match EMPTY\n        // '/*' does not match everything\n\n        // '\\\\\\/':\n        // 'abc/*' does not match 'abc/'\n        ? `${p1}[^/]+`\n\n        // 'a*' matches 'a'\n        // 'a*' matches 'aa'\n        : '[^/]*'\n\n      return `${prefix}(?=$|\\\\/$)`\n    }\n  ],\n]\n\n// A simple cache, because an ignore rule only has only one certain meaning\nconst regexCache = Object.create(null)\n\n// @param {pattern}\nconst makeRegex = (pattern, negative, ignorecase) => {\n  const r = regexCache[pattern]\n  if (r) {\n    return r\n  }\n\n  // const replacers = negative\n  //   ? NEGATIVE_REPLACERS\n  //   : POSITIVE_REPLACERS\n\n  const source = REPLACERS.reduce(\n    (prev, current) => prev.replace(current[0], current[1].bind(pattern)),\n    pattern\n  )\n\n  return regexCache[pattern] = ignorecase\n    ? new RegExp(source, 'i')\n    : new RegExp(source)\n}\n\nconst isString = subject => typeof subject === 'string'\n\n// > A blank line matches no files, so it can serve as a separator for readability.\nconst checkPattern = pattern => pattern\n  && isString(pattern)\n  && !REGEX_TEST_BLANK_LINE.test(pattern)\n\n  // > A line starting with # serves as a comment.\n  && pattern.indexOf('#') !== 0\n\nconst splitPattern = pattern => pattern.split(REGEX_SPLITALL_CRLF)\n\nclass IgnoreRule {\n  constructor (\n    origin,\n    pattern,\n    negative,\n    regex\n  ) {\n    this.origin = origin\n    this.pattern = pattern\n    this.negative = negative\n    this.regex = regex\n  }\n}\n\nconst createRule = (pattern, ignorecase) => {\n  const origin = pattern\n  let negative = false\n\n  // > An optional prefix \"!\" which negates the pattern;\n  if (pattern.indexOf('!') === 0) {\n    negative = true\n    pattern = pattern.substr(1)\n  }\n\n  pattern = pattern\n  // > Put a backslash (\"\\\") in front of the first \"!\" for patterns that\n  // >   begin with a literal \"!\", for example, `\"\\!important!.txt\"`.\n  .replace(REGEX_REPLACE_LEADING_EXCAPED_EXCLAMATION, '!')\n  // > Put a backslash (\"\\\") in front of the first hash for patterns that\n  // >   begin with a hash.\n  .replace(REGEX_REPLACE_LEADING_EXCAPED_HASH, '#')\n\n  const regex = makeRegex(pattern, negative, ignorecase)\n\n  return new IgnoreRule(\n    origin,\n    pattern,\n    negative,\n    regex\n  )\n}\n\nconst throwError = (message, Ctor) => {\n  throw new Ctor(message)\n}\n\nconst checkPath = (path, originalPath, doThrow) => {\n  if (!isString(path)) {\n    return doThrow(\n      `path must be a string, but got \\`${originalPath}\\``,\n      TypeError\n    )\n  }\n\n  // We don't know if we should ignore EMPTY, so throw\n  if (!path) {\n    return doThrow(`path must not be empty`, TypeError)\n  }\n\n  // Check if it is a relative path\n  if (checkPath.isNotRelative(path)) {\n    const r = '`path.relative()`d'\n    return doThrow(\n      `path should be a ${r} string, but got \"${originalPath}\"`,\n      RangeError\n    )\n  }\n\n  return true\n}\n\nconst isNotRelative = path => REGEX_TEST_INVALID_PATH.test(path)\n\ncheckPath.isNotRelative = isNotRelative\ncheckPath.convert = p => p\n\nclass Ignore {\n  constructor ({\n    ignorecase = true\n  } = {}) {\n    this._rules = []\n    this._ignorecase = ignorecase\n    define(this, KEY_IGNORE, true)\n    this._initCache()\n  }\n\n  _initCache () {\n    this._ignoreCache = Object.create(null)\n    this._testCache = Object.create(null)\n  }\n\n  _addPattern (pattern) {\n    // #32\n    if (pattern && pattern[KEY_IGNORE]) {\n      this._rules = this._rules.concat(pattern._rules)\n      this._added = true\n      return\n    }\n\n    if (checkPattern(pattern)) {\n      const rule = createRule(pattern, this._ignorecase)\n      this._added = true\n      this._rules.push(rule)\n    }\n  }\n\n  // @param {Array<string> | string | Ignore} pattern\n  add (pattern) {\n    this._added = false\n\n    makeArray(\n      isString(pattern)\n        ? splitPattern(pattern)\n        : pattern\n    ).forEach(this._addPattern, this)\n\n    // Some rules have just added to the ignore,\n    // making the behavior changed.\n    if (this._added) {\n      this._initCache()\n    }\n\n    return this\n  }\n\n  // legacy\n  addPattern (pattern) {\n    return this.add(pattern)\n  }\n\n  //          |           ignored : unignored\n  // negative |   0:0   |   0:1   |   1:0   |   1:1\n  // -------- | ------- | ------- | ------- | --------\n  //     0    |  TEST   |  TEST   |  SKIP   |    X\n  //     1    |  TESTIF |  SKIP   |  TEST   |    X\n\n  // - SKIP: always skip\n  // - TEST: always test\n  // - TESTIF: only test if checkUnignored\n  // - X: that never happen\n\n  // @param {boolean} whether should check if the path is unignored,\n  //   setting `checkUnignored` to `false` could reduce additional\n  //   path matching.\n\n  // @returns {TestResult} true if a file is ignored\n  _testOne (path, checkUnignored) {\n    let ignored = false\n    let unignored = false\n\n    this._rules.forEach(rule => {\n      const {negative} = rule\n      if (\n        unignored === negative && ignored !== unignored\n        || negative && !ignored && !unignored && !checkUnignored\n      ) {\n        return\n      }\n\n      const matched = rule.regex.test(path)\n\n      if (matched) {\n        ignored = !negative\n        unignored = negative\n      }\n    })\n\n    return {\n      ignored,\n      unignored\n    }\n  }\n\n  // @returns {TestResult}\n  _test (originalPath, cache, checkUnignored, slices) {\n    const path = originalPath\n      // Supports nullable path\n      && checkPath.convert(originalPath)\n\n    checkPath(path, originalPath, throwError)\n\n    return this._t(path, cache, checkUnignored, slices)\n  }\n\n  _t (path, cache, checkUnignored, slices) {\n    if (path in cache) {\n      return cache[path]\n    }\n\n    if (!slices) {\n      // path/to/a.js\n      // ['path', 'to', 'a.js']\n      slices = path.split(SLASH)\n    }\n\n    slices.pop()\n\n    // If the path has no parent directory, just test it\n    if (!slices.length) {\n      return cache[path] = this._testOne(path, checkUnignored)\n    }\n\n    const parent = this._t(\n      slices.join(SLASH) + SLASH,\n      cache,\n      checkUnignored,\n      slices\n    )\n\n    // If the path contains a parent directory, check the parent first\n    return cache[path] = parent.ignored\n      // > It is not possible to re-include a file if a parent directory of\n      // >   that file is excluded.\n      ? parent\n      : this._testOne(path, checkUnignored)\n  }\n\n  ignores (path) {\n    return this._test(path, this._ignoreCache, false).ignored\n  }\n\n  createFilter () {\n    return path => !this.ignores(path)\n  }\n\n  filter (paths) {\n    return makeArray(paths).filter(this.createFilter())\n  }\n\n  // @returns {TestResult}\n  test (path) {\n    return this._test(path, this._testCache, true)\n  }\n}\n\nconst factory = options => new Ignore(options)\n\nconst returnFalse = () => false\n\nconst isPathValid = path =>\n  checkPath(path && checkPath.convert(path), path, returnFalse)\n\nfactory.isPathValid = isPathValid\n\n// Fixes typescript\nfactory.default = factory\n\nmodule.exports = factory\n\n// Windows\n// --------------------------------------------------------------\n/* istanbul ignore if  */\nif (\n  // Detect `process` so that it can run in browsers.\n  typeof process !== 'undefined'\n  && (\n    process.env && process.env.IGNORE_TEST_WIN32\n    || process.platform === 'win32'\n  )\n) {\n  /* eslint no-control-regex: \"off\" */\n  const makePosix = str => /^\\\\\\\\\\?\\\\/.test(str)\n  || /[\"<>|\\u0000-\\u001F]+/u.test(str)\n    ? str\n    : str.replace(/\\\\/g, '/')\n\n  checkPath.convert = makePosix\n\n  // 'C:\\\\foo'     <- 'C:\\\\foo' has been converted to 'C:/'\n  // 'd:\\\\foo'\n  const REGIX_IS_WINDOWS_PATH_ABSOLUTE = /^[a-z]:\\//i\n  checkPath.isNotRelative = path =>\n    REGIX_IS_WINDOWS_PATH_ABSOLUTE.test(path)\n    || isNotRelative(path)\n}\n","/*!\n * is-extglob <https://github.com/jonschlinkert/is-extglob>\n *\n * Copyright (c) 2014-2016, Jon Schlinkert.\n * Licensed under the MIT License.\n */\n\nmodule.exports = function isExtglob(str) {\n  if (typeof str !== 'string' || str === '') {\n    return false;\n  }\n\n  var match;\n  while ((match = /(\\\\).|([@?!+*]\\(.*\\))/g.exec(str))) {\n    if (match[2]) return true;\n    str = str.slice(match.index + match[0].length);\n  }\n\n  return false;\n};\n","/*!\n * is-glob <https://github.com/jonschlinkert/is-glob>\n *\n * Copyright (c) 2014-2017, Jon Schlinkert.\n * Released under the MIT License.\n */\n\nvar isExtglob = require('is-extglob');\nvar chars = { '{': '}', '(': ')', '[': ']'};\nvar strictRegex = /\\\\(.)|(^!|\\*|[\\].+)]\\?|\\[[^\\\\\\]]+\\]|\\{[^\\\\}]+\\}|\\(\\?[:!=][^\\\\)]+\\)|\\([^|]+\\|[^\\\\)]+\\))/;\nvar relaxedRegex = /\\\\(.)|(^!|[*?{}()[\\]]|\\(\\?)/;\n\nmodule.exports = function isGlob(str, options) {\n  if (typeof str !== 'string' || str === '') {\n    return false;\n  }\n\n  if (isExtglob(str)) {\n    return true;\n  }\n\n  var regex = strictRegex;\n  var match;\n\n  // optionally relax regex\n  if (options && options.strict === false) {\n    regex = relaxedRegex;\n  }\n\n  while ((match = regex.exec(str))) {\n    if (match[2]) return true;\n    var idx = match.index + match[0].length;\n\n    // if an open bracket/brace/paren is escaped,\n    // set the index to the next closing character\n    var open = match[1];\n    var close = open ? chars[open] : null;\n    if (open && close) {\n      var n = str.indexOf(close, idx);\n      if (n !== -1) {\n        idx = n + 1;\n      }\n    }\n\n    str = str.slice(idx);\n  }\n  return false;\n};\n","/*!\n * is-number <https://github.com/jonschlinkert/is-number>\n *\n * Copyright (c) 2014-present, Jon Schlinkert.\n * Released under the MIT License.\n */\n\n'use strict';\n\nmodule.exports = function(num) {\n  if (typeof num === 'number') {\n    return num - num === 0;\n  }\n  if (typeof num === 'string' && num.trim() !== '') {\n    return Number.isFinite ? Number.isFinite(+num) : isFinite(+num);\n  }\n  return false;\n};\n","'use strict'\n/*\n * merge2\n * https://github.com/teambition/merge2\n *\n * Copyright (c) 2014-2020 Teambition\n * Licensed under the MIT license.\n */\nconst Stream = require('stream')\nconst PassThrough = Stream.PassThrough\nconst slice = Array.prototype.slice\n\nmodule.exports = merge2\n\nfunction merge2 () {\n  const streamsQueue = []\n  const args = slice.call(arguments)\n  let merging = false\n  let options = args[args.length - 1]\n\n  if (options && !Array.isArray(options) && options.pipe == null) {\n    args.pop()\n  } else {\n    options = {}\n  }\n\n  const doEnd = options.end !== false\n  const doPipeError = options.pipeError === true\n  if (options.objectMode == null) {\n    options.objectMode = true\n  }\n  if (options.highWaterMark == null) {\n    options.highWaterMark = 64 * 1024\n  }\n  const mergedStream = PassThrough(options)\n\n  function addStream () {\n    for (let i = 0, len = arguments.length; i < len; i++) {\n      streamsQueue.push(pauseStreams(arguments[i], options))\n    }\n    mergeStream()\n    return this\n  }\n\n  function mergeStream () {\n    if (merging) {\n      return\n    }\n    merging = true\n\n    let streams = streamsQueue.shift()\n    if (!streams) {\n      process.nextTick(endStream)\n      return\n    }\n    if (!Array.isArray(streams)) {\n      streams = [streams]\n    }\n\n    let pipesCount = streams.length + 1\n\n    function next () {\n      if (--pipesCount > 0) {\n        return\n      }\n      merging = false\n      mergeStream()\n    }\n\n    function pipe (stream) {\n      function onend () {\n        stream.removeListener('merge2UnpipeEnd', onend)\n        stream.removeListener('end', onend)\n        if (doPipeError) {\n          stream.removeListener('error', onerror)\n        }\n        next()\n      }\n      function onerror (err) {\n        mergedStream.emit('error', err)\n      }\n      // skip ended stream\n      if (stream._readableState.endEmitted) {\n        return next()\n      }\n\n      stream.on('merge2UnpipeEnd', onend)\n      stream.on('end', onend)\n\n      if (doPipeError) {\n        stream.on('error', onerror)\n      }\n\n      stream.pipe(mergedStream, { end: false })\n      // compatible for old stream\n      stream.resume()\n    }\n\n    for (let i = 0; i < streams.length; i++) {\n      pipe(streams[i])\n    }\n\n    next()\n  }\n\n  function endStream () {\n    merging = false\n    // emit 'queueDrain' when all streams merged.\n    mergedStream.emit('queueDrain')\n    if (doEnd) {\n      mergedStream.end()\n    }\n  }\n\n  mergedStream.setMaxListeners(0)\n  mergedStream.add = addStream\n  mergedStream.on('unpipe', function (stream) {\n    stream.emit('merge2UnpipeEnd')\n  })\n\n  if (args.length) {\n    addStream.apply(null, args)\n  }\n  return mergedStream\n}\n\n// check and pause streams for pipe.\nfunction pauseStreams (streams, options) {\n  if (!Array.isArray(streams)) {\n    // Backwards-compat with old-style streams\n    if (!streams._readableState && streams.pipe) {\n      streams = streams.pipe(PassThrough(options))\n    }\n    if (!streams._readableState || !streams.pause || !streams.pipe) {\n      throw new Error('Only readable stream can be merged.')\n    }\n    streams.pause()\n  } else {\n    for (let i = 0, len = streams.length; i < len; i++) {\n      streams[i] = pauseStreams(streams[i], options)\n    }\n  }\n  return streams\n}\n","'use strict';\n\nconst util = require('util');\nconst braces = require('braces');\nconst picomatch = require('picomatch');\nconst utils = require('picomatch/lib/utils');\nconst isEmptyString = val => typeof val === 'string' && (val === '' || val === './');\n\n/**\n * Returns an array of strings that match one or more glob patterns.\n *\n * ```js\n * const mm = require('micromatch');\n * // mm(list, patterns[, options]);\n *\n * console.log(mm(['a.js', 'a.txt'], ['*.js']));\n * //=> [ 'a.js' ]\n * ```\n * @param {String|Array<string>} list List of strings to match.\n * @param {String|Array<string>} patterns One or more glob patterns to use for matching.\n * @param {Object} options See available [options](#options)\n * @return {Array} Returns an array of matches\n * @summary false\n * @api public\n */\n\nconst micromatch = (list, patterns, options) => {\n  patterns = [].concat(patterns);\n  list = [].concat(list);\n\n  let omit = new Set();\n  let keep = new Set();\n  let items = new Set();\n  let negatives = 0;\n\n  let onResult = state => {\n    items.add(state.output);\n    if (options && options.onResult) {\n      options.onResult(state);\n    }\n  };\n\n  for (let i = 0; i < patterns.length; i++) {\n    let isMatch = picomatch(String(patterns[i]), { ...options, onResult }, true);\n    let negated = isMatch.state.negated || isMatch.state.negatedExtglob;\n    if (negated) negatives++;\n\n    for (let item of list) {\n      let matched = isMatch(item, true);\n\n      let match = negated ? !matched.isMatch : matched.isMatch;\n      if (!match) continue;\n\n      if (negated) {\n        omit.add(matched.output);\n      } else {\n        omit.delete(matched.output);\n        keep.add(matched.output);\n      }\n    }\n  }\n\n  let result = negatives === patterns.length ? [...items] : [...keep];\n  let matches = result.filter(item => !omit.has(item));\n\n  if (options && matches.length === 0) {\n    if (options.failglob === true) {\n      throw new Error(`No matches found for \"${patterns.join(', ')}\"`);\n    }\n\n    if (options.nonull === true || options.nullglob === true) {\n      return options.unescape ? patterns.map(p => p.replace(/\\\\/g, '')) : patterns;\n    }\n  }\n\n  return matches;\n};\n\n/**\n * Backwards compatibility\n */\n\nmicromatch.match = micromatch;\n\n/**\n * Returns a matcher function from the given glob `pattern` and `options`.\n * The returned function takes a string to match as its only argument and returns\n * true if the string is a match.\n *\n * ```js\n * const mm = require('micromatch');\n * // mm.matcher(pattern[, options]);\n *\n * const isMatch = mm.matcher('*.!(*a)');\n * console.log(isMatch('a.a')); //=> false\n * console.log(isMatch('a.b')); //=> true\n * ```\n * @param {String} `pattern` Glob pattern\n * @param {Object} `options`\n * @return {Function} Returns a matcher function.\n * @api public\n */\n\nmicromatch.matcher = (pattern, options) => picomatch(pattern, options);\n\n/**\n * Returns true if **any** of the given glob `patterns` match the specified `string`.\n *\n * ```js\n * const mm = require('micromatch');\n * // mm.isMatch(string, patterns[, options]);\n *\n * console.log(mm.isMatch('a.a', ['b.*', '*.a'])); //=> true\n * console.log(mm.isMatch('a.a', 'b.*')); //=> false\n * ```\n * @param {String} str The string to test.\n * @param {String|Array} patterns One or more glob patterns to use for matching.\n * @param {Object} [options] See available [options](#options).\n * @return {Boolean} Returns true if any patterns match `str`\n * @api public\n */\n\nmicromatch.isMatch = (str, patterns, options) => picomatch(patterns, options)(str);\n\n/**\n * Backwards compatibility\n */\n\nmicromatch.any = micromatch.isMatch;\n\n/**\n * Returns a list of strings that _**do not match any**_ of the given `patterns`.\n *\n * ```js\n * const mm = require('micromatch');\n * // mm.not(list, patterns[, options]);\n *\n * console.log(mm.not(['a.a', 'b.b', 'c.c'], '*.a'));\n * //=> ['b.b', 'c.c']\n * ```\n * @param {Array} `list` Array of strings to match.\n * @param {String|Array} `patterns` One or more glob pattern to use for matching.\n * @param {Object} `options` See available [options](#options) for changing how matches are performed\n * @return {Array} Returns an array of strings that **do not match** the given patterns.\n * @api public\n */\n\nmicromatch.not = (list, patterns, options = {}) => {\n  patterns = [].concat(patterns).map(String);\n  let result = new Set();\n  let items = [];\n\n  let onResult = state => {\n    if (options.onResult) options.onResult(state);\n    items.push(state.output);\n  };\n\n  let matches = micromatch(list, patterns, { ...options, onResult });\n\n  for (let item of items) {\n    if (!matches.includes(item)) {\n      result.add(item);\n    }\n  }\n  return [...result];\n};\n\n/**\n * Returns true if the given `string` contains the given pattern. Similar\n * to [.isMatch](#isMatch) but the pattern can match any part of the string.\n *\n * ```js\n * var mm = require('micromatch');\n * // mm.contains(string, pattern[, options]);\n *\n * console.log(mm.contains('aa/bb/cc', '*b'));\n * //=> true\n * console.log(mm.contains('aa/bb/cc', '*d'));\n * //=> false\n * ```\n * @param {String} `str` The string to match.\n * @param {String|Array} `patterns` Glob pattern to use for matching.\n * @param {Object} `options` See available [options](#options) for changing how matches are performed\n * @return {Boolean} Returns true if the patter matches any part of `str`.\n * @api public\n */\n\nmicromatch.contains = (str, pattern, options) => {\n  if (typeof str !== 'string') {\n    throw new TypeError(`Expected a string: \"${util.inspect(str)}\"`);\n  }\n\n  if (Array.isArray(pattern)) {\n    return pattern.some(p => micromatch.contains(str, p, options));\n  }\n\n  if (typeof pattern === 'string') {\n    if (isEmptyString(str) || isEmptyString(pattern)) {\n      return false;\n    }\n\n    if (str.includes(pattern) || (str.startsWith('./') && str.slice(2).includes(pattern))) {\n      return true;\n    }\n  }\n\n  return micromatch.isMatch(str, pattern, { ...options, contains: true });\n};\n\n/**\n * Filter the keys of the given object with the given `glob` pattern\n * and `options`. Does not attempt to match nested keys. If you need this feature,\n * use [glob-object][] instead.\n *\n * ```js\n * const mm = require('micromatch');\n * // mm.matchKeys(object, patterns[, options]);\n *\n * const obj = { aa: 'a', ab: 'b', ac: 'c' };\n * console.log(mm.matchKeys(obj, '*b'));\n * //=> { ab: 'b' }\n * ```\n * @param {Object} `object` The object with keys to filter.\n * @param {String|Array} `patterns` One or more glob patterns to use for matching.\n * @param {Object} `options` See available [options](#options) for changing how matches are performed\n * @return {Object} Returns an object with only keys that match the given patterns.\n * @api public\n */\n\nmicromatch.matchKeys = (obj, patterns, options) => {\n  if (!utils.isObject(obj)) {\n    throw new TypeError('Expected the first argument to be an object');\n  }\n  let keys = micromatch(Object.keys(obj), patterns, options);\n  let res = {};\n  for (let key of keys) res[key] = obj[key];\n  return res;\n};\n\n/**\n * Returns true if some of the strings in the given `list` match any of the given glob `patterns`.\n *\n * ```js\n * const mm = require('micromatch');\n * // mm.some(list, patterns[, options]);\n *\n * console.log(mm.some(['foo.js', 'bar.js'], ['*.js', '!foo.js']));\n * // true\n * console.log(mm.some(['foo.js'], ['*.js', '!foo.js']));\n * // false\n * ```\n * @param {String|Array} `list` The string or array of strings to test. Returns as soon as the first match is found.\n * @param {String|Array} `patterns` One or more glob patterns to use for matching.\n * @param {Object} `options` See available [options](#options) for changing how matches are performed\n * @return {Boolean} Returns true if any patterns match `str`\n * @api public\n */\n\nmicromatch.some = (list, patterns, options) => {\n  let items = [].concat(list);\n\n  for (let pattern of [].concat(patterns)) {\n    let isMatch = picomatch(String(pattern), options);\n    if (items.some(item => isMatch(item))) {\n      return true;\n    }\n  }\n  return false;\n};\n\n/**\n * Returns true if every string in the given `list` matches\n * any of the given glob `patterns`.\n *\n * ```js\n * const mm = require('micromatch');\n * // mm.every(list, patterns[, options]);\n *\n * console.log(mm.every('foo.js', ['foo.js']));\n * // true\n * console.log(mm.every(['foo.js', 'bar.js'], ['*.js']));\n * // true\n * console.log(mm.every(['foo.js', 'bar.js'], ['*.js', '!foo.js']));\n * // false\n * console.log(mm.every(['foo.js'], ['*.js', '!foo.js']));\n * // false\n * ```\n * @param {String|Array} `list` The string or array of strings to test.\n * @param {String|Array} `patterns` One or more glob patterns to use for matching.\n * @param {Object} `options` See available [options](#options) for changing how matches are performed\n * @return {Boolean} Returns true if any patterns match `str`\n * @api public\n */\n\nmicromatch.every = (list, patterns, options) => {\n  let items = [].concat(list);\n\n  for (let pattern of [].concat(patterns)) {\n    let isMatch = picomatch(String(pattern), options);\n    if (!items.every(item => isMatch(item))) {\n      return false;\n    }\n  }\n  return true;\n};\n\n/**\n * Returns true if **all** of the given `patterns` match\n * the specified string.\n *\n * ```js\n * const mm = require('micromatch');\n * // mm.all(string, patterns[, options]);\n *\n * console.log(mm.all('foo.js', ['foo.js']));\n * // true\n *\n * console.log(mm.all('foo.js', ['*.js', '!foo.js']));\n * // false\n *\n * console.log(mm.all('foo.js', ['*.js', 'foo.js']));\n * // true\n *\n * console.log(mm.all('foo.js', ['*.js', 'f*', '*o*', '*o.js']));\n * // true\n * ```\n * @param {String|Array} `str` The string to test.\n * @param {String|Array} `patterns` One or more glob patterns to use for matching.\n * @param {Object} `options` See available [options](#options) for changing how matches are performed\n * @return {Boolean} Returns true if any patterns match `str`\n * @api public\n */\n\nmicromatch.all = (str, patterns, options) => {\n  if (typeof str !== 'string') {\n    throw new TypeError(`Expected a string: \"${util.inspect(str)}\"`);\n  }\n\n  return [].concat(patterns).every(p => picomatch(p, options)(str));\n};\n\n/**\n * Returns an array of matches captured by `pattern` in `string, or `null` if the pattern did not match.\n *\n * ```js\n * const mm = require('micromatch');\n * // mm.capture(pattern, string[, options]);\n *\n * console.log(mm.capture('test/*.js', 'test/foo.js'));\n * //=> ['foo']\n * console.log(mm.capture('test/*.js', 'foo/bar.css'));\n * //=> null\n * ```\n * @param {String} `glob` Glob pattern to use for matching.\n * @param {String} `input` String to match\n * @param {Object} `options` See available [options](#options) for changing how matches are performed\n * @return {Boolean} Returns an array of captures if the input matches the glob pattern, otherwise `null`.\n * @api public\n */\n\nmicromatch.capture = (glob, input, options) => {\n  let posix = utils.isWindows(options);\n  let regex = picomatch.makeRe(String(glob), { ...options, capture: true });\n  let match = regex.exec(posix ? utils.toPosixSlashes(input) : input);\n\n  if (match) {\n    return match.slice(1).map(v => v === void 0 ? '' : v);\n  }\n};\n\n/**\n * Create a regular expression from the given glob `pattern`.\n *\n * ```js\n * const mm = require('micromatch');\n * // mm.makeRe(pattern[, options]);\n *\n * console.log(mm.makeRe('*.js'));\n * //=> /^(?:(\\.[\\\\\\/])?(?!\\.)(?=.)[^\\/]*?\\.js)$/\n * ```\n * @param {String} `pattern` A glob pattern to convert to regex.\n * @param {Object} `options`\n * @return {RegExp} Returns a regex created from the given pattern.\n * @api public\n */\n\nmicromatch.makeRe = (...args) => picomatch.makeRe(...args);\n\n/**\n * Scan a glob pattern to separate the pattern into segments. Used\n * by the [split](#split) method.\n *\n * ```js\n * const mm = require('micromatch');\n * const state = mm.scan(pattern[, options]);\n * ```\n * @param {String} `pattern`\n * @param {Object} `options`\n * @return {Object} Returns an object with\n * @api public\n */\n\nmicromatch.scan = (...args) => picomatch.scan(...args);\n\n/**\n * Parse a glob pattern to create the source string for a regular\n * expression.\n *\n * ```js\n * const mm = require('micromatch');\n * const state = mm(pattern[, options]);\n * ```\n * @param {String} `glob`\n * @param {Object} `options`\n * @return {Object} Returns an object with useful properties and output to be used as regex source string.\n * @api public\n */\n\nmicromatch.parse = (patterns, options) => {\n  let res = [];\n  for (let pattern of [].concat(patterns || [])) {\n    for (let str of braces(String(pattern), options)) {\n      res.push(picomatch.parse(str, options));\n    }\n  }\n  return res;\n};\n\n/**\n * Process the given brace `pattern`.\n *\n * ```js\n * const { braces } = require('micromatch');\n * console.log(braces('foo/{a,b,c}/bar'));\n * //=> [ 'foo/(a|b|c)/bar' ]\n *\n * console.log(braces('foo/{a,b,c}/bar', { expand: true }));\n * //=> [ 'foo/a/bar', 'foo/b/bar', 'foo/c/bar' ]\n * ```\n * @param {String} `pattern` String with brace pattern to process.\n * @param {Object} `options` Any [options](#options) to change how expansion is performed. See the [braces][] library for all available options.\n * @return {Array}\n * @api public\n */\n\nmicromatch.braces = (pattern, options) => {\n  if (typeof pattern !== 'string') throw new TypeError('Expected a string');\n  if ((options && options.nobrace === true) || !/\\{.*\\}/.test(pattern)) {\n    return [pattern];\n  }\n  return braces(pattern, options);\n};\n\n/**\n * Expand braces\n */\n\nmicromatch.braceExpand = (pattern, options) => {\n  if (typeof pattern !== 'string') throw new TypeError('Expected a string');\n  return micromatch.braces(pattern, { ...options, expand: true });\n};\n\n/**\n * Expose micromatch\n */\n\nmodule.exports = micromatch;\n","'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nfunction _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }\n\nvar Stream = _interopDefault(require('stream'));\nvar http = _interopDefault(require('http'));\nvar Url = _interopDefault(require('url'));\nvar https = _interopDefault(require('https'));\nvar zlib = _interopDefault(require('zlib'));\n\n// Based on https://github.com/tmpvar/jsdom/blob/aa85b2abf07766ff7bf5c1f6daafb3726f2f2db5/lib/jsdom/living/blob.js\n\n// fix for \"Readable\" isn't a named export issue\nconst Readable = Stream.Readable;\n\nconst BUFFER = Symbol('buffer');\nconst TYPE = Symbol('type');\n\nclass Blob {\n\tconstructor() {\n\t\tthis[TYPE] = '';\n\n\t\tconst blobParts = arguments[0];\n\t\tconst options = arguments[1];\n\n\t\tconst buffers = [];\n\t\tlet size = 0;\n\n\t\tif (blobParts) {\n\t\t\tconst a = blobParts;\n\t\t\tconst length = Number(a.length);\n\t\t\tfor (let i = 0; i < length; i++) {\n\t\t\t\tconst element = a[i];\n\t\t\t\tlet buffer;\n\t\t\t\tif (element instanceof Buffer) {\n\t\t\t\t\tbuffer = element;\n\t\t\t\t} else if (ArrayBuffer.isView(element)) {\n\t\t\t\t\tbuffer = Buffer.from(element.buffer, element.byteOffset, element.byteLength);\n\t\t\t\t} else if (element instanceof ArrayBuffer) {\n\t\t\t\t\tbuffer = Buffer.from(element);\n\t\t\t\t} else if (element instanceof Blob) {\n\t\t\t\t\tbuffer = element[BUFFER];\n\t\t\t\t} else {\n\t\t\t\t\tbuffer = Buffer.from(typeof element === 'string' ? element : String(element));\n\t\t\t\t}\n\t\t\t\tsize += buffer.length;\n\t\t\t\tbuffers.push(buffer);\n\t\t\t}\n\t\t}\n\n\t\tthis[BUFFER] = Buffer.concat(buffers);\n\n\t\tlet type = options && options.type !== undefined && String(options.type).toLowerCase();\n\t\tif (type && !/[^\\u0020-\\u007E]/.test(type)) {\n\t\t\tthis[TYPE] = type;\n\t\t}\n\t}\n\tget size() {\n\t\treturn this[BUFFER].length;\n\t}\n\tget type() {\n\t\treturn this[TYPE];\n\t}\n\ttext() {\n\t\treturn Promise.resolve(this[BUFFER].toString());\n\t}\n\tarrayBuffer() {\n\t\tconst buf = this[BUFFER];\n\t\tconst ab = buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);\n\t\treturn Promise.resolve(ab);\n\t}\n\tstream() {\n\t\tconst readable = new Readable();\n\t\treadable._read = function () {};\n\t\treadable.push(this[BUFFER]);\n\t\treadable.push(null);\n\t\treturn readable;\n\t}\n\ttoString() {\n\t\treturn '[object Blob]';\n\t}\n\tslice() {\n\t\tconst size = this.size;\n\n\t\tconst start = arguments[0];\n\t\tconst end = arguments[1];\n\t\tlet relativeStart, relativeEnd;\n\t\tif (start === undefined) {\n\t\t\trelativeStart = 0;\n\t\t} else if (start < 0) {\n\t\t\trelativeStart = Math.max(size + start, 0);\n\t\t} else {\n\t\t\trelativeStart = Math.min(start, size);\n\t\t}\n\t\tif (end === undefined) {\n\t\t\trelativeEnd = size;\n\t\t} else if (end < 0) {\n\t\t\trelativeEnd = Math.max(size + end, 0);\n\t\t} else {\n\t\t\trelativeEnd = Math.min(end, size);\n\t\t}\n\t\tconst span = Math.max(relativeEnd - relativeStart, 0);\n\n\t\tconst buffer = this[BUFFER];\n\t\tconst slicedBuffer = buffer.slice(relativeStart, relativeStart + span);\n\t\tconst blob = new Blob([], { type: arguments[2] });\n\t\tblob[BUFFER] = slicedBuffer;\n\t\treturn blob;\n\t}\n}\n\nObject.defineProperties(Blob.prototype, {\n\tsize: { enumerable: true },\n\ttype: { enumerable: true },\n\tslice: { enumerable: true }\n});\n\nObject.defineProperty(Blob.prototype, Symbol.toStringTag, {\n\tvalue: 'Blob',\n\twritable: false,\n\tenumerable: false,\n\tconfigurable: true\n});\n\n/**\n * fetch-error.js\n *\n * FetchError interface for operational errors\n */\n\n/**\n * Create FetchError instance\n *\n * @param   String      message      Error message for human\n * @param   String      type         Error type for machine\n * @param   String      systemError  For Node.js system error\n * @return  FetchError\n */\nfunction FetchError(message, type, systemError) {\n  Error.call(this, message);\n\n  this.message = message;\n  this.type = type;\n\n  // when err.type is `system`, err.code contains system error code\n  if (systemError) {\n    this.code = this.errno = systemError.code;\n  }\n\n  // hide custom error implementation details from end-users\n  Error.captureStackTrace(this, this.constructor);\n}\n\nFetchError.prototype = Object.create(Error.prototype);\nFetchError.prototype.constructor = FetchError;\nFetchError.prototype.name = 'FetchError';\n\nlet convert;\ntry {\n\tconvert = require('encoding').convert;\n} catch (e) {}\n\nconst INTERNALS = Symbol('Body internals');\n\n// fix an issue where \"PassThrough\" isn't a named export for node <10\nconst PassThrough = Stream.PassThrough;\n\n/**\n * Body mixin\n *\n * Ref: https://fetch.spec.whatwg.org/#body\n *\n * @param   Stream  body  Readable stream\n * @param   Object  opts  Response options\n * @return  Void\n */\nfunction Body(body) {\n\tvar _this = this;\n\n\tvar _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n\t    _ref$size = _ref.size;\n\n\tlet size = _ref$size === undefined ? 0 : _ref$size;\n\tvar _ref$timeout = _ref.timeout;\n\tlet timeout = _ref$timeout === undefined ? 0 : _ref$timeout;\n\n\tif (body == null) {\n\t\t// body is undefined or null\n\t\tbody = null;\n\t} else if (isURLSearchParams(body)) {\n\t\t// body is a URLSearchParams\n\t\tbody = Buffer.from(body.toString());\n\t} else if (isBlob(body)) ; else if (Buffer.isBuffer(body)) ; else if (Object.prototype.toString.call(body) === '[object ArrayBuffer]') {\n\t\t// body is ArrayBuffer\n\t\tbody = Buffer.from(body);\n\t} else if (ArrayBuffer.isView(body)) {\n\t\t// body is ArrayBufferView\n\t\tbody = Buffer.from(body.buffer, body.byteOffset, body.byteLength);\n\t} else if (body instanceof Stream) ; else {\n\t\t// none of the above\n\t\t// coerce to string then buffer\n\t\tbody = Buffer.from(String(body));\n\t}\n\tthis[INTERNALS] = {\n\t\tbody,\n\t\tdisturbed: false,\n\t\terror: null\n\t};\n\tthis.size = size;\n\tthis.timeout = timeout;\n\n\tif (body instanceof Stream) {\n\t\tbody.on('error', function (err) {\n\t\t\tconst error = err.name === 'AbortError' ? err : new FetchError(`Invalid response body while trying to fetch ${_this.url}: ${err.message}`, 'system', err);\n\t\t\t_this[INTERNALS].error = error;\n\t\t});\n\t}\n}\n\nBody.prototype = {\n\tget body() {\n\t\treturn this[INTERNALS].body;\n\t},\n\n\tget bodyUsed() {\n\t\treturn this[INTERNALS].disturbed;\n\t},\n\n\t/**\n  * Decode response as ArrayBuffer\n  *\n  * @return  Promise\n  */\n\tarrayBuffer() {\n\t\treturn consumeBody.call(this).then(function (buf) {\n\t\t\treturn buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);\n\t\t});\n\t},\n\n\t/**\n  * Return raw response as Blob\n  *\n  * @return Promise\n  */\n\tblob() {\n\t\tlet ct = this.headers && this.headers.get('content-type') || '';\n\t\treturn consumeBody.call(this).then(function (buf) {\n\t\t\treturn Object.assign(\n\t\t\t// Prevent copying\n\t\t\tnew Blob([], {\n\t\t\t\ttype: ct.toLowerCase()\n\t\t\t}), {\n\t\t\t\t[BUFFER]: buf\n\t\t\t});\n\t\t});\n\t},\n\n\t/**\n  * Decode response as json\n  *\n  * @return  Promise\n  */\n\tjson() {\n\t\tvar _this2 = this;\n\n\t\treturn consumeBody.call(this).then(function (buffer) {\n\t\t\ttry {\n\t\t\t\treturn JSON.parse(buffer.toString());\n\t\t\t} catch (err) {\n\t\t\t\treturn Body.Promise.reject(new FetchError(`invalid json response body at ${_this2.url} reason: ${err.message}`, 'invalid-json'));\n\t\t\t}\n\t\t});\n\t},\n\n\t/**\n  * Decode response as text\n  *\n  * @return  Promise\n  */\n\ttext() {\n\t\treturn consumeBody.call(this).then(function (buffer) {\n\t\t\treturn buffer.toString();\n\t\t});\n\t},\n\n\t/**\n  * Decode response as buffer (non-spec api)\n  *\n  * @return  Promise\n  */\n\tbuffer() {\n\t\treturn consumeBody.call(this);\n\t},\n\n\t/**\n  * Decode response as text, while automatically detecting the encoding and\n  * trying to decode to UTF-8 (non-spec api)\n  *\n  * @return  Promise\n  */\n\ttextConverted() {\n\t\tvar _this3 = this;\n\n\t\treturn consumeBody.call(this).then(function (buffer) {\n\t\t\treturn convertBody(buffer, _this3.headers);\n\t\t});\n\t}\n};\n\n// In browsers, all properties are enumerable.\nObject.defineProperties(Body.prototype, {\n\tbody: { enumerable: true },\n\tbodyUsed: { enumerable: true },\n\tarrayBuffer: { enumerable: true },\n\tblob: { enumerable: true },\n\tjson: { enumerable: true },\n\ttext: { enumerable: true }\n});\n\nBody.mixIn = function (proto) {\n\tfor (const name of Object.getOwnPropertyNames(Body.prototype)) {\n\t\t// istanbul ignore else: future proof\n\t\tif (!(name in proto)) {\n\t\t\tconst desc = Object.getOwnPropertyDescriptor(Body.prototype, name);\n\t\t\tObject.defineProperty(proto, name, desc);\n\t\t}\n\t}\n};\n\n/**\n * Consume and convert an entire Body to a Buffer.\n *\n * Ref: https://fetch.spec.whatwg.org/#concept-body-consume-body\n *\n * @return  Promise\n */\nfunction consumeBody() {\n\tvar _this4 = this;\n\n\tif (this[INTERNALS].disturbed) {\n\t\treturn Body.Promise.reject(new TypeError(`body used already for: ${this.url}`));\n\t}\n\n\tthis[INTERNALS].disturbed = true;\n\n\tif (this[INTERNALS].error) {\n\t\treturn Body.Promise.reject(this[INTERNALS].error);\n\t}\n\n\tlet body = this.body;\n\n\t// body is null\n\tif (body === null) {\n\t\treturn Body.Promise.resolve(Buffer.alloc(0));\n\t}\n\n\t// body is blob\n\tif (isBlob(body)) {\n\t\tbody = body.stream();\n\t}\n\n\t// body is buffer\n\tif (Buffer.isBuffer(body)) {\n\t\treturn Body.Promise.resolve(body);\n\t}\n\n\t// istanbul ignore if: should never happen\n\tif (!(body instanceof Stream)) {\n\t\treturn Body.Promise.resolve(Buffer.alloc(0));\n\t}\n\n\t// body is stream\n\t// get ready to actually consume the body\n\tlet accum = [];\n\tlet accumBytes = 0;\n\tlet abort = false;\n\n\treturn new Body.Promise(function (resolve, reject) {\n\t\tlet resTimeout;\n\n\t\t// allow timeout on slow response body\n\t\tif (_this4.timeout) {\n\t\t\tresTimeout = setTimeout(function () {\n\t\t\t\tabort = true;\n\t\t\t\treject(new FetchError(`Response timeout while trying to fetch ${_this4.url} (over ${_this4.timeout}ms)`, 'body-timeout'));\n\t\t\t}, _this4.timeout);\n\t\t}\n\n\t\t// handle stream errors\n\t\tbody.on('error', function (err) {\n\t\t\tif (err.name === 'AbortError') {\n\t\t\t\t// if the request was aborted, reject with this Error\n\t\t\t\tabort = true;\n\t\t\t\treject(err);\n\t\t\t} else {\n\t\t\t\t// other errors, such as incorrect content-encoding\n\t\t\t\treject(new FetchError(`Invalid response body while trying to fetch ${_this4.url}: ${err.message}`, 'system', err));\n\t\t\t}\n\t\t});\n\n\t\tbody.on('data', function (chunk) {\n\t\t\tif (abort || chunk === null) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (_this4.size && accumBytes + chunk.length > _this4.size) {\n\t\t\t\tabort = true;\n\t\t\t\treject(new FetchError(`content size at ${_this4.url} over limit: ${_this4.size}`, 'max-size'));\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\taccumBytes += chunk.length;\n\t\t\taccum.push(chunk);\n\t\t});\n\n\t\tbody.on('end', function () {\n\t\t\tif (abort) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tclearTimeout(resTimeout);\n\n\t\t\ttry {\n\t\t\t\tresolve(Buffer.concat(accum, accumBytes));\n\t\t\t} catch (err) {\n\t\t\t\t// handle streams that have accumulated too much data (issue #414)\n\t\t\t\treject(new FetchError(`Could not create Buffer from response body for ${_this4.url}: ${err.message}`, 'system', err));\n\t\t\t}\n\t\t});\n\t});\n}\n\n/**\n * Detect buffer encoding and convert to target encoding\n * ref: http://www.w3.org/TR/2011/WD-html5-20110113/parsing.html#determining-the-character-encoding\n *\n * @param   Buffer  buffer    Incoming buffer\n * @param   String  encoding  Target encoding\n * @return  String\n */\nfunction convertBody(buffer, headers) {\n\tif (typeof convert !== 'function') {\n\t\tthrow new Error('The package `encoding` must be installed to use the textConverted() function');\n\t}\n\n\tconst ct = headers.get('content-type');\n\tlet charset = 'utf-8';\n\tlet res, str;\n\n\t// header\n\tif (ct) {\n\t\tres = /charset=([^;]*)/i.exec(ct);\n\t}\n\n\t// no charset in content type, peek at response body for at most 1024 bytes\n\tstr = buffer.slice(0, 1024).toString();\n\n\t// html5\n\tif (!res && str) {\n\t\tres = /<meta.+?charset=(['\"])(.+?)\\1/i.exec(str);\n\t}\n\n\t// html4\n\tif (!res && str) {\n\t\tres = /<meta[\\s]+?http-equiv=(['\"])content-type\\1[\\s]+?content=(['\"])(.+?)\\2/i.exec(str);\n\t\tif (!res) {\n\t\t\tres = /<meta[\\s]+?content=(['\"])(.+?)\\1[\\s]+?http-equiv=(['\"])content-type\\3/i.exec(str);\n\t\t\tif (res) {\n\t\t\t\tres.pop(); // drop last quote\n\t\t\t}\n\t\t}\n\n\t\tif (res) {\n\t\t\tres = /charset=(.*)/i.exec(res.pop());\n\t\t}\n\t}\n\n\t// xml\n\tif (!res && str) {\n\t\tres = /<\\?xml.+?encoding=(['\"])(.+?)\\1/i.exec(str);\n\t}\n\n\t// found charset\n\tif (res) {\n\t\tcharset = res.pop();\n\n\t\t// prevent decode issues when sites use incorrect encoding\n\t\t// ref: https://hsivonen.fi/encoding-menu/\n\t\tif (charset === 'gb2312' || charset === 'gbk') {\n\t\t\tcharset = 'gb18030';\n\t\t}\n\t}\n\n\t// turn raw buffers into a single utf-8 buffer\n\treturn convert(buffer, 'UTF-8', charset).toString();\n}\n\n/**\n * Detect a URLSearchParams object\n * ref: https://github.com/bitinn/node-fetch/issues/296#issuecomment-307598143\n *\n * @param   Object  obj     Object to detect by type or brand\n * @return  String\n */\nfunction isURLSearchParams(obj) {\n\t// Duck-typing as a necessary condition.\n\tif (typeof obj !== 'object' || typeof obj.append !== 'function' || typeof obj.delete !== 'function' || typeof obj.get !== 'function' || typeof obj.getAll !== 'function' || typeof obj.has !== 'function' || typeof obj.set !== 'function') {\n\t\treturn false;\n\t}\n\n\t// Brand-checking and more duck-typing as optional condition.\n\treturn obj.constructor.name === 'URLSearchParams' || Object.prototype.toString.call(obj) === '[object URLSearchParams]' || typeof obj.sort === 'function';\n}\n\n/**\n * Check if `obj` is a W3C `Blob` object (which `File` inherits from)\n * @param  {*} obj\n * @return {boolean}\n */\nfunction isBlob(obj) {\n\treturn typeof obj === 'object' && typeof obj.arrayBuffer === 'function' && typeof obj.type === 'string' && typeof obj.stream === 'function' && typeof obj.constructor === 'function' && typeof obj.constructor.name === 'string' && /^(Blob|File)$/.test(obj.constructor.name) && /^(Blob|File)$/.test(obj[Symbol.toStringTag]);\n}\n\n/**\n * Clone body given Res/Req instance\n *\n * @param   Mixed  instance  Response or Request instance\n * @return  Mixed\n */\nfunction clone(instance) {\n\tlet p1, p2;\n\tlet body = instance.body;\n\n\t// don't allow cloning a used body\n\tif (instance.bodyUsed) {\n\t\tthrow new Error('cannot clone body after it is used');\n\t}\n\n\t// check that body is a stream and not form-data object\n\t// note: we can't clone the form-data object without having it as a dependency\n\tif (body instanceof Stream && typeof body.getBoundary !== 'function') {\n\t\t// tee instance body\n\t\tp1 = new PassThrough();\n\t\tp2 = new PassThrough();\n\t\tbody.pipe(p1);\n\t\tbody.pipe(p2);\n\t\t// set instance body to teed body and return the other teed body\n\t\tinstance[INTERNALS].body = p1;\n\t\tbody = p2;\n\t}\n\n\treturn body;\n}\n\n/**\n * Performs the operation \"extract a `Content-Type` value from |object|\" as\n * specified in the specification:\n * https://fetch.spec.whatwg.org/#concept-bodyinit-extract\n *\n * This function assumes that instance.body is present.\n *\n * @param   Mixed  instance  Any options.body input\n */\nfunction extractContentType(body) {\n\tif (body === null) {\n\t\t// body is null\n\t\treturn null;\n\t} else if (typeof body === 'string') {\n\t\t// body is string\n\t\treturn 'text/plain;charset=UTF-8';\n\t} else if (isURLSearchParams(body)) {\n\t\t// body is a URLSearchParams\n\t\treturn 'application/x-www-form-urlencoded;charset=UTF-8';\n\t} else if (isBlob(body)) {\n\t\t// body is blob\n\t\treturn body.type || null;\n\t} else if (Buffer.isBuffer(body)) {\n\t\t// body is buffer\n\t\treturn null;\n\t} else if (Object.prototype.toString.call(body) === '[object ArrayBuffer]') {\n\t\t// body is ArrayBuffer\n\t\treturn null;\n\t} else if (ArrayBuffer.isView(body)) {\n\t\t// body is ArrayBufferView\n\t\treturn null;\n\t} else if (typeof body.getBoundary === 'function') {\n\t\t// detect form data input from form-data module\n\t\treturn `multipart/form-data;boundary=${body.getBoundary()}`;\n\t} else if (body instanceof Stream) {\n\t\t// body is stream\n\t\t// can't really do much about this\n\t\treturn null;\n\t} else {\n\t\t// Body constructor defaults other things to string\n\t\treturn 'text/plain;charset=UTF-8';\n\t}\n}\n\n/**\n * The Fetch Standard treats this as if \"total bytes\" is a property on the body.\n * For us, we have to explicitly get it with a function.\n *\n * ref: https://fetch.spec.whatwg.org/#concept-body-total-bytes\n *\n * @param   Body    instance   Instance of Body\n * @return  Number?            Number of bytes, or null if not possible\n */\nfunction getTotalBytes(instance) {\n\tconst body = instance.body;\n\n\n\tif (body === null) {\n\t\t// body is null\n\t\treturn 0;\n\t} else if (isBlob(body)) {\n\t\treturn body.size;\n\t} else if (Buffer.isBuffer(body)) {\n\t\t// body is buffer\n\t\treturn body.length;\n\t} else if (body && typeof body.getLengthSync === 'function') {\n\t\t// detect form data input from form-data module\n\t\tif (body._lengthRetrievers && body._lengthRetrievers.length == 0 || // 1.x\n\t\tbody.hasKnownLength && body.hasKnownLength()) {\n\t\t\t// 2.x\n\t\t\treturn body.getLengthSync();\n\t\t}\n\t\treturn null;\n\t} else {\n\t\t// body is stream\n\t\treturn null;\n\t}\n}\n\n/**\n * Write a Body to a Node.js WritableStream (e.g. http.Request) object.\n *\n * @param   Body    instance   Instance of Body\n * @return  Void\n */\nfunction writeToStream(dest, instance) {\n\tconst body = instance.body;\n\n\n\tif (body === null) {\n\t\t// body is null\n\t\tdest.end();\n\t} else if (isBlob(body)) {\n\t\tbody.stream().pipe(dest);\n\t} else if (Buffer.isBuffer(body)) {\n\t\t// body is buffer\n\t\tdest.write(body);\n\t\tdest.end();\n\t} else {\n\t\t// body is stream\n\t\tbody.pipe(dest);\n\t}\n}\n\n// expose Promise\nBody.Promise = global.Promise;\n\n/**\n * headers.js\n *\n * Headers class offers convenient helpers\n */\n\nconst invalidTokenRegex = /[^\\^_`a-zA-Z\\-0-9!#$%&'*+.|~]/;\nconst invalidHeaderCharRegex = /[^\\t\\x20-\\x7e\\x80-\\xff]/;\n\nfunction validateName(name) {\n\tname = `${name}`;\n\tif (invalidTokenRegex.test(name) || name === '') {\n\t\tthrow new TypeError(`${name} is not a legal HTTP header name`);\n\t}\n}\n\nfunction validateValue(value) {\n\tvalue = `${value}`;\n\tif (invalidHeaderCharRegex.test(value)) {\n\t\tthrow new TypeError(`${value} is not a legal HTTP header value`);\n\t}\n}\n\n/**\n * Find the key in the map object given a header name.\n *\n * Returns undefined if not found.\n *\n * @param   String  name  Header name\n * @return  String|Undefined\n */\nfunction find(map, name) {\n\tname = name.toLowerCase();\n\tfor (const key in map) {\n\t\tif (key.toLowerCase() === name) {\n\t\t\treturn key;\n\t\t}\n\t}\n\treturn undefined;\n}\n\nconst MAP = Symbol('map');\nclass Headers {\n\t/**\n  * Headers class\n  *\n  * @param   Object  headers  Response headers\n  * @return  Void\n  */\n\tconstructor() {\n\t\tlet init = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : undefined;\n\n\t\tthis[MAP] = Object.create(null);\n\n\t\tif (init instanceof Headers) {\n\t\t\tconst rawHeaders = init.raw();\n\t\t\tconst headerNames = Object.keys(rawHeaders);\n\n\t\t\tfor (const headerName of headerNames) {\n\t\t\t\tfor (const value of rawHeaders[headerName]) {\n\t\t\t\t\tthis.append(headerName, value);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn;\n\t\t}\n\n\t\t// We don't worry about converting prop to ByteString here as append()\n\t\t// will handle it.\n\t\tif (init == null) ; else if (typeof init === 'object') {\n\t\t\tconst method = init[Symbol.iterator];\n\t\t\tif (method != null) {\n\t\t\t\tif (typeof method !== 'function') {\n\t\t\t\t\tthrow new TypeError('Header pairs must be iterable');\n\t\t\t\t}\n\n\t\t\t\t// sequence<sequence<ByteString>>\n\t\t\t\t// Note: per spec we have to first exhaust the lists then process them\n\t\t\t\tconst pairs = [];\n\t\t\t\tfor (const pair of init) {\n\t\t\t\t\tif (typeof pair !== 'object' || typeof pair[Symbol.iterator] !== 'function') {\n\t\t\t\t\t\tthrow new TypeError('Each header pair must be iterable');\n\t\t\t\t\t}\n\t\t\t\t\tpairs.push(Array.from(pair));\n\t\t\t\t}\n\n\t\t\t\tfor (const pair of pairs) {\n\t\t\t\t\tif (pair.length !== 2) {\n\t\t\t\t\t\tthrow new TypeError('Each header pair must be a name/value tuple');\n\t\t\t\t\t}\n\t\t\t\t\tthis.append(pair[0], pair[1]);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// record<ByteString, ByteString>\n\t\t\t\tfor (const key of Object.keys(init)) {\n\t\t\t\t\tconst value = init[key];\n\t\t\t\t\tthis.append(key, value);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tthrow new TypeError('Provided initializer must be an object');\n\t\t}\n\t}\n\n\t/**\n  * Return combined header value given name\n  *\n  * @param   String  name  Header name\n  * @return  Mixed\n  */\n\tget(name) {\n\t\tname = `${name}`;\n\t\tvalidateName(name);\n\t\tconst key = find(this[MAP], name);\n\t\tif (key === undefined) {\n\t\t\treturn null;\n\t\t}\n\n\t\treturn this[MAP][key].join(', ');\n\t}\n\n\t/**\n  * Iterate over all headers\n  *\n  * @param   Function  callback  Executed for each item with parameters (value, name, thisArg)\n  * @param   Boolean   thisArg   `this` context for callback function\n  * @return  Void\n  */\n\tforEach(callback) {\n\t\tlet thisArg = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;\n\n\t\tlet pairs = getHeaders(this);\n\t\tlet i = 0;\n\t\twhile (i < pairs.length) {\n\t\t\tvar _pairs$i = pairs[i];\n\t\t\tconst name = _pairs$i[0],\n\t\t\t      value = _pairs$i[1];\n\n\t\t\tcallback.call(thisArg, value, name, this);\n\t\t\tpairs = getHeaders(this);\n\t\t\ti++;\n\t\t}\n\t}\n\n\t/**\n  * Overwrite header values given name\n  *\n  * @param   String  name   Header name\n  * @param   String  value  Header value\n  * @return  Void\n  */\n\tset(name, value) {\n\t\tname = `${name}`;\n\t\tvalue = `${value}`;\n\t\tvalidateName(name);\n\t\tvalidateValue(value);\n\t\tconst key = find(this[MAP], name);\n\t\tthis[MAP][key !== undefined ? key : name] = [value];\n\t}\n\n\t/**\n  * Append a value onto existing header\n  *\n  * @param   String  name   Header name\n  * @param   String  value  Header value\n  * @return  Void\n  */\n\tappend(name, value) {\n\t\tname = `${name}`;\n\t\tvalue = `${value}`;\n\t\tvalidateName(name);\n\t\tvalidateValue(value);\n\t\tconst key = find(this[MAP], name);\n\t\tif (key !== undefined) {\n\t\t\tthis[MAP][key].push(value);\n\t\t} else {\n\t\t\tthis[MAP][name] = [value];\n\t\t}\n\t}\n\n\t/**\n  * Check for header name existence\n  *\n  * @param   String   name  Header name\n  * @return  Boolean\n  */\n\thas(name) {\n\t\tname = `${name}`;\n\t\tvalidateName(name);\n\t\treturn find(this[MAP], name) !== undefined;\n\t}\n\n\t/**\n  * Delete all header values given name\n  *\n  * @param   String  name  Header name\n  * @return  Void\n  */\n\tdelete(name) {\n\t\tname = `${name}`;\n\t\tvalidateName(name);\n\t\tconst key = find(this[MAP], name);\n\t\tif (key !== undefined) {\n\t\t\tdelete this[MAP][key];\n\t\t}\n\t}\n\n\t/**\n  * Return raw headers (non-spec api)\n  *\n  * @return  Object\n  */\n\traw() {\n\t\treturn this[MAP];\n\t}\n\n\t/**\n  * Get an iterator on keys.\n  *\n  * @return  Iterator\n  */\n\tkeys() {\n\t\treturn createHeadersIterator(this, 'key');\n\t}\n\n\t/**\n  * Get an iterator on values.\n  *\n  * @return  Iterator\n  */\n\tvalues() {\n\t\treturn createHeadersIterator(this, 'value');\n\t}\n\n\t/**\n  * Get an iterator on entries.\n  *\n  * This is the default iterator of the Headers object.\n  *\n  * @return  Iterator\n  */\n\t[Symbol.iterator]() {\n\t\treturn createHeadersIterator(this, 'key+value');\n\t}\n}\nHeaders.prototype.entries = Headers.prototype[Symbol.iterator];\n\nObject.defineProperty(Headers.prototype, Symbol.toStringTag, {\n\tvalue: 'Headers',\n\twritable: false,\n\tenumerable: false,\n\tconfigurable: true\n});\n\nObject.defineProperties(Headers.prototype, {\n\tget: { enumerable: true },\n\tforEach: { enumerable: true },\n\tset: { enumerable: true },\n\tappend: { enumerable: true },\n\thas: { enumerable: true },\n\tdelete: { enumerable: true },\n\tkeys: { enumerable: true },\n\tvalues: { enumerable: true },\n\tentries: { enumerable: true }\n});\n\nfunction getHeaders(headers) {\n\tlet kind = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'key+value';\n\n\tconst keys = Object.keys(headers[MAP]).sort();\n\treturn keys.map(kind === 'key' ? function (k) {\n\t\treturn k.toLowerCase();\n\t} : kind === 'value' ? function (k) {\n\t\treturn headers[MAP][k].join(', ');\n\t} : function (k) {\n\t\treturn [k.toLowerCase(), headers[MAP][k].join(', ')];\n\t});\n}\n\nconst INTERNAL = Symbol('internal');\n\nfunction createHeadersIterator(target, kind) {\n\tconst iterator = Object.create(HeadersIteratorPrototype);\n\titerator[INTERNAL] = {\n\t\ttarget,\n\t\tkind,\n\t\tindex: 0\n\t};\n\treturn iterator;\n}\n\nconst HeadersIteratorPrototype = Object.setPrototypeOf({\n\tnext() {\n\t\t// istanbul ignore if\n\t\tif (!this || Object.getPrototypeOf(this) !== HeadersIteratorPrototype) {\n\t\t\tthrow new TypeError('Value of `this` is not a HeadersIterator');\n\t\t}\n\n\t\tvar _INTERNAL = this[INTERNAL];\n\t\tconst target = _INTERNAL.target,\n\t\t      kind = _INTERNAL.kind,\n\t\t      index = _INTERNAL.index;\n\n\t\tconst values = getHeaders(target, kind);\n\t\tconst len = values.length;\n\t\tif (index >= len) {\n\t\t\treturn {\n\t\t\t\tvalue: undefined,\n\t\t\t\tdone: true\n\t\t\t};\n\t\t}\n\n\t\tthis[INTERNAL].index = index + 1;\n\n\t\treturn {\n\t\t\tvalue: values[index],\n\t\t\tdone: false\n\t\t};\n\t}\n}, Object.getPrototypeOf(Object.getPrototypeOf([][Symbol.iterator]())));\n\nObject.defineProperty(HeadersIteratorPrototype, Symbol.toStringTag, {\n\tvalue: 'HeadersIterator',\n\twritable: false,\n\tenumerable: false,\n\tconfigurable: true\n});\n\n/**\n * Export the Headers object in a form that Node.js can consume.\n *\n * @param   Headers  headers\n * @return  Object\n */\nfunction exportNodeCompatibleHeaders(headers) {\n\tconst obj = Object.assign({ __proto__: null }, headers[MAP]);\n\n\t// http.request() only supports string as Host header. This hack makes\n\t// specifying custom Host header possible.\n\tconst hostHeaderKey = find(headers[MAP], 'Host');\n\tif (hostHeaderKey !== undefined) {\n\t\tobj[hostHeaderKey] = obj[hostHeaderKey][0];\n\t}\n\n\treturn obj;\n}\n\n/**\n * Create a Headers object from an object of headers, ignoring those that do\n * not conform to HTTP grammar productions.\n *\n * @param   Object  obj  Object of headers\n * @return  Headers\n */\nfunction createHeadersLenient(obj) {\n\tconst headers = new Headers();\n\tfor (const name of Object.keys(obj)) {\n\t\tif (invalidTokenRegex.test(name)) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (Array.isArray(obj[name])) {\n\t\t\tfor (const val of obj[name]) {\n\t\t\t\tif (invalidHeaderCharRegex.test(val)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (headers[MAP][name] === undefined) {\n\t\t\t\t\theaders[MAP][name] = [val];\n\t\t\t\t} else {\n\t\t\t\t\theaders[MAP][name].push(val);\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (!invalidHeaderCharRegex.test(obj[name])) {\n\t\t\theaders[MAP][name] = [obj[name]];\n\t\t}\n\t}\n\treturn headers;\n}\n\nconst INTERNALS$1 = Symbol('Response internals');\n\n// fix an issue where \"STATUS_CODES\" aren't a named export for node <10\nconst STATUS_CODES = http.STATUS_CODES;\n\n/**\n * Response class\n *\n * @param   Stream  body  Readable stream\n * @param   Object  opts  Response options\n * @return  Void\n */\nclass Response {\n\tconstructor() {\n\t\tlet body = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n\t\tlet opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n\t\tBody.call(this, body, opts);\n\n\t\tconst status = opts.status || 200;\n\t\tconst headers = new Headers(opts.headers);\n\n\t\tif (body != null && !headers.has('Content-Type')) {\n\t\t\tconst contentType = extractContentType(body);\n\t\t\tif (contentType) {\n\t\t\t\theaders.append('Content-Type', contentType);\n\t\t\t}\n\t\t}\n\n\t\tthis[INTERNALS$1] = {\n\t\t\turl: opts.url,\n\t\t\tstatus,\n\t\t\tstatusText: opts.statusText || STATUS_CODES[status],\n\t\t\theaders,\n\t\t\tcounter: opts.counter\n\t\t};\n\t}\n\n\tget url() {\n\t\treturn this[INTERNALS$1].url || '';\n\t}\n\n\tget status() {\n\t\treturn this[INTERNALS$1].status;\n\t}\n\n\t/**\n  * Convenience property representing if the request ended normally\n  */\n\tget ok() {\n\t\treturn this[INTERNALS$1].status >= 200 && this[INTERNALS$1].status < 300;\n\t}\n\n\tget redirected() {\n\t\treturn this[INTERNALS$1].counter > 0;\n\t}\n\n\tget statusText() {\n\t\treturn this[INTERNALS$1].statusText;\n\t}\n\n\tget headers() {\n\t\treturn this[INTERNALS$1].headers;\n\t}\n\n\t/**\n  * Clone this response\n  *\n  * @return  Response\n  */\n\tclone() {\n\t\treturn new Response(clone(this), {\n\t\t\turl: this.url,\n\t\t\tstatus: this.status,\n\t\t\tstatusText: this.statusText,\n\t\t\theaders: this.headers,\n\t\t\tok: this.ok,\n\t\t\tredirected: this.redirected\n\t\t});\n\t}\n}\n\nBody.mixIn(Response.prototype);\n\nObject.defineProperties(Response.prototype, {\n\turl: { enumerable: true },\n\tstatus: { enumerable: true },\n\tok: { enumerable: true },\n\tredirected: { enumerable: true },\n\tstatusText: { enumerable: true },\n\theaders: { enumerable: true },\n\tclone: { enumerable: true }\n});\n\nObject.defineProperty(Response.prototype, Symbol.toStringTag, {\n\tvalue: 'Response',\n\twritable: false,\n\tenumerable: false,\n\tconfigurable: true\n});\n\nconst INTERNALS$2 = Symbol('Request internals');\n\n// fix an issue where \"format\", \"parse\" aren't a named export for node <10\nconst parse_url = Url.parse;\nconst format_url = Url.format;\n\nconst streamDestructionSupported = 'destroy' in Stream.Readable.prototype;\n\n/**\n * Check if a value is an instance of Request.\n *\n * @param   Mixed   input\n * @return  Boolean\n */\nfunction isRequest(input) {\n\treturn typeof input === 'object' && typeof input[INTERNALS$2] === 'object';\n}\n\nfunction isAbortSignal(signal) {\n\tconst proto = signal && typeof signal === 'object' && Object.getPrototypeOf(signal);\n\treturn !!(proto && proto.constructor.name === 'AbortSignal');\n}\n\n/**\n * Request class\n *\n * @param   Mixed   input  Url or Request instance\n * @param   Object  init   Custom options\n * @return  Void\n */\nclass Request {\n\tconstructor(input) {\n\t\tlet init = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n\t\tlet parsedURL;\n\n\t\t// normalize input\n\t\tif (!isRequest(input)) {\n\t\t\tif (input && input.href) {\n\t\t\t\t// in order to support Node.js' Url objects; though WHATWG's URL objects\n\t\t\t\t// will fall into this branch also (since their `toString()` will return\n\t\t\t\t// `href` property anyway)\n\t\t\t\tparsedURL = parse_url(input.href);\n\t\t\t} else {\n\t\t\t\t// coerce input to a string before attempting to parse\n\t\t\t\tparsedURL = parse_url(`${input}`);\n\t\t\t}\n\t\t\tinput = {};\n\t\t} else {\n\t\t\tparsedURL = parse_url(input.url);\n\t\t}\n\n\t\tlet method = init.method || input.method || 'GET';\n\t\tmethod = method.toUpperCase();\n\n\t\tif ((init.body != null || isRequest(input) && input.body !== null) && (method === 'GET' || method === 'HEAD')) {\n\t\t\tthrow new TypeError('Request with GET/HEAD method cannot have body');\n\t\t}\n\n\t\tlet inputBody = init.body != null ? init.body : isRequest(input) && input.body !== null ? clone(input) : null;\n\n\t\tBody.call(this, inputBody, {\n\t\t\ttimeout: init.timeout || input.timeout || 0,\n\t\t\tsize: init.size || input.size || 0\n\t\t});\n\n\t\tconst headers = new Headers(init.headers || input.headers || {});\n\n\t\tif (inputBody != null && !headers.has('Content-Type')) {\n\t\t\tconst contentType = extractContentType(inputBody);\n\t\t\tif (contentType) {\n\t\t\t\theaders.append('Content-Type', contentType);\n\t\t\t}\n\t\t}\n\n\t\tlet signal = isRequest(input) ? input.signal : null;\n\t\tif ('signal' in init) signal = init.signal;\n\n\t\tif (signal != null && !isAbortSignal(signal)) {\n\t\t\tthrow new TypeError('Expected signal to be an instanceof AbortSignal');\n\t\t}\n\n\t\tthis[INTERNALS$2] = {\n\t\t\tmethod,\n\t\t\tredirect: init.redirect || input.redirect || 'follow',\n\t\t\theaders,\n\t\t\tparsedURL,\n\t\t\tsignal\n\t\t};\n\n\t\t// node-fetch-only options\n\t\tthis.follow = init.follow !== undefined ? init.follow : input.follow !== undefined ? input.follow : 20;\n\t\tthis.compress = init.compress !== undefined ? init.compress : input.compress !== undefined ? input.compress : true;\n\t\tthis.counter = init.counter || input.counter || 0;\n\t\tthis.agent = init.agent || input.agent;\n\t}\n\n\tget method() {\n\t\treturn this[INTERNALS$2].method;\n\t}\n\n\tget url() {\n\t\treturn format_url(this[INTERNALS$2].parsedURL);\n\t}\n\n\tget headers() {\n\t\treturn this[INTERNALS$2].headers;\n\t}\n\n\tget redirect() {\n\t\treturn this[INTERNALS$2].redirect;\n\t}\n\n\tget signal() {\n\t\treturn this[INTERNALS$2].signal;\n\t}\n\n\t/**\n  * Clone this request\n  *\n  * @return  Request\n  */\n\tclone() {\n\t\treturn new Request(this);\n\t}\n}\n\nBody.mixIn(Request.prototype);\n\nObject.defineProperty(Request.prototype, Symbol.toStringTag, {\n\tvalue: 'Request',\n\twritable: false,\n\tenumerable: false,\n\tconfigurable: true\n});\n\nObject.defineProperties(Request.prototype, {\n\tmethod: { enumerable: true },\n\turl: { enumerable: true },\n\theaders: { enumerable: true },\n\tredirect: { enumerable: true },\n\tclone: { enumerable: true },\n\tsignal: { enumerable: true }\n});\n\n/**\n * Convert a Request to Node.js http request options.\n *\n * @param   Request  A Request instance\n * @return  Object   The options object to be passed to http.request\n */\nfunction getNodeRequestOptions(request) {\n\tconst parsedURL = request[INTERNALS$2].parsedURL;\n\tconst headers = new Headers(request[INTERNALS$2].headers);\n\n\t// fetch step 1.3\n\tif (!headers.has('Accept')) {\n\t\theaders.set('Accept', '*/*');\n\t}\n\n\t// Basic fetch\n\tif (!parsedURL.protocol || !parsedURL.hostname) {\n\t\tthrow new TypeError('Only absolute URLs are supported');\n\t}\n\n\tif (!/^https?:$/.test(parsedURL.protocol)) {\n\t\tthrow new TypeError('Only HTTP(S) protocols are supported');\n\t}\n\n\tif (request.signal && request.body instanceof Stream.Readable && !streamDestructionSupported) {\n\t\tthrow new Error('Cancellation of streamed requests with AbortSignal is not supported in node < 8');\n\t}\n\n\t// HTTP-network-or-cache fetch steps 2.4-2.7\n\tlet contentLengthValue = null;\n\tif (request.body == null && /^(POST|PUT)$/i.test(request.method)) {\n\t\tcontentLengthValue = '0';\n\t}\n\tif (request.body != null) {\n\t\tconst totalBytes = getTotalBytes(request);\n\t\tif (typeof totalBytes === 'number') {\n\t\t\tcontentLengthValue = String(totalBytes);\n\t\t}\n\t}\n\tif (contentLengthValue) {\n\t\theaders.set('Content-Length', contentLengthValue);\n\t}\n\n\t// HTTP-network-or-cache fetch step 2.11\n\tif (!headers.has('User-Agent')) {\n\t\theaders.set('User-Agent', 'node-fetch/1.0 (+https://github.com/bitinn/node-fetch)');\n\t}\n\n\t// HTTP-network-or-cache fetch step 2.15\n\tif (request.compress && !headers.has('Accept-Encoding')) {\n\t\theaders.set('Accept-Encoding', 'gzip,deflate');\n\t}\n\n\tlet agent = request.agent;\n\tif (typeof agent === 'function') {\n\t\tagent = agent(parsedURL);\n\t}\n\n\tif (!headers.has('Connection') && !agent) {\n\t\theaders.set('Connection', 'close');\n\t}\n\n\t// HTTP-network fetch step 4.2\n\t// chunked encoding is handled by Node.js\n\n\treturn Object.assign({}, parsedURL, {\n\t\tmethod: request.method,\n\t\theaders: exportNodeCompatibleHeaders(headers),\n\t\tagent\n\t});\n}\n\n/**\n * abort-error.js\n *\n * AbortError interface for cancelled requests\n */\n\n/**\n * Create AbortError instance\n *\n * @param   String      message      Error message for human\n * @return  AbortError\n */\nfunction AbortError(message) {\n  Error.call(this, message);\n\n  this.type = 'aborted';\n  this.message = message;\n\n  // hide custom error implementation details from end-users\n  Error.captureStackTrace(this, this.constructor);\n}\n\nAbortError.prototype = Object.create(Error.prototype);\nAbortError.prototype.constructor = AbortError;\nAbortError.prototype.name = 'AbortError';\n\n// fix an issue where \"PassThrough\", \"resolve\" aren't a named export for node <10\nconst PassThrough$1 = Stream.PassThrough;\nconst resolve_url = Url.resolve;\n\n/**\n * Fetch function\n *\n * @param   Mixed    url   Absolute url or Request instance\n * @param   Object   opts  Fetch options\n * @return  Promise\n */\nfunction fetch(url, opts) {\n\n\t// allow custom promise\n\tif (!fetch.Promise) {\n\t\tthrow new Error('native promise missing, set fetch.Promise to your favorite alternative');\n\t}\n\n\tBody.Promise = fetch.Promise;\n\n\t// wrap http.request into fetch\n\treturn new fetch.Promise(function (resolve, reject) {\n\t\t// build request object\n\t\tconst request = new Request(url, opts);\n\t\tconst options = getNodeRequestOptions(request);\n\n\t\tconst send = (options.protocol === 'https:' ? https : http).request;\n\t\tconst signal = request.signal;\n\n\t\tlet response = null;\n\n\t\tconst abort = function abort() {\n\t\t\tlet error = new AbortError('The user aborted a request.');\n\t\t\treject(error);\n\t\t\tif (request.body && request.body instanceof Stream.Readable) {\n\t\t\t\trequest.body.destroy(error);\n\t\t\t}\n\t\t\tif (!response || !response.body) return;\n\t\t\tresponse.body.emit('error', error);\n\t\t};\n\n\t\tif (signal && signal.aborted) {\n\t\t\tabort();\n\t\t\treturn;\n\t\t}\n\n\t\tconst abortAndFinalize = function abortAndFinalize() {\n\t\t\tabort();\n\t\t\tfinalize();\n\t\t};\n\n\t\t// send request\n\t\tconst req = send(options);\n\t\tlet reqTimeout;\n\n\t\tif (signal) {\n\t\t\tsignal.addEventListener('abort', abortAndFinalize);\n\t\t}\n\n\t\tfunction finalize() {\n\t\t\treq.abort();\n\t\t\tif (signal) signal.removeEventListener('abort', abortAndFinalize);\n\t\t\tclearTimeout(reqTimeout);\n\t\t}\n\n\t\tif (request.timeout) {\n\t\t\treq.once('socket', function (socket) {\n\t\t\t\treqTimeout = setTimeout(function () {\n\t\t\t\t\treject(new FetchError(`network timeout at: ${request.url}`, 'request-timeout'));\n\t\t\t\t\tfinalize();\n\t\t\t\t}, request.timeout);\n\t\t\t});\n\t\t}\n\n\t\treq.on('error', function (err) {\n\t\t\treject(new FetchError(`request to ${request.url} failed, reason: ${err.message}`, 'system', err));\n\t\t\tfinalize();\n\t\t});\n\n\t\treq.on('response', function (res) {\n\t\t\tclearTimeout(reqTimeout);\n\n\t\t\tconst headers = createHeadersLenient(res.headers);\n\n\t\t\t// HTTP fetch step 5\n\t\t\tif (fetch.isRedirect(res.statusCode)) {\n\t\t\t\t// HTTP fetch step 5.2\n\t\t\t\tconst location = headers.get('Location');\n\n\t\t\t\t// HTTP fetch step 5.3\n\t\t\t\tconst locationURL = location === null ? null : resolve_url(request.url, location);\n\n\t\t\t\t// HTTP fetch step 5.5\n\t\t\t\tswitch (request.redirect) {\n\t\t\t\t\tcase 'error':\n\t\t\t\t\t\treject(new FetchError(`uri requested responds with a redirect, redirect mode is set to error: ${request.url}`, 'no-redirect'));\n\t\t\t\t\t\tfinalize();\n\t\t\t\t\t\treturn;\n\t\t\t\t\tcase 'manual':\n\t\t\t\t\t\t// node-fetch-specific step: make manual redirect a bit easier to use by setting the Location header value to the resolved URL.\n\t\t\t\t\t\tif (locationURL !== null) {\n\t\t\t\t\t\t\t// handle corrupted header\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\theaders.set('Location', locationURL);\n\t\t\t\t\t\t\t} catch (err) {\n\t\t\t\t\t\t\t\t// istanbul ignore next: nodejs server prevent invalid response headers, we can't test this through normal request\n\t\t\t\t\t\t\t\treject(err);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'follow':\n\t\t\t\t\t\t// HTTP-redirect fetch step 2\n\t\t\t\t\t\tif (locationURL === null) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// HTTP-redirect fetch step 5\n\t\t\t\t\t\tif (request.counter >= request.follow) {\n\t\t\t\t\t\t\treject(new FetchError(`maximum redirect reached at: ${request.url}`, 'max-redirect'));\n\t\t\t\t\t\t\tfinalize();\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// HTTP-redirect fetch step 6 (counter increment)\n\t\t\t\t\t\t// Create a new Request object.\n\t\t\t\t\t\tconst requestOpts = {\n\t\t\t\t\t\t\theaders: new Headers(request.headers),\n\t\t\t\t\t\t\tfollow: request.follow,\n\t\t\t\t\t\t\tcounter: request.counter + 1,\n\t\t\t\t\t\t\tagent: request.agent,\n\t\t\t\t\t\t\tcompress: request.compress,\n\t\t\t\t\t\t\tmethod: request.method,\n\t\t\t\t\t\t\tbody: request.body,\n\t\t\t\t\t\t\tsignal: request.signal,\n\t\t\t\t\t\t\ttimeout: request.timeout,\n\t\t\t\t\t\t\tsize: request.size\n\t\t\t\t\t\t};\n\n\t\t\t\t\t\t// HTTP-redirect fetch step 9\n\t\t\t\t\t\tif (res.statusCode !== 303 && request.body && getTotalBytes(request) === null) {\n\t\t\t\t\t\t\treject(new FetchError('Cannot follow redirect with body being a readable stream', 'unsupported-redirect'));\n\t\t\t\t\t\t\tfinalize();\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// HTTP-redirect fetch step 11\n\t\t\t\t\t\tif (res.statusCode === 303 || (res.statusCode === 301 || res.statusCode === 302) && request.method === 'POST') {\n\t\t\t\t\t\t\trequestOpts.method = 'GET';\n\t\t\t\t\t\t\trequestOpts.body = undefined;\n\t\t\t\t\t\t\trequestOpts.headers.delete('content-length');\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// HTTP-redirect fetch step 15\n\t\t\t\t\t\tresolve(fetch(new Request(locationURL, requestOpts)));\n\t\t\t\t\t\tfinalize();\n\t\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// prepare response\n\t\t\tres.once('end', function () {\n\t\t\t\tif (signal) signal.removeEventListener('abort', abortAndFinalize);\n\t\t\t});\n\t\t\tlet body = res.pipe(new PassThrough$1());\n\n\t\t\tconst response_options = {\n\t\t\t\turl: request.url,\n\t\t\t\tstatus: res.statusCode,\n\t\t\t\tstatusText: res.statusMessage,\n\t\t\t\theaders: headers,\n\t\t\t\tsize: request.size,\n\t\t\t\ttimeout: request.timeout,\n\t\t\t\tcounter: request.counter\n\t\t\t};\n\n\t\t\t// HTTP-network fetch step 12.1.1.3\n\t\t\tconst codings = headers.get('Content-Encoding');\n\n\t\t\t// HTTP-network fetch step 12.1.1.4: handle content codings\n\n\t\t\t// in following scenarios we ignore compression support\n\t\t\t// 1. compression support is disabled\n\t\t\t// 2. HEAD request\n\t\t\t// 3. no Content-Encoding header\n\t\t\t// 4. no content response (204)\n\t\t\t// 5. content not modified response (304)\n\t\t\tif (!request.compress || request.method === 'HEAD' || codings === null || res.statusCode === 204 || res.statusCode === 304) {\n\t\t\t\tresponse = new Response(body, response_options);\n\t\t\t\tresolve(response);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// For Node v6+\n\t\t\t// Be less strict when decoding compressed responses, since sometimes\n\t\t\t// servers send slightly invalid responses that are still accepted\n\t\t\t// by common browsers.\n\t\t\t// Always using Z_SYNC_FLUSH is what cURL does.\n\t\t\tconst zlibOptions = {\n\t\t\t\tflush: zlib.Z_SYNC_FLUSH,\n\t\t\t\tfinishFlush: zlib.Z_SYNC_FLUSH\n\t\t\t};\n\n\t\t\t// for gzip\n\t\t\tif (codings == 'gzip' || codings == 'x-gzip') {\n\t\t\t\tbody = body.pipe(zlib.createGunzip(zlibOptions));\n\t\t\t\tresponse = new Response(body, response_options);\n\t\t\t\tresolve(response);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// for deflate\n\t\t\tif (codings == 'deflate' || codings == 'x-deflate') {\n\t\t\t\t// handle the infamous raw deflate response from old servers\n\t\t\t\t// a hack for old IIS and Apache servers\n\t\t\t\tconst raw = res.pipe(new PassThrough$1());\n\t\t\t\traw.once('data', function (chunk) {\n\t\t\t\t\t// see http://stackoverflow.com/questions/37519828\n\t\t\t\t\tif ((chunk[0] & 0x0F) === 0x08) {\n\t\t\t\t\t\tbody = body.pipe(zlib.createInflate());\n\t\t\t\t\t} else {\n\t\t\t\t\t\tbody = body.pipe(zlib.createInflateRaw());\n\t\t\t\t\t}\n\t\t\t\t\tresponse = new Response(body, response_options);\n\t\t\t\t\tresolve(response);\n\t\t\t\t});\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// for br\n\t\t\tif (codings == 'br' && typeof zlib.createBrotliDecompress === 'function') {\n\t\t\t\tbody = body.pipe(zlib.createBrotliDecompress());\n\t\t\t\tresponse = new Response(body, response_options);\n\t\t\t\tresolve(response);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// otherwise, use response as-is\n\t\t\tresponse = new Response(body, response_options);\n\t\t\tresolve(response);\n\t\t});\n\n\t\twriteToStream(req, request);\n\t});\n}\n/**\n * Redirect code matching\n *\n * @param   Number   code  Status code\n * @return  Boolean\n */\nfetch.isRedirect = function (code) {\n\treturn code === 301 || code === 302 || code === 303 || code === 307 || code === 308;\n};\n\n// expose Promise\nfetch.Promise = global.Promise;\n\nmodule.exports = exports = fetch;\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = exports;\nexports.Headers = Headers;\nexports.Request = Request;\nexports.Response = Response;\nexports.FetchError = FetchError;\n","'use strict';\nconst {promisify} = require('util');\nconst fs = require('fs');\n\nasync function isType(fsStatType, statsMethodName, filePath) {\n\tif (typeof filePath !== 'string') {\n\t\tthrow new TypeError(`Expected a string, got ${typeof filePath}`);\n\t}\n\n\ttry {\n\t\tconst stats = await promisify(fs[fsStatType])(filePath);\n\t\treturn stats[statsMethodName]();\n\t} catch (error) {\n\t\tif (error.code === 'ENOENT') {\n\t\t\treturn false;\n\t\t}\n\n\t\tthrow error;\n\t}\n}\n\nfunction isTypeSync(fsStatType, statsMethodName, filePath) {\n\tif (typeof filePath !== 'string') {\n\t\tthrow new TypeError(`Expected a string, got ${typeof filePath}`);\n\t}\n\n\ttry {\n\t\treturn fs[fsStatType](filePath)[statsMethodName]();\n\t} catch (error) {\n\t\tif (error.code === 'ENOENT') {\n\t\t\treturn false;\n\t\t}\n\n\t\tthrow error;\n\t}\n}\n\nexports.isFile = isType.bind(null, 'stat', 'isFile');\nexports.isDirectory = isType.bind(null, 'stat', 'isDirectory');\nexports.isSymlink = isType.bind(null, 'lstat', 'isSymbolicLink');\nexports.isFileSync = isTypeSync.bind(null, 'statSync', 'isFile');\nexports.isDirectorySync = isTypeSync.bind(null, 'statSync', 'isDirectory');\nexports.isSymlinkSync = isTypeSync.bind(null, 'lstatSync', 'isSymbolicLink');\n","'use strict';\n\nmodule.exports = require('./lib/picomatch');\n","'use strict';\n\nconst path = require('path');\nconst WIN_SLASH = '\\\\\\\\/';\nconst WIN_NO_SLASH = `[^${WIN_SLASH}]`;\n\n/**\n * Posix glob regex\n */\n\nconst DOT_LITERAL = '\\\\.';\nconst PLUS_LITERAL = '\\\\+';\nconst QMARK_LITERAL = '\\\\?';\nconst SLASH_LITERAL = '\\\\/';\nconst ONE_CHAR = '(?=.)';\nconst QMARK = '[^/]';\nconst END_ANCHOR = `(?:${SLASH_LITERAL}|$)`;\nconst START_ANCHOR = `(?:^|${SLASH_LITERAL})`;\nconst DOTS_SLASH = `${DOT_LITERAL}{1,2}${END_ANCHOR}`;\nconst NO_DOT = `(?!${DOT_LITERAL})`;\nconst NO_DOTS = `(?!${START_ANCHOR}${DOTS_SLASH})`;\nconst NO_DOT_SLASH = `(?!${DOT_LITERAL}{0,1}${END_ANCHOR})`;\nconst NO_DOTS_SLASH = `(?!${DOTS_SLASH})`;\nconst QMARK_NO_DOT = `[^.${SLASH_LITERAL}]`;\nconst STAR = `${QMARK}*?`;\n\nconst POSIX_CHARS = {\n  DOT_LITERAL,\n  PLUS_LITERAL,\n  QMARK_LITERAL,\n  SLASH_LITERAL,\n  ONE_CHAR,\n  QMARK,\n  END_ANCHOR,\n  DOTS_SLASH,\n  NO_DOT,\n  NO_DOTS,\n  NO_DOT_SLASH,\n  NO_DOTS_SLASH,\n  QMARK_NO_DOT,\n  STAR,\n  START_ANCHOR\n};\n\n/**\n * Windows glob regex\n */\n\nconst WINDOWS_CHARS = {\n  ...POSIX_CHARS,\n\n  SLASH_LITERAL: `[${WIN_SLASH}]`,\n  QMARK: WIN_NO_SLASH,\n  STAR: `${WIN_NO_SLASH}*?`,\n  DOTS_SLASH: `${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$)`,\n  NO_DOT: `(?!${DOT_LITERAL})`,\n  NO_DOTS: `(?!(?:^|[${WIN_SLASH}])${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$))`,\n  NO_DOT_SLASH: `(?!${DOT_LITERAL}{0,1}(?:[${WIN_SLASH}]|$))`,\n  NO_DOTS_SLASH: `(?!${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$))`,\n  QMARK_NO_DOT: `[^.${WIN_SLASH}]`,\n  START_ANCHOR: `(?:^|[${WIN_SLASH}])`,\n  END_ANCHOR: `(?:[${WIN_SLASH}]|$)`\n};\n\n/**\n * POSIX Bracket Regex\n */\n\nconst POSIX_REGEX_SOURCE = {\n  alnum: 'a-zA-Z0-9',\n  alpha: 'a-zA-Z',\n  ascii: '\\\\x00-\\\\x7F',\n  blank: ' \\\\t',\n  cntrl: '\\\\x00-\\\\x1F\\\\x7F',\n  digit: '0-9',\n  graph: '\\\\x21-\\\\x7E',\n  lower: 'a-z',\n  print: '\\\\x20-\\\\x7E ',\n  punct: '\\\\-!\"#$%&\\'()\\\\*+,./:;<=>?@[\\\\]^_`{|}~',\n  space: ' \\\\t\\\\r\\\\n\\\\v\\\\f',\n  upper: 'A-Z',\n  word: 'A-Za-z0-9_',\n  xdigit: 'A-Fa-f0-9'\n};\n\nmodule.exports = {\n  MAX_LENGTH: 1024 * 64,\n  POSIX_REGEX_SOURCE,\n\n  // regular expressions\n  REGEX_BACKSLASH: /\\\\(?![*+?^${}(|)[\\]])/g,\n  REGEX_NON_SPECIAL_CHARS: /^[^@![\\].,$*+?^{}()|\\\\/]+/,\n  REGEX_SPECIAL_CHARS: /[-*+?.^${}(|)[\\]]/,\n  REGEX_SPECIAL_CHARS_BACKREF: /(\\\\?)((\\W)(\\3*))/g,\n  REGEX_SPECIAL_CHARS_GLOBAL: /([-*+?.^${}(|)[\\]])/g,\n  REGEX_REMOVE_BACKSLASH: /(?:\\[.*?[^\\\\]\\]|\\\\(?=.))/g,\n\n  // Replace globs with equivalent patterns to reduce parsing time.\n  REPLACEMENTS: {\n    '***': '*',\n    '**/**': '**',\n    '**/**/**': '**'\n  },\n\n  // Digits\n  CHAR_0: 48, /* 0 */\n  CHAR_9: 57, /* 9 */\n\n  // Alphabet chars.\n  CHAR_UPPERCASE_A: 65, /* A */\n  CHAR_LOWERCASE_A: 97, /* a */\n  CHAR_UPPERCASE_Z: 90, /* Z */\n  CHAR_LOWERCASE_Z: 122, /* z */\n\n  CHAR_LEFT_PARENTHESES: 40, /* ( */\n  CHAR_RIGHT_PARENTHESES: 41, /* ) */\n\n  CHAR_ASTERISK: 42, /* * */\n\n  // Non-alphabetic chars.\n  CHAR_AMPERSAND: 38, /* & */\n  CHAR_AT: 64, /* @ */\n  CHAR_BACKWARD_SLASH: 92, /* \\ */\n  CHAR_CARRIAGE_RETURN: 13, /* \\r */\n  CHAR_CIRCUMFLEX_ACCENT: 94, /* ^ */\n  CHAR_COLON: 58, /* : */\n  CHAR_COMMA: 44, /* , */\n  CHAR_DOT: 46, /* . */\n  CHAR_DOUBLE_QUOTE: 34, /* \" */\n  CHAR_EQUAL: 61, /* = */\n  CHAR_EXCLAMATION_MARK: 33, /* ! */\n  CHAR_FORM_FEED: 12, /* \\f */\n  CHAR_FORWARD_SLASH: 47, /* / */\n  CHAR_GRAVE_ACCENT: 96, /* ` */\n  CHAR_HASH: 35, /* # */\n  CHAR_HYPHEN_MINUS: 45, /* - */\n  CHAR_LEFT_ANGLE_BRACKET: 60, /* < */\n  CHAR_LEFT_CURLY_BRACE: 123, /* { */\n  CHAR_LEFT_SQUARE_BRACKET: 91, /* [ */\n  CHAR_LINE_FEED: 10, /* \\n */\n  CHAR_NO_BREAK_SPACE: 160, /* \\u00A0 */\n  CHAR_PERCENT: 37, /* % */\n  CHAR_PLUS: 43, /* + */\n  CHAR_QUESTION_MARK: 63, /* ? */\n  CHAR_RIGHT_ANGLE_BRACKET: 62, /* > */\n  CHAR_RIGHT_CURLY_BRACE: 125, /* } */\n  CHAR_RIGHT_SQUARE_BRACKET: 93, /* ] */\n  CHAR_SEMICOLON: 59, /* ; */\n  CHAR_SINGLE_QUOTE: 39, /* ' */\n  CHAR_SPACE: 32, /*   */\n  CHAR_TAB: 9, /* \\t */\n  CHAR_UNDERSCORE: 95, /* _ */\n  CHAR_VERTICAL_LINE: 124, /* | */\n  CHAR_ZERO_WIDTH_NOBREAK_SPACE: 65279, /* \\uFEFF */\n\n  SEP: path.sep,\n\n  /**\n   * Create EXTGLOB_CHARS\n   */\n\n  extglobChars(chars) {\n    return {\n      '!': { type: 'negate', open: '(?:(?!(?:', close: `))${chars.STAR})` },\n      '?': { type: 'qmark', open: '(?:', close: ')?' },\n      '+': { type: 'plus', open: '(?:', close: ')+' },\n      '*': { type: 'star', open: '(?:', close: ')*' },\n      '@': { type: 'at', open: '(?:', close: ')' }\n    };\n  },\n\n  /**\n   * Create GLOB_CHARS\n   */\n\n  globChars(win32) {\n    return win32 === true ? WINDOWS_CHARS : POSIX_CHARS;\n  }\n};\n","'use strict';\n\nconst constants = require('./constants');\nconst utils = require('./utils');\n\n/**\n * Constants\n */\n\nconst {\n  MAX_LENGTH,\n  POSIX_REGEX_SOURCE,\n  REGEX_NON_SPECIAL_CHARS,\n  REGEX_SPECIAL_CHARS_BACKREF,\n  REPLACEMENTS\n} = constants;\n\n/**\n * Helpers\n */\n\nconst expandRange = (args, options) => {\n  if (typeof options.expandRange === 'function') {\n    return options.expandRange(...args, options);\n  }\n\n  args.sort();\n  const value = `[${args.join('-')}]`;\n\n  try {\n    /* eslint-disable-next-line no-new */\n    new RegExp(value);\n  } catch (ex) {\n    return args.map(v => utils.escapeRegex(v)).join('..');\n  }\n\n  return value;\n};\n\n/**\n * Create the message for a syntax error\n */\n\nconst syntaxError = (type, char) => {\n  return `Missing ${type}: \"${char}\" - use \"\\\\\\\\${char}\" to match literal characters`;\n};\n\n/**\n * Parse the given input string.\n * @param {String} input\n * @param {Object} options\n * @return {Object}\n */\n\nconst parse = (input, options) => {\n  if (typeof input !== 'string') {\n    throw new TypeError('Expected a string');\n  }\n\n  input = REPLACEMENTS[input] || input;\n\n  const opts = { ...options };\n  const max = typeof opts.maxLength === 'number' ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;\n\n  let len = input.length;\n  if (len > max) {\n    throw new SyntaxError(`Input length: ${len}, exceeds maximum allowed length: ${max}`);\n  }\n\n  const bos = { type: 'bos', value: '', output: opts.prepend || '' };\n  const tokens = [bos];\n\n  const capture = opts.capture ? '' : '?:';\n  const win32 = utils.isWindows(options);\n\n  // create constants based on platform, for windows or posix\n  const PLATFORM_CHARS = constants.globChars(win32);\n  const EXTGLOB_CHARS = constants.extglobChars(PLATFORM_CHARS);\n\n  const {\n    DOT_LITERAL,\n    PLUS_LITERAL,\n    SLASH_LITERAL,\n    ONE_CHAR,\n    DOTS_SLASH,\n    NO_DOT,\n    NO_DOT_SLASH,\n    NO_DOTS_SLASH,\n    QMARK,\n    QMARK_NO_DOT,\n    STAR,\n    START_ANCHOR\n  } = PLATFORM_CHARS;\n\n  const globstar = (opts) => {\n    return `(${capture}(?:(?!${START_ANCHOR}${opts.dot ? DOTS_SLASH : DOT_LITERAL}).)*?)`;\n  };\n\n  const nodot = opts.dot ? '' : NO_DOT;\n  const qmarkNoDot = opts.dot ? QMARK : QMARK_NO_DOT;\n  let star = opts.bash === true ? globstar(opts) : STAR;\n\n  if (opts.capture) {\n    star = `(${star})`;\n  }\n\n  // minimatch options support\n  if (typeof opts.noext === 'boolean') {\n    opts.noextglob = opts.noext;\n  }\n\n  const state = {\n    input,\n    index: -1,\n    start: 0,\n    dot: opts.dot === true,\n    consumed: '',\n    output: '',\n    prefix: '',\n    backtrack: false,\n    negated: false,\n    brackets: 0,\n    braces: 0,\n    parens: 0,\n    quotes: 0,\n    globstar: false,\n    tokens\n  };\n\n  input = utils.removePrefix(input, state);\n  len = input.length;\n\n  const extglobs = [];\n  const braces = [];\n  const stack = [];\n  let prev = bos;\n  let value;\n\n  /**\n   * Tokenizing helpers\n   */\n\n  const eos = () => state.index === len - 1;\n  const peek = state.peek = (n = 1) => input[state.index + n];\n  const advance = state.advance = () => input[++state.index];\n  const remaining = () => input.slice(state.index + 1);\n  const consume = (value = '', num = 0) => {\n    state.consumed += value;\n    state.index += num;\n  };\n  const append = token => {\n    state.output += token.output != null ? token.output : token.value;\n    consume(token.value);\n  };\n\n  const negate = () => {\n    let count = 1;\n\n    while (peek() === '!' && (peek(2) !== '(' || peek(3) === '?')) {\n      advance();\n      state.start++;\n      count++;\n    }\n\n    if (count % 2 === 0) {\n      return false;\n    }\n\n    state.negated = true;\n    state.start++;\n    return true;\n  };\n\n  const increment = type => {\n    state[type]++;\n    stack.push(type);\n  };\n\n  const decrement = type => {\n    state[type]--;\n    stack.pop();\n  };\n\n  /**\n   * Push tokens onto the tokens array. This helper speeds up\n   * tokenizing by 1) helping us avoid backtracking as much as possible,\n   * and 2) helping us avoid creating extra tokens when consecutive\n   * characters are plain text. This improves performance and simplifies\n   * lookbehinds.\n   */\n\n  const push = tok => {\n    if (prev.type === 'globstar') {\n      const isBrace = state.braces > 0 && (tok.type === 'comma' || tok.type === 'brace');\n      const isExtglob = tok.extglob === true || (extglobs.length && (tok.type === 'pipe' || tok.type === 'paren'));\n\n      if (tok.type !== 'slash' && tok.type !== 'paren' && !isBrace && !isExtglob) {\n        state.output = state.output.slice(0, -prev.output.length);\n        prev.type = 'star';\n        prev.value = '*';\n        prev.output = star;\n        state.output += prev.output;\n      }\n    }\n\n    if (extglobs.length && tok.type !== 'paren' && !EXTGLOB_CHARS[tok.value]) {\n      extglobs[extglobs.length - 1].inner += tok.value;\n    }\n\n    if (tok.value || tok.output) append(tok);\n    if (prev && prev.type === 'text' && tok.type === 'text') {\n      prev.value += tok.value;\n      prev.output = (prev.output || '') + tok.value;\n      return;\n    }\n\n    tok.prev = prev;\n    tokens.push(tok);\n    prev = tok;\n  };\n\n  const extglobOpen = (type, value) => {\n    const token = { ...EXTGLOB_CHARS[value], conditions: 1, inner: '' };\n\n    token.prev = prev;\n    token.parens = state.parens;\n    token.output = state.output;\n    const output = (opts.capture ? '(' : '') + token.open;\n\n    increment('parens');\n    push({ type, value, output: state.output ? '' : ONE_CHAR });\n    push({ type: 'paren', extglob: true, value: advance(), output });\n    extglobs.push(token);\n  };\n\n  const extglobClose = token => {\n    let output = token.close + (opts.capture ? ')' : '');\n\n    if (token.type === 'negate') {\n      let extglobStar = star;\n\n      if (token.inner && token.inner.length > 1 && token.inner.includes('/')) {\n        extglobStar = globstar(opts);\n      }\n\n      if (extglobStar !== star || eos() || /^\\)+$/.test(remaining())) {\n        output = token.close = `)$))${extglobStar}`;\n      }\n\n      if (token.prev.type === 'bos' && eos()) {\n        state.negatedExtglob = true;\n      }\n    }\n\n    push({ type: 'paren', extglob: true, value, output });\n    decrement('parens');\n  };\n\n  /**\n   * Fast paths\n   */\n\n  if (opts.fastpaths !== false && !/(^[*!]|[/()[\\]{}\"])/.test(input)) {\n    let backslashes = false;\n\n    let output = input.replace(REGEX_SPECIAL_CHARS_BACKREF, (m, esc, chars, first, rest, index) => {\n      if (first === '\\\\') {\n        backslashes = true;\n        return m;\n      }\n\n      if (first === '?') {\n        if (esc) {\n          return esc + first + (rest ? QMARK.repeat(rest.length) : '');\n        }\n        if (index === 0) {\n          return qmarkNoDot + (rest ? QMARK.repeat(rest.length) : '');\n        }\n        return QMARK.repeat(chars.length);\n      }\n\n      if (first === '.') {\n        return DOT_LITERAL.repeat(chars.length);\n      }\n\n      if (first === '*') {\n        if (esc) {\n          return esc + first + (rest ? star : '');\n        }\n        return star;\n      }\n      return esc ? m : `\\\\${m}`;\n    });\n\n    if (backslashes === true) {\n      if (opts.unescape === true) {\n        output = output.replace(/\\\\/g, '');\n      } else {\n        output = output.replace(/\\\\+/g, m => {\n          return m.length % 2 === 0 ? '\\\\\\\\' : (m ? '\\\\' : '');\n        });\n      }\n    }\n\n    if (output === input && opts.contains === true) {\n      state.output = input;\n      return state;\n    }\n\n    state.output = utils.wrapOutput(output, state, options);\n    return state;\n  }\n\n  /**\n   * Tokenize input until we reach end-of-string\n   */\n\n  while (!eos()) {\n    value = advance();\n\n    if (value === '\\u0000') {\n      continue;\n    }\n\n    /**\n     * Escaped characters\n     */\n\n    if (value === '\\\\') {\n      const next = peek();\n\n      if (next === '/' && opts.bash !== true) {\n        continue;\n      }\n\n      if (next === '.' || next === ';') {\n        continue;\n      }\n\n      if (!next) {\n        value += '\\\\';\n        push({ type: 'text', value });\n        continue;\n      }\n\n      // collapse slashes to reduce potential for exploits\n      const match = /^\\\\+/.exec(remaining());\n      let slashes = 0;\n\n      if (match && match[0].length > 2) {\n        slashes = match[0].length;\n        state.index += slashes;\n        if (slashes % 2 !== 0) {\n          value += '\\\\';\n        }\n      }\n\n      if (opts.unescape === true) {\n        value = advance() || '';\n      } else {\n        value += advance() || '';\n      }\n\n      if (state.brackets === 0) {\n        push({ type: 'text', value });\n        continue;\n      }\n    }\n\n    /**\n     * If we're inside a regex character class, continue\n     * until we reach the closing bracket.\n     */\n\n    if (state.brackets > 0 && (value !== ']' || prev.value === '[' || prev.value === '[^')) {\n      if (opts.posix !== false && value === ':') {\n        const inner = prev.value.slice(1);\n        if (inner.includes('[')) {\n          prev.posix = true;\n\n          if (inner.includes(':')) {\n            const idx = prev.value.lastIndexOf('[');\n            const pre = prev.value.slice(0, idx);\n            const rest = prev.value.slice(idx + 2);\n            const posix = POSIX_REGEX_SOURCE[rest];\n            if (posix) {\n              prev.value = pre + posix;\n              state.backtrack = true;\n              advance();\n\n              if (!bos.output && tokens.indexOf(prev) === 1) {\n                bos.output = ONE_CHAR;\n              }\n              continue;\n            }\n          }\n        }\n      }\n\n      if ((value === '[' && peek() !== ':') || (value === '-' && peek() === ']')) {\n        value = `\\\\${value}`;\n      }\n\n      if (value === ']' && (prev.value === '[' || prev.value === '[^')) {\n        value = `\\\\${value}`;\n      }\n\n      if (opts.posix === true && value === '!' && prev.value === '[') {\n        value = '^';\n      }\n\n      prev.value += value;\n      append({ value });\n      continue;\n    }\n\n    /**\n     * If we're inside a quoted string, continue\n     * until we reach the closing double quote.\n     */\n\n    if (state.quotes === 1 && value !== '\"') {\n      value = utils.escapeRegex(value);\n      prev.value += value;\n      append({ value });\n      continue;\n    }\n\n    /**\n     * Double quotes\n     */\n\n    if (value === '\"') {\n      state.quotes = state.quotes === 1 ? 0 : 1;\n      if (opts.keepQuotes === true) {\n        push({ type: 'text', value });\n      }\n      continue;\n    }\n\n    /**\n     * Parentheses\n     */\n\n    if (value === '(') {\n      increment('parens');\n      push({ type: 'paren', value });\n      continue;\n    }\n\n    if (value === ')') {\n      if (state.parens === 0 && opts.strictBrackets === true) {\n        throw new SyntaxError(syntaxError('opening', '('));\n      }\n\n      const extglob = extglobs[extglobs.length - 1];\n      if (extglob && state.parens === extglob.parens + 1) {\n        extglobClose(extglobs.pop());\n        continue;\n      }\n\n      push({ type: 'paren', value, output: state.parens ? ')' : '\\\\)' });\n      decrement('parens');\n      continue;\n    }\n\n    /**\n     * Square brackets\n     */\n\n    if (value === '[') {\n      if (opts.nobracket === true || !remaining().includes(']')) {\n        if (opts.nobracket !== true && opts.strictBrackets === true) {\n          throw new SyntaxError(syntaxError('closing', ']'));\n        }\n\n        value = `\\\\${value}`;\n      } else {\n        increment('brackets');\n      }\n\n      push({ type: 'bracket', value });\n      continue;\n    }\n\n    if (value === ']') {\n      if (opts.nobracket === true || (prev && prev.type === 'bracket' && prev.value.length === 1)) {\n        push({ type: 'text', value, output: `\\\\${value}` });\n        continue;\n      }\n\n      if (state.brackets === 0) {\n        if (opts.strictBrackets === true) {\n          throw new SyntaxError(syntaxError('opening', '['));\n        }\n\n        push({ type: 'text', value, output: `\\\\${value}` });\n        continue;\n      }\n\n      decrement('brackets');\n\n      const prevValue = prev.value.slice(1);\n      if (prev.posix !== true && prevValue[0] === '^' && !prevValue.includes('/')) {\n        value = `/${value}`;\n      }\n\n      prev.value += value;\n      append({ value });\n\n      // when literal brackets are explicitly disabled\n      // assume we should match with a regex character class\n      if (opts.literalBrackets === false || utils.hasRegexChars(prevValue)) {\n        continue;\n      }\n\n      const escaped = utils.escapeRegex(prev.value);\n      state.output = state.output.slice(0, -prev.value.length);\n\n      // when literal brackets are explicitly enabled\n      // assume we should escape the brackets to match literal characters\n      if (opts.literalBrackets === true) {\n        state.output += escaped;\n        prev.value = escaped;\n        continue;\n      }\n\n      // when the user specifies nothing, try to match both\n      prev.value = `(${capture}${escaped}|${prev.value})`;\n      state.output += prev.value;\n      continue;\n    }\n\n    /**\n     * Braces\n     */\n\n    if (value === '{' && opts.nobrace !== true) {\n      increment('braces');\n\n      const open = {\n        type: 'brace',\n        value,\n        output: '(',\n        outputIndex: state.output.length,\n        tokensIndex: state.tokens.length\n      };\n\n      braces.push(open);\n      push(open);\n      continue;\n    }\n\n    if (value === '}') {\n      const brace = braces[braces.length - 1];\n\n      if (opts.nobrace === true || !brace) {\n        push({ type: 'text', value, output: value });\n        continue;\n      }\n\n      let output = ')';\n\n      if (brace.dots === true) {\n        const arr = tokens.slice();\n        const range = [];\n\n        for (let i = arr.length - 1; i >= 0; i--) {\n          tokens.pop();\n          if (arr[i].type === 'brace') {\n            break;\n          }\n          if (arr[i].type !== 'dots') {\n            range.unshift(arr[i].value);\n          }\n        }\n\n        output = expandRange(range, opts);\n        state.backtrack = true;\n      }\n\n      if (brace.comma !== true && brace.dots !== true) {\n        const out = state.output.slice(0, brace.outputIndex);\n        const toks = state.tokens.slice(brace.tokensIndex);\n        brace.value = brace.output = '\\\\{';\n        value = output = '\\\\}';\n        state.output = out;\n        for (const t of toks) {\n          state.output += (t.output || t.value);\n        }\n      }\n\n      push({ type: 'brace', value, output });\n      decrement('braces');\n      braces.pop();\n      continue;\n    }\n\n    /**\n     * Pipes\n     */\n\n    if (value === '|') {\n      if (extglobs.length > 0) {\n        extglobs[extglobs.length - 1].conditions++;\n      }\n      push({ type: 'text', value });\n      continue;\n    }\n\n    /**\n     * Commas\n     */\n\n    if (value === ',') {\n      let output = value;\n\n      const brace = braces[braces.length - 1];\n      if (brace && stack[stack.length - 1] === 'braces') {\n        brace.comma = true;\n        output = '|';\n      }\n\n      push({ type: 'comma', value, output });\n      continue;\n    }\n\n    /**\n     * Slashes\n     */\n\n    if (value === '/') {\n      // if the beginning of the glob is \"./\", advance the start\n      // to the current index, and don't add the \"./\" characters\n      // to the state. This greatly simplifies lookbehinds when\n      // checking for BOS characters like \"!\" and \".\" (not \"./\")\n      if (prev.type === 'dot' && state.index === state.start + 1) {\n        state.start = state.index + 1;\n        state.consumed = '';\n        state.output = '';\n        tokens.pop();\n        prev = bos; // reset \"prev\" to the first token\n        continue;\n      }\n\n      push({ type: 'slash', value, output: SLASH_LITERAL });\n      continue;\n    }\n\n    /**\n     * Dots\n     */\n\n    if (value === '.') {\n      if (state.braces > 0 && prev.type === 'dot') {\n        if (prev.value === '.') prev.output = DOT_LITERAL;\n        const brace = braces[braces.length - 1];\n        prev.type = 'dots';\n        prev.output += value;\n        prev.value += value;\n        brace.dots = true;\n        continue;\n      }\n\n      if ((state.braces + state.parens) === 0 && prev.type !== 'bos' && prev.type !== 'slash') {\n        push({ type: 'text', value, output: DOT_LITERAL });\n        continue;\n      }\n\n      push({ type: 'dot', value, output: DOT_LITERAL });\n      continue;\n    }\n\n    /**\n     * Question marks\n     */\n\n    if (value === '?') {\n      const isGroup = prev && prev.value === '(';\n      if (!isGroup && opts.noextglob !== true && peek() === '(' && peek(2) !== '?') {\n        extglobOpen('qmark', value);\n        continue;\n      }\n\n      if (prev && prev.type === 'paren') {\n        const next = peek();\n        let output = value;\n\n        if (next === '<' && !utils.supportsLookbehinds()) {\n          throw new Error('Node.js v10 or higher is required for regex lookbehinds');\n        }\n\n        if ((prev.value === '(' && !/[!=<:]/.test(next)) || (next === '<' && !/<([!=]|\\w+>)/.test(remaining()))) {\n          output = `\\\\${value}`;\n        }\n\n        push({ type: 'text', value, output });\n        continue;\n      }\n\n      if (opts.dot !== true && (prev.type === 'slash' || prev.type === 'bos')) {\n        push({ type: 'qmark', value, output: QMARK_NO_DOT });\n        continue;\n      }\n\n      push({ type: 'qmark', value, output: QMARK });\n      continue;\n    }\n\n    /**\n     * Exclamation\n     */\n\n    if (value === '!') {\n      if (opts.noextglob !== true && peek() === '(') {\n        if (peek(2) !== '?' || !/[!=<:]/.test(peek(3))) {\n          extglobOpen('negate', value);\n          continue;\n        }\n      }\n\n      if (opts.nonegate !== true && state.index === 0) {\n        negate();\n        continue;\n      }\n    }\n\n    /**\n     * Plus\n     */\n\n    if (value === '+') {\n      if (opts.noextglob !== true && peek() === '(' && peek(2) !== '?') {\n        extglobOpen('plus', value);\n        continue;\n      }\n\n      if ((prev && prev.value === '(') || opts.regex === false) {\n        push({ type: 'plus', value, output: PLUS_LITERAL });\n        continue;\n      }\n\n      if ((prev && (prev.type === 'bracket' || prev.type === 'paren' || prev.type === 'brace')) || state.parens > 0) {\n        push({ type: 'plus', value });\n        continue;\n      }\n\n      push({ type: 'plus', value: PLUS_LITERAL });\n      continue;\n    }\n\n    /**\n     * Plain text\n     */\n\n    if (value === '@') {\n      if (opts.noextglob !== true && peek() === '(' && peek(2) !== '?') {\n        push({ type: 'at', extglob: true, value, output: '' });\n        continue;\n      }\n\n      push({ type: 'text', value });\n      continue;\n    }\n\n    /**\n     * Plain text\n     */\n\n    if (value !== '*') {\n      if (value === '$' || value === '^') {\n        value = `\\\\${value}`;\n      }\n\n      const match = REGEX_NON_SPECIAL_CHARS.exec(remaining());\n      if (match) {\n        value += match[0];\n        state.index += match[0].length;\n      }\n\n      push({ type: 'text', value });\n      continue;\n    }\n\n    /**\n     * Stars\n     */\n\n    if (prev && (prev.type === 'globstar' || prev.star === true)) {\n      prev.type = 'star';\n      prev.star = true;\n      prev.value += value;\n      prev.output = star;\n      state.backtrack = true;\n      state.globstar = true;\n      consume(value);\n      continue;\n    }\n\n    let rest = remaining();\n    if (opts.noextglob !== true && /^\\([^?]/.test(rest)) {\n      extglobOpen('star', value);\n      continue;\n    }\n\n    if (prev.type === 'star') {\n      if (opts.noglobstar === true) {\n        consume(value);\n        continue;\n      }\n\n      const prior = prev.prev;\n      const before = prior.prev;\n      const isStart = prior.type === 'slash' || prior.type === 'bos';\n      const afterStar = before && (before.type === 'star' || before.type === 'globstar');\n\n      if (opts.bash === true && (!isStart || (rest[0] && rest[0] !== '/'))) {\n        push({ type: 'star', value, output: '' });\n        continue;\n      }\n\n      const isBrace = state.braces > 0 && (prior.type === 'comma' || prior.type === 'brace');\n      const isExtglob = extglobs.length && (prior.type === 'pipe' || prior.type === 'paren');\n      if (!isStart && prior.type !== 'paren' && !isBrace && !isExtglob) {\n        push({ type: 'star', value, output: '' });\n        continue;\n      }\n\n      // strip consecutive `/**/`\n      while (rest.slice(0, 3) === '/**') {\n        const after = input[state.index + 4];\n        if (after && after !== '/') {\n          break;\n        }\n        rest = rest.slice(3);\n        consume('/**', 3);\n      }\n\n      if (prior.type === 'bos' && eos()) {\n        prev.type = 'globstar';\n        prev.value += value;\n        prev.output = globstar(opts);\n        state.output = prev.output;\n        state.globstar = true;\n        consume(value);\n        continue;\n      }\n\n      if (prior.type === 'slash' && prior.prev.type !== 'bos' && !afterStar && eos()) {\n        state.output = state.output.slice(0, -(prior.output + prev.output).length);\n        prior.output = `(?:${prior.output}`;\n\n        prev.type = 'globstar';\n        prev.output = globstar(opts) + (opts.strictSlashes ? ')' : '|$)');\n        prev.value += value;\n        state.globstar = true;\n        state.output += prior.output + prev.output;\n        consume(value);\n        continue;\n      }\n\n      if (prior.type === 'slash' && prior.prev.type !== 'bos' && rest[0] === '/') {\n        const end = rest[1] !== void 0 ? '|$' : '';\n\n        state.output = state.output.slice(0, -(prior.output + prev.output).length);\n        prior.output = `(?:${prior.output}`;\n\n        prev.type = 'globstar';\n        prev.output = `${globstar(opts)}${SLASH_LITERAL}|${SLASH_LITERAL}${end})`;\n        prev.value += value;\n\n        state.output += prior.output + prev.output;\n        state.globstar = true;\n\n        consume(value + advance());\n\n        push({ type: 'slash', value: '/', output: '' });\n        continue;\n      }\n\n      if (prior.type === 'bos' && rest[0] === '/') {\n        prev.type = 'globstar';\n        prev.value += value;\n        prev.output = `(?:^|${SLASH_LITERAL}|${globstar(opts)}${SLASH_LITERAL})`;\n        state.output = prev.output;\n        state.globstar = true;\n        consume(value + advance());\n        push({ type: 'slash', value: '/', output: '' });\n        continue;\n      }\n\n      // remove single star from output\n      state.output = state.output.slice(0, -prev.output.length);\n\n      // reset previous token to globstar\n      prev.type = 'globstar';\n      prev.output = globstar(opts);\n      prev.value += value;\n\n      // reset output with globstar\n      state.output += prev.output;\n      state.globstar = true;\n      consume(value);\n      continue;\n    }\n\n    const token = { type: 'star', value, output: star };\n\n    if (opts.bash === true) {\n      token.output = '.*?';\n      if (prev.type === 'bos' || prev.type === 'slash') {\n        token.output = nodot + token.output;\n      }\n      push(token);\n      continue;\n    }\n\n    if (prev && (prev.type === 'bracket' || prev.type === 'paren') && opts.regex === true) {\n      token.output = value;\n      push(token);\n      continue;\n    }\n\n    if (state.index === state.start || prev.type === 'slash' || prev.type === 'dot') {\n      if (prev.type === 'dot') {\n        state.output += NO_DOT_SLASH;\n        prev.output += NO_DOT_SLASH;\n\n      } else if (opts.dot === true) {\n        state.output += NO_DOTS_SLASH;\n        prev.output += NO_DOTS_SLASH;\n\n      } else {\n        state.output += nodot;\n        prev.output += nodot;\n      }\n\n      if (peek() !== '*') {\n        state.output += ONE_CHAR;\n        prev.output += ONE_CHAR;\n      }\n    }\n\n    push(token);\n  }\n\n  while (state.brackets > 0) {\n    if (opts.strictBrackets === true) throw new SyntaxError(syntaxError('closing', ']'));\n    state.output = utils.escapeLast(state.output, '[');\n    decrement('brackets');\n  }\n\n  while (state.parens > 0) {\n    if (opts.strictBrackets === true) throw new SyntaxError(syntaxError('closing', ')'));\n    state.output = utils.escapeLast(state.output, '(');\n    decrement('parens');\n  }\n\n  while (state.braces > 0) {\n    if (opts.strictBrackets === true) throw new SyntaxError(syntaxError('closing', '}'));\n    state.output = utils.escapeLast(state.output, '{');\n    decrement('braces');\n  }\n\n  if (opts.strictSlashes !== true && (prev.type === 'star' || prev.type === 'bracket')) {\n    push({ type: 'maybe_slash', value: '', output: `${SLASH_LITERAL}?` });\n  }\n\n  // rebuild the output if we had to backtrack at any point\n  if (state.backtrack === true) {\n    state.output = '';\n\n    for (const token of state.tokens) {\n      state.output += token.output != null ? token.output : token.value;\n\n      if (token.suffix) {\n        state.output += token.suffix;\n      }\n    }\n  }\n\n  return state;\n};\n\n/**\n * Fast paths for creating regular expressions for common glob patterns.\n * This can significantly speed up processing and has very little downside\n * impact when none of the fast paths match.\n */\n\nparse.fastpaths = (input, options) => {\n  const opts = { ...options };\n  const max = typeof opts.maxLength === 'number' ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;\n  const len = input.length;\n  if (len > max) {\n    throw new SyntaxError(`Input length: ${len}, exceeds maximum allowed length: ${max}`);\n  }\n\n  input = REPLACEMENTS[input] || input;\n  const win32 = utils.isWindows(options);\n\n  // create constants based on platform, for windows or posix\n  const {\n    DOT_LITERAL,\n    SLASH_LITERAL,\n    ONE_CHAR,\n    DOTS_SLASH,\n    NO_DOT,\n    NO_DOTS,\n    NO_DOTS_SLASH,\n    STAR,\n    START_ANCHOR\n  } = constants.globChars(win32);\n\n  const nodot = opts.dot ? NO_DOTS : NO_DOT;\n  const slashDot = opts.dot ? NO_DOTS_SLASH : NO_DOT;\n  const capture = opts.capture ? '' : '?:';\n  const state = { negated: false, prefix: '' };\n  let star = opts.bash === true ? '.*?' : STAR;\n\n  if (opts.capture) {\n    star = `(${star})`;\n  }\n\n  const globstar = (opts) => {\n    if (opts.noglobstar === true) return star;\n    return `(${capture}(?:(?!${START_ANCHOR}${opts.dot ? DOTS_SLASH : DOT_LITERAL}).)*?)`;\n  };\n\n  const create = str => {\n    switch (str) {\n      case '*':\n        return `${nodot}${ONE_CHAR}${star}`;\n\n      case '.*':\n        return `${DOT_LITERAL}${ONE_CHAR}${star}`;\n\n      case '*.*':\n        return `${nodot}${star}${DOT_LITERAL}${ONE_CHAR}${star}`;\n\n      case '*/*':\n        return `${nodot}${star}${SLASH_LITERAL}${ONE_CHAR}${slashDot}${star}`;\n\n      case '**':\n        return nodot + globstar(opts);\n\n      case '**/*':\n        return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${slashDot}${ONE_CHAR}${star}`;\n\n      case '**/*.*':\n        return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${slashDot}${star}${DOT_LITERAL}${ONE_CHAR}${star}`;\n\n      case '**/.*':\n        return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${DOT_LITERAL}${ONE_CHAR}${star}`;\n\n      default: {\n        const match = /^(.*?)\\.(\\w+)$/.exec(str);\n        if (!match) return;\n\n        const source = create(match[1]);\n        if (!source) return;\n\n        return source + DOT_LITERAL + match[2];\n      }\n    }\n  };\n\n  const output = utils.removePrefix(input, state);\n  let source = create(output);\n\n  if (source && opts.strictSlashes !== true) {\n    source += `${SLASH_LITERAL}?`;\n  }\n\n  return source;\n};\n\nmodule.exports = parse;\n","'use strict';\n\nconst path = require('path');\nconst scan = require('./scan');\nconst parse = require('./parse');\nconst utils = require('./utils');\nconst constants = require('./constants');\nconst isObject = val => val && typeof val === 'object' && !Array.isArray(val);\n\n/**\n * Creates a matcher function from one or more glob patterns. The\n * returned function takes a string to match as its first argument,\n * and returns true if the string is a match. The returned matcher\n * function also takes a boolean as the second argument that, when true,\n * returns an object with additional information.\n *\n * ```js\n * const picomatch = require('picomatch');\n * // picomatch(glob[, options]);\n *\n * const isMatch = picomatch('*.!(*a)');\n * console.log(isMatch('a.a')); //=> false\n * console.log(isMatch('a.b')); //=> true\n * ```\n * @name picomatch\n * @param {String|Array} `globs` One or more glob patterns.\n * @param {Object=} `options`\n * @return {Function=} Returns a matcher function.\n * @api public\n */\n\nconst picomatch = (glob, options, returnState = false) => {\n  if (Array.isArray(glob)) {\n    const fns = glob.map(input => picomatch(input, options, returnState));\n    const arrayMatcher = str => {\n      for (const isMatch of fns) {\n        const state = isMatch(str);\n        if (state) return state;\n      }\n      return false;\n    };\n    return arrayMatcher;\n  }\n\n  const isState = isObject(glob) && glob.tokens && glob.input;\n\n  if (glob === '' || (typeof glob !== 'string' && !isState)) {\n    throw new TypeError('Expected pattern to be a non-empty string');\n  }\n\n  const opts = options || {};\n  const posix = utils.isWindows(options);\n  const regex = isState\n    ? picomatch.compileRe(glob, options)\n    : picomatch.makeRe(glob, options, false, true);\n\n  const state = regex.state;\n  delete regex.state;\n\n  let isIgnored = () => false;\n  if (opts.ignore) {\n    const ignoreOpts = { ...options, ignore: null, onMatch: null, onResult: null };\n    isIgnored = picomatch(opts.ignore, ignoreOpts, returnState);\n  }\n\n  const matcher = (input, returnObject = false) => {\n    const { isMatch, match, output } = picomatch.test(input, regex, options, { glob, posix });\n    const result = { glob, state, regex, posix, input, output, match, isMatch };\n\n    if (typeof opts.onResult === 'function') {\n      opts.onResult(result);\n    }\n\n    if (isMatch === false) {\n      result.isMatch = false;\n      return returnObject ? result : false;\n    }\n\n    if (isIgnored(input)) {\n      if (typeof opts.onIgnore === 'function') {\n        opts.onIgnore(result);\n      }\n      result.isMatch = false;\n      return returnObject ? result : false;\n    }\n\n    if (typeof opts.onMatch === 'function') {\n      opts.onMatch(result);\n    }\n    return returnObject ? result : true;\n  };\n\n  if (returnState) {\n    matcher.state = state;\n  }\n\n  return matcher;\n};\n\n/**\n * Test `input` with the given `regex`. This is used by the main\n * `picomatch()` function to test the input string.\n *\n * ```js\n * const picomatch = require('picomatch');\n * // picomatch.test(input, regex[, options]);\n *\n * console.log(picomatch.test('foo/bar', /^(?:([^/]*?)\\/([^/]*?))$/));\n * // { isMatch: true, match: [ 'foo/', 'foo', 'bar' ], output: 'foo/bar' }\n * ```\n * @param {String} `input` String to test.\n * @param {RegExp} `regex`\n * @return {Object} Returns an object with matching info.\n * @api public\n */\n\npicomatch.test = (input, regex, options, { glob, posix } = {}) => {\n  if (typeof input !== 'string') {\n    throw new TypeError('Expected input to be a string');\n  }\n\n  if (input === '') {\n    return { isMatch: false, output: '' };\n  }\n\n  const opts = options || {};\n  const format = opts.format || (posix ? utils.toPosixSlashes : null);\n  let match = input === glob;\n  let output = (match && format) ? format(input) : input;\n\n  if (match === false) {\n    output = format ? format(input) : input;\n    match = output === glob;\n  }\n\n  if (match === false || opts.capture === true) {\n    if (opts.matchBase === true || opts.basename === true) {\n      match = picomatch.matchBase(input, regex, options, posix);\n    } else {\n      match = regex.exec(output);\n    }\n  }\n\n  return { isMatch: Boolean(match), match, output };\n};\n\n/**\n * Match the basename of a filepath.\n *\n * ```js\n * const picomatch = require('picomatch');\n * // picomatch.matchBase(input, glob[, options]);\n * console.log(picomatch.matchBase('foo/bar.js', '*.js'); // true\n * ```\n * @param {String} `input` String to test.\n * @param {RegExp|String} `glob` Glob pattern or regex created by [.makeRe](#makeRe).\n * @return {Boolean}\n * @api public\n */\n\npicomatch.matchBase = (input, glob, options, posix = utils.isWindows(options)) => {\n  const regex = glob instanceof RegExp ? glob : picomatch.makeRe(glob, options);\n  return regex.test(path.basename(input));\n};\n\n/**\n * Returns true if **any** of the given glob `patterns` match the specified `string`.\n *\n * ```js\n * const picomatch = require('picomatch');\n * // picomatch.isMatch(string, patterns[, options]);\n *\n * console.log(picomatch.isMatch('a.a', ['b.*', '*.a'])); //=> true\n * console.log(picomatch.isMatch('a.a', 'b.*')); //=> false\n * ```\n * @param {String|Array} str The string to test.\n * @param {String|Array} patterns One or more glob patterns to use for matching.\n * @param {Object} [options] See available [options](#options).\n * @return {Boolean} Returns true if any patterns match `str`\n * @api public\n */\n\npicomatch.isMatch = (str, patterns, options) => picomatch(patterns, options)(str);\n\n/**\n * Parse a glob pattern to create the source string for a regular\n * expression.\n *\n * ```js\n * const picomatch = require('picomatch');\n * const result = picomatch.parse(pattern[, options]);\n * ```\n * @param {String} `pattern`\n * @param {Object} `options`\n * @return {Object} Returns an object with useful properties and output to be used as a regex source string.\n * @api public\n */\n\npicomatch.parse = (pattern, options) => {\n  if (Array.isArray(pattern)) return pattern.map(p => picomatch.parse(p, options));\n  return parse(pattern, { ...options, fastpaths: false });\n};\n\n/**\n * Scan a glob pattern to separate the pattern into segments.\n *\n * ```js\n * const picomatch = require('picomatch');\n * // picomatch.scan(input[, options]);\n *\n * const result = picomatch.scan('!./foo/*.js');\n * console.log(result);\n * { prefix: '!./',\n *   input: '!./foo/*.js',\n *   start: 3,\n *   base: 'foo',\n *   glob: '*.js',\n *   isBrace: false,\n *   isBracket: false,\n *   isGlob: true,\n *   isExtglob: false,\n *   isGlobstar: false,\n *   negated: true }\n * ```\n * @param {String} `input` Glob pattern to scan.\n * @param {Object} `options`\n * @return {Object} Returns an object with\n * @api public\n */\n\npicomatch.scan = (input, options) => scan(input, options);\n\n/**\n * Create a regular expression from a parsed glob pattern.\n *\n * ```js\n * const picomatch = require('picomatch');\n * const state = picomatch.parse('*.js');\n * // picomatch.compileRe(state[, options]);\n *\n * console.log(picomatch.compileRe(state));\n * //=> /^(?:(?!\\.)(?=.)[^/]*?\\.js)$/\n * ```\n * @param {String} `state` The object returned from the `.parse` method.\n * @param {Object} `options`\n * @return {RegExp} Returns a regex created from the given pattern.\n * @api public\n */\n\npicomatch.compileRe = (parsed, options, returnOutput = false, returnState = false) => {\n  if (returnOutput === true) {\n    return parsed.output;\n  }\n\n  const opts = options || {};\n  const prepend = opts.contains ? '' : '^';\n  const append = opts.contains ? '' : '$';\n\n  let source = `${prepend}(?:${parsed.output})${append}`;\n  if (parsed && parsed.negated === true) {\n    source = `^(?!${source}).*$`;\n  }\n\n  const regex = picomatch.toRegex(source, options);\n  if (returnState === true) {\n    regex.state = parsed;\n  }\n\n  return regex;\n};\n\npicomatch.makeRe = (input, options, returnOutput = false, returnState = false) => {\n  if (!input || typeof input !== 'string') {\n    throw new TypeError('Expected a non-empty string');\n  }\n\n  const opts = options || {};\n  let parsed = { negated: false, fastpaths: true };\n  let prefix = '';\n  let output;\n\n  if (input.startsWith('./')) {\n    input = input.slice(2);\n    prefix = parsed.prefix = './';\n  }\n\n  if (opts.fastpaths !== false && (input[0] === '.' || input[0] === '*')) {\n    output = parse.fastpaths(input, options);\n  }\n\n  if (output === undefined) {\n    parsed = parse(input, options);\n    parsed.prefix = prefix + (parsed.prefix || '');\n  } else {\n    parsed.output = output;\n  }\n\n  return picomatch.compileRe(parsed, options, returnOutput, returnState);\n};\n\n/**\n * Create a regular expression from the given regex source string.\n *\n * ```js\n * const picomatch = require('picomatch');\n * // picomatch.toRegex(source[, options]);\n *\n * const { output } = picomatch.parse('*.js');\n * console.log(picomatch.toRegex(output));\n * //=> /^(?:(?!\\.)(?=.)[^/]*?\\.js)$/\n * ```\n * @param {String} `source` Regular expression source string.\n * @param {Object} `options`\n * @return {RegExp}\n * @api public\n */\n\npicomatch.toRegex = (source, options) => {\n  try {\n    const opts = options || {};\n    return new RegExp(source, opts.flags || (opts.nocase ? 'i' : ''));\n  } catch (err) {\n    if (options && options.debug === true) throw err;\n    return /$^/;\n  }\n};\n\n/**\n * Picomatch constants.\n * @return {Object}\n */\n\npicomatch.constants = constants;\n\n/**\n * Expose \"picomatch\"\n */\n\nmodule.exports = picomatch;\n","'use strict';\n\nconst utils = require('./utils');\nconst {\n  CHAR_ASTERISK,             /* * */\n  CHAR_AT,                   /* @ */\n  CHAR_BACKWARD_SLASH,       /* \\ */\n  CHAR_COMMA,                /* , */\n  CHAR_DOT,                  /* . */\n  CHAR_EXCLAMATION_MARK,     /* ! */\n  CHAR_FORWARD_SLASH,        /* / */\n  CHAR_LEFT_CURLY_BRACE,     /* { */\n  CHAR_LEFT_PARENTHESES,     /* ( */\n  CHAR_LEFT_SQUARE_BRACKET,  /* [ */\n  CHAR_PLUS,                 /* + */\n  CHAR_QUESTION_MARK,        /* ? */\n  CHAR_RIGHT_CURLY_BRACE,    /* } */\n  CHAR_RIGHT_PARENTHESES,    /* ) */\n  CHAR_RIGHT_SQUARE_BRACKET  /* ] */\n} = require('./constants');\n\nconst isPathSeparator = code => {\n  return code === CHAR_FORWARD_SLASH || code === CHAR_BACKWARD_SLASH;\n};\n\nconst depth = token => {\n  if (token.isPrefix !== true) {\n    token.depth = token.isGlobstar ? Infinity : 1;\n  }\n};\n\n/**\n * Quickly scans a glob pattern and returns an object with a handful of\n * useful properties, like `isGlob`, `path` (the leading non-glob, if it exists),\n * `glob` (the actual pattern), and `negated` (true if the path starts with `!`).\n *\n * ```js\n * const pm = require('picomatch');\n * console.log(pm.scan('foo/bar/*.js'));\n * { isGlob: true, input: 'foo/bar/*.js', base: 'foo/bar', glob: '*.js' }\n * ```\n * @param {String} `str`\n * @param {Object} `options`\n * @return {Object} Returns an object with tokens and regex source string.\n * @api public\n */\n\nconst scan = (input, options) => {\n  const opts = options || {};\n\n  const length = input.length - 1;\n  const scanToEnd = opts.parts === true || opts.scanToEnd === true;\n  const slashes = [];\n  const tokens = [];\n  const parts = [];\n\n  let str = input;\n  let index = -1;\n  let start = 0;\n  let lastIndex = 0;\n  let isBrace = false;\n  let isBracket = false;\n  let isGlob = false;\n  let isExtglob = false;\n  let isGlobstar = false;\n  let braceEscaped = false;\n  let backslashes = false;\n  let negated = false;\n  let finished = false;\n  let braces = 0;\n  let prev;\n  let code;\n  let token = { value: '', depth: 0, isGlob: false };\n\n  const eos = () => index >= length;\n  const peek = () => str.charCodeAt(index + 1);\n  const advance = () => {\n    prev = code;\n    return str.charCodeAt(++index);\n  };\n\n  while (index < length) {\n    code = advance();\n    let next;\n\n    if (code === CHAR_BACKWARD_SLASH) {\n      backslashes = token.backslashes = true;\n      code = advance();\n\n      if (code === CHAR_LEFT_CURLY_BRACE) {\n        braceEscaped = true;\n      }\n      continue;\n    }\n\n    if (braceEscaped === true || code === CHAR_LEFT_CURLY_BRACE) {\n      braces++;\n\n      while (eos() !== true && (code = advance())) {\n        if (code === CHAR_BACKWARD_SLASH) {\n          backslashes = token.backslashes = true;\n          advance();\n          continue;\n        }\n\n        if (code === CHAR_LEFT_CURLY_BRACE) {\n          braces++;\n          continue;\n        }\n\n        if (braceEscaped !== true && code === CHAR_DOT && (code = advance()) === CHAR_DOT) {\n          isBrace = token.isBrace = true;\n          isGlob = token.isGlob = true;\n          finished = true;\n\n          if (scanToEnd === true) {\n            continue;\n          }\n\n          break;\n        }\n\n        if (braceEscaped !== true && code === CHAR_COMMA) {\n          isBrace = token.isBrace = true;\n          isGlob = token.isGlob = true;\n          finished = true;\n\n          if (scanToEnd === true) {\n            continue;\n          }\n\n          break;\n        }\n\n        if (code === CHAR_RIGHT_CURLY_BRACE) {\n          braces--;\n\n          if (braces === 0) {\n            braceEscaped = false;\n            isBrace = token.isBrace = true;\n            finished = true;\n            break;\n          }\n        }\n      }\n\n      if (scanToEnd === true) {\n        continue;\n      }\n\n      break;\n    }\n\n    if (code === CHAR_FORWARD_SLASH) {\n      slashes.push(index);\n      tokens.push(token);\n      token = { value: '', depth: 0, isGlob: false };\n\n      if (finished === true) continue;\n      if (prev === CHAR_DOT && index === (start + 1)) {\n        start += 2;\n        continue;\n      }\n\n      lastIndex = index + 1;\n      continue;\n    }\n\n    if (opts.noext !== true) {\n      const isExtglobChar = code === CHAR_PLUS\n        || code === CHAR_AT\n        || code === CHAR_ASTERISK\n        || code === CHAR_QUESTION_MARK\n        || code === CHAR_EXCLAMATION_MARK;\n\n      if (isExtglobChar === true && peek() === CHAR_LEFT_PARENTHESES) {\n        isGlob = token.isGlob = true;\n        isExtglob = token.isExtglob = true;\n        finished = true;\n\n        if (scanToEnd === true) {\n          while (eos() !== true && (code = advance())) {\n            if (code === CHAR_BACKWARD_SLASH) {\n              backslashes = token.backslashes = true;\n              code = advance();\n              continue;\n            }\n\n            if (code === CHAR_RIGHT_PARENTHESES) {\n              isGlob = token.isGlob = true;\n              finished = true;\n              break;\n            }\n          }\n          continue;\n        }\n        break;\n      }\n    }\n\n    if (code === CHAR_ASTERISK) {\n      if (prev === CHAR_ASTERISK) isGlobstar = token.isGlobstar = true;\n      isGlob = token.isGlob = true;\n      finished = true;\n\n      if (scanToEnd === true) {\n        continue;\n      }\n      break;\n    }\n\n    if (code === CHAR_QUESTION_MARK) {\n      isGlob = token.isGlob = true;\n      finished = true;\n\n      if (scanToEnd === true) {\n        continue;\n      }\n      break;\n    }\n\n    if (code === CHAR_LEFT_SQUARE_BRACKET) {\n      while (eos() !== true && (next = advance())) {\n        if (next === CHAR_BACKWARD_SLASH) {\n          backslashes = token.backslashes = true;\n          advance();\n          continue;\n        }\n\n        if (next === CHAR_RIGHT_SQUARE_BRACKET) {\n          isBracket = token.isBracket = true;\n          isGlob = token.isGlob = true;\n          finished = true;\n\n          if (scanToEnd === true) {\n            continue;\n          }\n          break;\n        }\n      }\n    }\n\n    if (opts.nonegate !== true && code === CHAR_EXCLAMATION_MARK && index === start) {\n      negated = token.negated = true;\n      start++;\n      continue;\n    }\n\n    if (opts.noparen !== true && code === CHAR_LEFT_PARENTHESES) {\n      isGlob = token.isGlob = true;\n\n      if (scanToEnd === true) {\n        while (eos() !== true && (code = advance())) {\n          if (code === CHAR_LEFT_PARENTHESES) {\n            backslashes = token.backslashes = true;\n            code = advance();\n            continue;\n          }\n\n          if (code === CHAR_RIGHT_PARENTHESES) {\n            finished = true;\n            break;\n          }\n        }\n        continue;\n      }\n      break;\n    }\n\n    if (isGlob === true) {\n      finished = true;\n\n      if (scanToEnd === true) {\n        continue;\n      }\n\n      break;\n    }\n  }\n\n  if (opts.noext === true) {\n    isExtglob = false;\n    isGlob = false;\n  }\n\n  let base = str;\n  let prefix = '';\n  let glob = '';\n\n  if (start > 0) {\n    prefix = str.slice(0, start);\n    str = str.slice(start);\n    lastIndex -= start;\n  }\n\n  if (base && isGlob === true && lastIndex > 0) {\n    base = str.slice(0, lastIndex);\n    glob = str.slice(lastIndex);\n  } else if (isGlob === true) {\n    base = '';\n    glob = str;\n  } else {\n    base = str;\n  }\n\n  if (base && base !== '' && base !== '/' && base !== str) {\n    if (isPathSeparator(base.charCodeAt(base.length - 1))) {\n      base = base.slice(0, -1);\n    }\n  }\n\n  if (opts.unescape === true) {\n    if (glob) glob = utils.removeBackslashes(glob);\n\n    if (base && backslashes === true) {\n      base = utils.removeBackslashes(base);\n    }\n  }\n\n  const state = {\n    prefix,\n    input,\n    start,\n    base,\n    glob,\n    isBrace,\n    isBracket,\n    isGlob,\n    isExtglob,\n    isGlobstar,\n    negated\n  };\n\n  if (opts.tokens === true) {\n    state.maxDepth = 0;\n    if (!isPathSeparator(code)) {\n      tokens.push(token);\n    }\n    state.tokens = tokens;\n  }\n\n  if (opts.parts === true || opts.tokens === true) {\n    let prevIndex;\n\n    for (let idx = 0; idx < slashes.length; idx++) {\n      const n = prevIndex ? prevIndex + 1 : start;\n      const i = slashes[idx];\n      const value = input.slice(n, i);\n      if (opts.tokens) {\n        if (idx === 0 && start !== 0) {\n          tokens[idx].isPrefix = true;\n          tokens[idx].value = prefix;\n        } else {\n          tokens[idx].value = value;\n        }\n        depth(tokens[idx]);\n        state.maxDepth += tokens[idx].depth;\n      }\n      if (idx !== 0 || value !== '') {\n        parts.push(value);\n      }\n      prevIndex = i;\n    }\n\n    if (prevIndex && prevIndex + 1 < input.length) {\n      const value = input.slice(prevIndex + 1);\n      parts.push(value);\n\n      if (opts.tokens) {\n        tokens[tokens.length - 1].value = value;\n        depth(tokens[tokens.length - 1]);\n        state.maxDepth += tokens[tokens.length - 1].depth;\n      }\n    }\n\n    state.slashes = slashes;\n    state.parts = parts;\n  }\n\n  return state;\n};\n\nmodule.exports = scan;\n","'use strict';\n\nconst path = require('path');\nconst win32 = process.platform === 'win32';\nconst {\n  REGEX_BACKSLASH,\n  REGEX_REMOVE_BACKSLASH,\n  REGEX_SPECIAL_CHARS,\n  REGEX_SPECIAL_CHARS_GLOBAL\n} = require('./constants');\n\nexports.isObject = val => val !== null && typeof val === 'object' && !Array.isArray(val);\nexports.hasRegexChars = str => REGEX_SPECIAL_CHARS.test(str);\nexports.isRegexChar = str => str.length === 1 && exports.hasRegexChars(str);\nexports.escapeRegex = str => str.replace(REGEX_SPECIAL_CHARS_GLOBAL, '\\\\$1');\nexports.toPosixSlashes = str => str.replace(REGEX_BACKSLASH, '/');\n\nexports.removeBackslashes = str => {\n  return str.replace(REGEX_REMOVE_BACKSLASH, match => {\n    return match === '\\\\' ? '' : match;\n  });\n};\n\nexports.supportsLookbehinds = () => {\n  const segs = process.version.slice(1).split('.').map(Number);\n  if (segs.length === 3 && segs[0] >= 9 || (segs[0] === 8 && segs[1] >= 10)) {\n    return true;\n  }\n  return false;\n};\n\nexports.isWindows = options => {\n  if (options && typeof options.windows === 'boolean') {\n    return options.windows;\n  }\n  return win32 === true || path.sep === '\\\\';\n};\n\nexports.escapeLast = (input, char, lastIdx) => {\n  const idx = input.lastIndexOf(char, lastIdx);\n  if (idx === -1) return input;\n  if (input[idx - 1] === '\\\\') return exports.escapeLast(input, char, idx - 1);\n  return `${input.slice(0, idx)}\\\\${input.slice(idx)}`;\n};\n\nexports.removePrefix = (input, state = {}) => {\n  let output = input;\n  if (output.startsWith('./')) {\n    output = output.slice(2);\n    state.prefix = './';\n  }\n  return output;\n};\n\nexports.wrapOutput = (input, state = {}, options = {}) => {\n  const prepend = options.contains ? '' : '^';\n  const append = options.contains ? '' : '$';\n\n  let output = `${prepend}(?:${input})${append}`;\n  if (state.negated === true) {\n    output = `(?:^(?!${output}).*$)`;\n  }\n  return output;\n};\n","'use strict'\n\nfunction reusify (Constructor) {\n  var head = new Constructor()\n  var tail = head\n\n  function get () {\n    var current = head\n\n    if (current.next) {\n      head = current.next\n    } else {\n      head = new Constructor()\n      tail = head\n    }\n\n    current.next = null\n\n    return current\n  }\n\n  function release (obj) {\n    tail.next = obj\n    tail = obj\n  }\n\n  return {\n    get: get,\n    release: release\n  }\n}\n\nmodule.exports = reusify\n","/*! run-parallel. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */\nmodule.exports = runParallel\n\nfunction runParallel (tasks, cb) {\n  var results, pending, keys\n  var isSync = true\n\n  if (Array.isArray(tasks)) {\n    results = []\n    pending = tasks.length\n  } else {\n    keys = Object.keys(tasks)\n    results = {}\n    pending = keys.length\n  }\n\n  function done (err) {\n    function end () {\n      if (cb) cb(err, results)\n      cb = null\n    }\n    if (isSync) process.nextTick(end)\n    else end()\n  }\n\n  function each (i, err, result) {\n    results[i] = result\n    if (--pending === 0 || err) {\n      done(err)\n    }\n  }\n\n  if (!pending) {\n    // empty\n    done(null)\n  } else if (keys) {\n    // object\n    keys.forEach(function (key) {\n      tasks[key](function (err, result) { each(key, err, result) })\n    })\n  } else {\n    // array\n    tasks.forEach(function (task, i) {\n      task(function (err, result) { each(i, err, result) })\n    })\n  }\n\n  isSync = false\n}\n","'use strict';\nmodule.exports = path => {\n\tconst isExtendedLengthPath = /^\\\\\\\\\\?\\\\/.test(path);\n\tconst hasNonAscii = /[^\\u0000-\\u0080]+/.test(path); // eslint-disable-line no-control-regex\n\n\tif (isExtendedLengthPath || hasNonAscii) {\n\t\treturn path;\n\t}\n\n\treturn path.replace(/\\\\/g, '/');\n};\n","/*!\n * to-regex-range <https://github.com/micromatch/to-regex-range>\n *\n * Copyright (c) 2015-present, Jon Schlinkert.\n * Released under the MIT License.\n */\n\n'use strict';\n\nconst isNumber = require('is-number');\n\nconst toRegexRange = (min, max, options) => {\n  if (isNumber(min) === false) {\n    throw new TypeError('toRegexRange: expected the first argument to be a number');\n  }\n\n  if (max === void 0 || min === max) {\n    return String(min);\n  }\n\n  if (isNumber(max) === false) {\n    throw new TypeError('toRegexRange: expected the second argument to be a number.');\n  }\n\n  let opts = { relaxZeros: true, ...options };\n  if (typeof opts.strictZeros === 'boolean') {\n    opts.relaxZeros = opts.strictZeros === false;\n  }\n\n  let relax = String(opts.relaxZeros);\n  let shorthand = String(opts.shorthand);\n  let capture = String(opts.capture);\n  let wrap = String(opts.wrap);\n  let cacheKey = min + ':' + max + '=' + relax + shorthand + capture + wrap;\n\n  if (toRegexRange.cache.hasOwnProperty(cacheKey)) {\n    return toRegexRange.cache[cacheKey].result;\n  }\n\n  let a = Math.min(min, max);\n  let b = Math.max(min, max);\n\n  if (Math.abs(a - b) === 1) {\n    let result = min + '|' + max;\n    if (opts.capture) {\n      return `(${result})`;\n    }\n    if (opts.wrap === false) {\n      return result;\n    }\n    return `(?:${result})`;\n  }\n\n  let isPadded = hasPadding(min) || hasPadding(max);\n  let state = { min, max, a, b };\n  let positives = [];\n  let negatives = [];\n\n  if (isPadded) {\n    state.isPadded = isPadded;\n    state.maxLen = String(state.max).length;\n  }\n\n  if (a < 0) {\n    let newMin = b < 0 ? Math.abs(b) : 1;\n    negatives = splitToPatterns(newMin, Math.abs(a), state, opts);\n    a = state.a = 0;\n  }\n\n  if (b >= 0) {\n    positives = splitToPatterns(a, b, state, opts);\n  }\n\n  state.negatives = negatives;\n  state.positives = positives;\n  state.result = collatePatterns(negatives, positives, opts);\n\n  if (opts.capture === true) {\n    state.result = `(${state.result})`;\n  } else if (opts.wrap !== false && (positives.length + negatives.length) > 1) {\n    state.result = `(?:${state.result})`;\n  }\n\n  toRegexRange.cache[cacheKey] = state;\n  return state.result;\n};\n\nfunction collatePatterns(neg, pos, options) {\n  let onlyNegative = filterPatterns(neg, pos, '-', false, options) || [];\n  let onlyPositive = filterPatterns(pos, neg, '', false, options) || [];\n  let intersected = filterPatterns(neg, pos, '-?', true, options) || [];\n  let subpatterns = onlyNegative.concat(intersected).concat(onlyPositive);\n  return subpatterns.join('|');\n}\n\nfunction splitToRanges(min, max) {\n  let nines = 1;\n  let zeros = 1;\n\n  let stop = countNines(min, nines);\n  let stops = new Set([max]);\n\n  while (min <= stop && stop <= max) {\n    stops.add(stop);\n    nines += 1;\n    stop = countNines(min, nines);\n  }\n\n  stop = countZeros(max + 1, zeros) - 1;\n\n  while (min < stop && stop <= max) {\n    stops.add(stop);\n    zeros += 1;\n    stop = countZeros(max + 1, zeros) - 1;\n  }\n\n  stops = [...stops];\n  stops.sort(compare);\n  return stops;\n}\n\n/**\n * Convert a range to a regex pattern\n * @param {Number} `start`\n * @param {Number} `stop`\n * @return {String}\n */\n\nfunction rangeToPattern(start, stop, options) {\n  if (start === stop) {\n    return { pattern: start, count: [], digits: 0 };\n  }\n\n  let zipped = zip(start, stop);\n  let digits = zipped.length;\n  let pattern = '';\n  let count = 0;\n\n  for (let i = 0; i < digits; i++) {\n    let [startDigit, stopDigit] = zipped[i];\n\n    if (startDigit === stopDigit) {\n      pattern += startDigit;\n\n    } else if (startDigit !== '0' || stopDigit !== '9') {\n      pattern += toCharacterClass(startDigit, stopDigit, options);\n\n    } else {\n      count++;\n    }\n  }\n\n  if (count) {\n    pattern += options.shorthand === true ? '\\\\d' : '[0-9]';\n  }\n\n  return { pattern, count: [count], digits };\n}\n\nfunction splitToPatterns(min, max, tok, options) {\n  let ranges = splitToRanges(min, max);\n  let tokens = [];\n  let start = min;\n  let prev;\n\n  for (let i = 0; i < ranges.length; i++) {\n    let max = ranges[i];\n    let obj = rangeToPattern(String(start), String(max), options);\n    let zeros = '';\n\n    if (!tok.isPadded && prev && prev.pattern === obj.pattern) {\n      if (prev.count.length > 1) {\n        prev.count.pop();\n      }\n\n      prev.count.push(obj.count[0]);\n      prev.string = prev.pattern + toQuantifier(prev.count);\n      start = max + 1;\n      continue;\n    }\n\n    if (tok.isPadded) {\n      zeros = padZeros(max, tok, options);\n    }\n\n    obj.string = zeros + obj.pattern + toQuantifier(obj.count);\n    tokens.push(obj);\n    start = max + 1;\n    prev = obj;\n  }\n\n  return tokens;\n}\n\nfunction filterPatterns(arr, comparison, prefix, intersection, options) {\n  let result = [];\n\n  for (let ele of arr) {\n    let { string } = ele;\n\n    // only push if _both_ are negative...\n    if (!intersection && !contains(comparison, 'string', string)) {\n      result.push(prefix + string);\n    }\n\n    // or _both_ are positive\n    if (intersection && contains(comparison, 'string', string)) {\n      result.push(prefix + string);\n    }\n  }\n  return result;\n}\n\n/**\n * Zip strings\n */\n\nfunction zip(a, b) {\n  let arr = [];\n  for (let i = 0; i < a.length; i++) arr.push([a[i], b[i]]);\n  return arr;\n}\n\nfunction compare(a, b) {\n  return a > b ? 1 : b > a ? -1 : 0;\n}\n\nfunction contains(arr, key, val) {\n  return arr.some(ele => ele[key] === val);\n}\n\nfunction countNines(min, len) {\n  return Number(String(min).slice(0, -len) + '9'.repeat(len));\n}\n\nfunction countZeros(integer, zeros) {\n  return integer - (integer % Math.pow(10, zeros));\n}\n\nfunction toQuantifier(digits) {\n  let [start = 0, stop = ''] = digits;\n  if (stop || start > 1) {\n    return `{${start + (stop ? ',' + stop : '')}}`;\n  }\n  return '';\n}\n\nfunction toCharacterClass(a, b, options) {\n  return `[${a}${(b - a === 1) ? '' : '-'}${b}]`;\n}\n\nfunction hasPadding(str) {\n  return /^-?(0+)\\d/.test(str);\n}\n\nfunction padZeros(value, tok, options) {\n  if (!tok.isPadded) {\n    return value;\n  }\n\n  let diff = Math.abs(tok.maxLen - String(value).length);\n  let relax = options.relaxZeros !== false;\n\n  switch (diff) {\n    case 0:\n      return '';\n    case 1:\n      return relax ? '0?' : '0';\n    case 2:\n      return relax ? '0{0,2}' : '00';\n    default: {\n      return relax ? `0{0,${diff}}` : `0{${diff}}`;\n    }\n  }\n}\n\n/**\n * Cache\n */\n\ntoRegexRange.cache = {};\ntoRegexRange.clearCache = () => (toRegexRange.cache = {});\n\n/**\n * Expose `toRegexRange`\n */\n\nmodule.exports = toRegexRange;\n",null,"module.exports = require(\"crypto\");;","module.exports = require(\"events\");;","module.exports = require(\"fs\");;","module.exports = require(\"http\");;","module.exports = require(\"https\");;","module.exports = require(\"os\");;","module.exports = require(\"path\");;","module.exports = require(\"stream\");;","module.exports = require(\"url\");;","module.exports = require(\"util\");;","module.exports = require(\"zlib\");;","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tif(__webpack_module_cache__[moduleId]) {\n\t\treturn __webpack_module_cache__[moduleId].exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\tvar threw = true;\n\ttry {\n\t\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\t\tthrew = false;\n\t} finally {\n\t\tif(threw) delete __webpack_module_cache__[moduleId];\n\t}\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","\n__webpack_require__.ab = __dirname + \"/\";","// module exports must be returned from runtime so entry inlining is disabled\n// startup\n// Load entry module and return exports\nreturn __webpack_require__(3109);\n"],"mappings":";;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;;ACpEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;;ACrCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;;ACZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;;AC/EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;;AC9OA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;;AC7BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;;ACnBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;;ACnBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;;ACdA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;;ACzBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;;AC3FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;;ACrDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;;ACzBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;;ACnBA;AACA;AACA;AACA;AACA;AACA;A;;;;;;ACLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;;ACjBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;;ACzBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;;AChCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;;ACvBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;;ACjBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;;ACjCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;;AC/BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;;AC/BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;;ACfA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;;AC9FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;;ACzBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;;ACZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;;AC5DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;;AC3BA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;;AC3KA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;;AC1DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;;AC1DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;;AClHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;;AC9UA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;;ACjCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;;ACjHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;;AC5EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;;ACvBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;;AC3qGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;;ACpdA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;;ACZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;;AC/NA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;;ACrDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;;AClFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;;AClCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;;ACpEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;;AClEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;;AC7BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;;AC/DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;;ACzDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;;AChBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;;ACnDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;;ACvCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;;ACjDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;;AChCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;;ACxBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;;AC3BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;;AClCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;;ACxDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;;AC5CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;;ACtDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;;ACvBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;;ACRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;;ACpBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;;AClBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;;AClCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;;ACrIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;;AClBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;;ACZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;;ACxMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;;AC1PA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;;AC1CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;;ACvHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;;AClLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;AC/CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;ACtlBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;ACrBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;;ACjDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;;ACnBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;;ACjJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;;ACpdA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;;AClnDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;;AC5CA;AACA;AACA;AACA;AACA;A;;;;;;ACJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;;ACpLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;;ACvjCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;;ACpVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;;AChYA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;;ACjEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;AClCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;;AClDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;;ACZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;ACjSA;AACA;AACA;A;;;;;;ACFA;AACA;A;;;;;;ACDA;AACA;A;;;;;;ACDA;AACA;A;;;;;;ACDA;AACA;A;;;;;;ACDA;AACA;A;;;;;;ACDA;AACA;A;;;;;;ACDA;AACA;A;;;;;;ACDA;AACA;A;;;;;;ACDA;AACA;A;;;;;;ACDA;AACA;A;;;;;;ACDA;AACA;A;;;;ACDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AC5BA;AACA;ACDA;AACA;AACA;AACA;;A","sourceRoot":""}